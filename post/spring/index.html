
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>Spring | KnowledgeBase</title>
<meta name="description" content="KnowledgeBase">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://sunxiaohang.github.io/favicon.ico?v=1586177596974">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://sunxiaohang.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://sunxiaohang.github.io">
        <img class="avatar" src="https://sunxiaohang.github.io/images/avatar.png?v=1586177596974" alt="" width="32px" height="32px">
      </a>
      <a href="https://sunxiaohang.github.io">
        <h1 class="site-title">KnowledgeBase</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
          <h2 class="post-title">Spring</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-04-06</span>
            
          </div>
          <div class="post-content">
            <p>主要是一些读书笔记，总结java web项目常用框架的一些实现细节和基础理论。</p>
<!-- more -->
<h4 id="jsp">JSP</h4>
<h5 id="jsp内置对象">JSP内置对象</h5>
<table>
<thead>
<tr>
<th>JSP内置对象</th>
<th>对象描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Out</td>
<td>向客户端对象输出数据</td>
</tr>
<tr>
<td>Request</td>
<td>向服务器提交数据</td>
</tr>
<tr>
<td>Response</td>
<td>服务器项目信息</td>
</tr>
<tr>
<td>Exception</td>
<td>异常信息</td>
</tr>
<tr>
<td>Config</td>
<td>配置信息</td>
</tr>
<tr>
<td>Page</td>
<td>指向当前page本身</td>
</tr>
<tr>
<td>Session</td>
<td>保存会话信息（统一用户的不同对象之间共享信息）</td>
</tr>
<tr>
<td>Application</td>
<td>上下文（不同用户间共享信息）</td>
</tr>
<tr>
<td>PageContext</td>
<td>队jsp页面所有对象及命名空间的访问</td>
</tr>
</tbody>
</table>
<h5 id="out对象">out对象</h5>
<p><code>out.flush()</code><br>
<code>out.clearBuffer</code><br>
<code>out.clear</code></p>
<pre><code>out.print(&quot;获取当前缓冲区大小：&quot;+out.getBufferSize());
out.print(&quot;当前缓冲区剩余字节数目&quot;+out.getRemaining());
</code></pre>
<h5 id="request对象">Request对象</h5>
<table>
<thead>
<tr>
<th>Request对象</th>
<th>对象描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="简单语法格式整理">简单语法格式整理</h5>
<pre><code>&lt;jsp:forward page=&quot;login.jsp&quot;&gt;
    &lt;jsp:param value=&quot;jikexueyuan&quot; name=&quot;username&quot;/&gt;
    &lt;jsp:param value=&quot;sunxiaohang&quot; name=&quot;password&quot;/&gt;
&lt;/jsp:forward&gt;
&lt;%@page errorPage=&quot;error_page.jsp&quot; isErrorPage=&quot;true&quot; %&gt;


  String username=request.getParameter(&quot;username&quot;);
    String password=request.getParameter(&quot;password&quot;);
    out.println(&quot;username &quot;+username);
    out.println(&quot;&lt;br/&gt;&quot;);
    out.println(&quot;password &quot;+password);

&lt;jsp:include page=&quot;body.jsp&quot;&gt;
    &lt;jsp:param name=&quot;bgcolor&quot; value=&quot;red&quot;/&gt;
&lt;/jsp:include&gt;

&lt;body bgcolor=&quot;&lt;%=request.getParameter(&quot;bgcolor&quot;)%&gt;&quot;&gt;
&lt;/body&gt;

&lt;jsp:useBean id=&quot;person&quot; class=&quot;Person&quot;&gt;&lt;/jsp:useBean&gt;
&lt;jsp:setProperty property=&quot;name&quot; name=&quot;person&quot;/&gt;
&lt;jsp:setProperty property=&quot;sex&quot; name=&quot;person&quot;/&gt;

&lt;jsp:getProperty property=&quot;name&quot; name=&quot;person&quot;/&gt;
&lt;jsp:getProperty property=&quot;sex&quot; name=&quot;person&quot;/&gt;
需要添加statdard.jar jstl.jar包
</code></pre>
<h5 id="spring内置对象">Spring内置对象</h5>
<pre><code>  response.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);//无缓存
    response.setIntHeader(&quot;refresh&quot;,2);//设置两秒钟自动刷新
    out.print(&quot;this date is :&quot;+new java.util.Date().toString()+&quot;&lt;br&gt;&quot;);
    response.sendRedirect(&quot;https://www.baidu.com&quot;);//重定向页面
    Cookie cookie=new Cookie(&quot;username&quot;,&quot;password&quot;);
    cookie.setMaxAge(3600);
    response.addCookie(cookie);
    session.getId();
</code></pre>
<h5 id="面向方面的程序设计aop">面向<code>方面</code>的程序设计（AOP）</h5>
<p>Spring框架的一个关键组件是面向方面的程序设计（AOP）框架。一个程序中跨越多个点的功能被称为<code>横切关注点</code>，其在概念上独立于应用程序的业务逻辑（sample：日志记录、声明性事务）</p>
<p><code>OOP</code>中模块化的关键单元是类，<code>AOP</code>中模块化的关键单元室方面。<code>AOP</code>帮助你将横切关注点从他们所影响的对象中分离出来，<code>依赖注入</code>帮助你将你的应用程序对象从彼此中分离出来。</p>
<ul>
<li>
<p><code>控制反转IOC</code><br>
在编写一个复杂的java程序时应用程序类应当尽可能的独立于其他的java类来增加这些类的可重用性，当进行单元测试时，可以使他们独立于其他类进行测试。</p>
</li>
<li>
<p><code>依赖注入DI</code><br>
依赖注入可以以向构造函数传递参数的方式发生，或者通过使用setter方法post-construction。</p>
</li>
</ul>
<h5 id="spring体系结构">Spring体系结构</h5>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/2480310-1638858c768bd15f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Spring体系框架图" loading="lazy"></figure>
<h5 id="核心容器">核心容器</h5>
<p>核心容器由核心、bean、上下文的表达式语言模块组成</p>
<ul>
<li><code>核心</code>提供框架的基本组成部分、包括IOC和依赖注入功能。</li>
<li><code>Bean</code>提供BeanFactory，工厂模式的复杂实现。</li>
<li><code>上下文</code>建立在由core和bean提供的坚实基础上，他是访问定义和配置的任何对象的媒介。ApplicationContext接口是上下文模块的重点。</li>
<li><code>表达式语言</code>模块在运行时提供了查询和操作一个对象图的强大的表达式语言</li>
</ul>
<h5 id="数据集成-访问">数据集成、访问</h5>
<ul>
<li><code>JDBC</code>提供删除冗余的JDBC相关编码的JDBC抽象层</li>
<li><code>ORC</code>为流行的对象关系映射API，包括JPA、JDO、Hibernate和iBatis提供集成层</li>
<li><code>OXM</code>提供抽象层、它支持对JAXB、Castor、XMLBeans，JiBx和XStream的对象/XML映射实现</li>
<li><code>JMS</code>java消息服务包含生产和消费的信息的功能</li>
<li><code>事务</code>事务模块为实现特殊接口的类及所有的POJO支持编程式和声明式事务管理</li>
</ul>
<h5 id="web">Web</h5>
<ul>
<li><code>Web</code>提供基本的面向web的集成功能，例如多个文件上传的功能和使用servlet监听器和面向web应用程序的上下文来初始化IOC容器</li>
<li><code>Web-MVC</code>包含Spring的模型-视图-控制（MVC），实现了web应用程序</li>
<li><code>Web-Socket</code>为<code>WebSocket-Based</code>提供支持，而且在web应用程序中提供客户端和服务器端之间的通信的两种方式。</li>
<li><code>Web-Portlet</code>提供在portlet环境中实现MVC，并且反映了Web-Servlet模块的功能。</li>
</ul>
<h5 id="spring实例">Spring实例</h5>
<ul>
<li>1.生成工厂对象，加载完指定路径下bean配置文件，利用框架提供的<code>FileSystemXmlApplicationContext</code> API生成工厂bean<code>FileSystemXmlApplicationContext</code>负责生成和初始化所有对象，比如：所有XML bean配置文件中的bean</li>
<li>利用第一步生成的上下文中的<code>getBean()</code>方法得到所需要的bean，这个方法通过配置中的<code>beanID</code>来返回一个真正的对象，一旦得到这个对象就可以利用这个对象条用任何方法。</li>
</ul>
<pre><code> ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;/configure/beansConfigure.xml&quot;);
        HelloWord helloWord= (HelloWord) applicationContext.getBean(&quot;helloWord&quot;);
        helloWord.getMessage();
</code></pre>
<h5 id="bean-property">bean property</h5>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>强制属性，制定用来创建bean的bean类</td>
</tr>
<tr>
<td>name/id</td>
<td>指定唯一的bean的标识符</td>
</tr>
<tr>
<td>scope</td>
<td>指定由特定bean定义创建的对象的作用域</td>
</tr>
<tr>
<td>constructor-arg</td>
<td>用来注入依赖关系</td>
</tr>
<tr>
<td>properties</td>
<td>用来注入依赖关系</td>
</tr>
<tr>
<td>autowiring mode</td>
<td>用来注入依赖关系</td>
</tr>
<tr>
<td>lazy-initialization mode</td>
<td>第一次调用时创建对象（懒汉模式）</td>
</tr>
<tr>
<td>initialization</td>
<td>在bean的所有必须属性被容器设置之后，调用回调方法</td>
</tr>
<tr>
<td>destruction</td>
<td>当包含该bean的容器被销毁是，使用回调方法</td>
</tr>
</tbody>
</table>
<h5 id="spring配置元数据">Spring配置元数据</h5>
<p><code>Spring IoC</code>容器完全由实际编写的配置元数据的格式解耦</p>
<ul>
<li>基于XML的配置文件</li>
<li>基于注解的配置</li>
<li>基于java的配置</li>
</ul>
<h5 id="spring-bean的作用域">Spring Bean的作用域</h5>
<p>在Spring定义一个bean时，必须声明该bean的作用域.</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>singleTon</code></td>
<td>单例模式</td>
</tr>
<tr>
<td><code>prototype</code></td>
<td>普通模式，每次调用创建一个新的对象</td>
</tr>
<tr>
<td><code>request</code></td>
<td>作用域定义为HTTP请求，只在web-aware spring ApplicationContext的上下文中有效</td>
</tr>
<tr>
<td><code>session</code></td>
<td>作用域定义限制为HTTP会话，只在web-aware spring ApplicationContext的上下文中有效</td>
</tr>
<tr>
<td><code>global-session</code></td>
<td>作用域将bean的定义限制为全局HTTP绘画，只在web-aware spring ApplicationContext的上下文中有效</td>
</tr>
</tbody>
</table>
<p>作用域设置实例</p>
<pre><code> &lt;bean id=&quot;singleTon&quot; class=&quot;com.example.SingleTon&quot; 
      scope=&quot;singleton&quot;&gt;
</code></pre>
<h5 id="spring-bean的生命周期">Spring bean的生命周期</h5>
<p>声明带有 <code>init-method</code>和 <code>destroy-method</code> 参数的 。</p>
<ul>
<li><code>init-method</code> 属性指定一个方法，在实例化 bean 时调用该方法。</li>
<li><code>destroy-method</code> 指定一个方法，只有从容器中移除 bean 后，才能调用该方法。</li>
</ul>
<p>在<code>org.springframework.beans.factory.InitializingBean</code> 接口指定一个单一的方法：</p>
<pre><code>void afterPropertiesSet() throws Exception;
</code></pre>
<p>我们只需要在实现<code>InitializingBean</code>接口就可以在对象创建后做一些事情</p>
<pre><code>public class TestBean implements InitializingBean {
   public void afterPropertiesSet() throws Exception{
      // do some initialization work
   }
}
</code></pre>
<p>同样的在<code>org.springframework.beans.factory.DisposableBean</code> 接口指定一个单一的方法：</p>
<pre><code>void destroy() throws Exception;
</code></pre>
<p>然后在类对象中实现<code>DisposableBean</code>接口</p>
<pre><code>public class TestBean implements DisposableBean{
    @Override
    public void destroy() throws Exception {
        // do some initialization work
    }
}
</code></pre>
<p>除此之外，在基于XML元数据配置的境况下还可以通过设置<code>destroy-method</code>属性实现</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot;
         class=&quot;examples.ExampleBean&quot; destroy-method=&quot;destroy&quot;/&gt;
</code></pre>
<p>在类里面我们可以这样定义</p>
<pre><code>public class TestBean {
   public void destroy() {
      // do some destruction work
   }
}
</code></pre>
<h5 id="beanpostprocessor">BeanPostProcessor</h5>
<p>有时候会需要在bean实例化对象前后去做一些准备工作或预处理，可以在创建bean类时实现<code>BeanPostProcessor</code>接口去完成自定义工作。<br>
该接口定义了<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>两个带参函数，示例代码如下</p>
<pre><code>public class TestBean implements BeanPostProcessor {
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      System.out.println(&quot;BeforeInitialization : &quot; + beanName);
      return bean;  // you can return any other object as well
   }
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      System.out.println(&quot;AfterInitialization : &quot; + beanName);
      return bean;  // you can return any other object as well
   }
}
</code></pre>
<p><code>注意</code>：在main方法中需要注册一个在 AbstractApplicationContext 类中声明的关闭 hook 的 registerShutdownHook() 方法。它将确保正常关闭，并且调用相关的 destroy 方法。</p>
<pre><code>context.registerShutdownHook();
</code></pre>
<h4 id="java的反射机制">Java的反射机制</h4>
<p><code>写在Spring Ioc之前</code><br>
类装载器就是寻找类的字节码文件并构造出类在JVM内部表示的对象组件，主要工作由ClassLoader及其子类负责，ClassLoader是一个重要的java运行时系统组件，他负责在运行时查找和装入Class字节码文件</p>
<pre><code>public class ReflectCar {
    public static Car initCarByDefaultConst() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        ClassLoader loader=Thread.currentThread().getContextClassLoader();
        Class clazz=loader.loadClass(&quot;com.beijinghuayi.ioc.Car&quot;);
        //获取类默认实例化对象
        Constructor constructor=clazz.getDeclaredConstructor((Class[])null);
        Car car= (Car) constructor.newInstance();

        Method setBrand=clazz.getMethod(&quot;setBrand&quot;,String.class);
        setBrand.invoke(car,&quot;奔驰&quot;);
        Method setColor=clazz.getMethod(&quot;setColor&quot;,String.class);
        setColor.invoke(car,&quot;红色&quot;);
        Method setMaxspeed=clazz.getMethod(&quot;setMaxspeed&quot;,String.class);
        setMaxspeed.invoke(car,&quot;200码&quot;);
        return car;
    }
    public static Car initCarByParams() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        ClassLoader loader=Thread.currentThread().getContextClassLoader();
        Class clazz=loader.loadClass(&quot;com.beijinghuayi.ioc.Car&quot;);
        Constructor constructor=clazz.getDeclaredConstructor(new Class[]{String.class,String.class,String.class});
        Car car= (Car) constructor.newInstance(new Object[]{&quot;红色&quot;,&quot;宝马&quot;,&quot;180&quot;});
        return car;
    }
}
</code></pre>
<p><code>工作机制：</code></p>
<ul>
<li>1.装载：查找和导入Class文件</li>
<li>2.链接：执行校验，准备和解析步骤</li>
<li>3.初始化：对类的静态变量、静态代码块执行初始化操作</li>
</ul>
<p><code>Tip:</code>JVM在运行时会产生3个<code>classLoader</code></p>
<ul>
<li>根装载器（C++实现、不是classloader的子类）装载jre核心类库</li>
<li>ExtClassLoader（扩展类装载器）装载jre扩展目录ext中的jar类</li>
<li>AppClassLoader（系统类装载器）装载classpath中的内容</li>
</ul>
<p><code>ClassLoader</code>重要方法</p>
<ul>
<li>Class loadClass(String name);从文件中装在类</li>
<li>Class defineClass(String name,byte[]b,int off,int len)</li>
<li>Class findSystemClass(String name)</li>
<li>Class findLoadedClass(String name)</li>
<li>ClassLoader getParent()</li>
</ul>
<p>Class反射对象描述类语义结构，可以从Class对象中获得构造函数，成员变量，方法等元素的反射对象，并以编程的方法通过这些反射对象对目标类对象进行操作。这些反射对象类在java.reflect包中定义，下面是最主要的三个反射类</p>
<ul>
<li>1.Constructor类对象的反射类（通过getConstructor方法可以获得类的所有构造函数反射对象数组）NewInstance。</li>
<li>2.Method类方法的反射类invoke() getReturnType(),getParameterTypes();</li>
<li>3.Field 获取类的成员变量反射类（ 获取成员变量反射数组）<br>
<code>Tip</code>访问private，protect成员变量或方法时需添加<code>Field.setAccessible(true)</code>，<code>Method.setAccessible(true)</code>方法取消java语言检查，否则将会抛出<code>IllegalAccessException</code>异常.</li>
</ul>
<pre><code> ClassLoader loader=Thread.currentThread().getContextClassLoader();
        System.out.println(&quot;classLoader:&quot;+loader);
        System.out.println(&quot;parent classLoader:&quot;+loader.getParent());
        System.out.println(&quot;grandParent classLoader:&quot;+loader.getParent().getParent());
</code></pre>
<h5 id="引出spring-ioc">引出Spring Ioc</h5>
<p>在Spring中，通过IOC可以将实现类、参数信息等配置在对应的配置文件中，那么当需要更改实现类或参数信息时，只需要修改配置文件即可，我们还可以对某对象所需要的其他对象进行注入，这种注入都是在配置文件中实现。</p>
<h5 id="spring-bean的简单实现">Spring Bean的简单实现</h5>
<pre><code>public class BeanFactory {
    private Map&lt;String,Object&gt; beanmap=new HashMap&lt;&gt;();
    public void init(String xml) throws DocumentException, ClassNotFoundException, IntrospectionException, IllegalAccessException, InstantiationException, InvocationTargetException {
        //1.创建读取配置文件的reader对象
        SAXReader reader=new SAXReader();
        //2.获取当前线程的类加载器
        ClassLoader loader=Thread.currentThread().getContextClassLoader();
        //3.从class目录下获取指定的xml文件
        InputStream ins=loader.getResourceAsStream(xml);
        Document doc=reader.read(ins);
        Element root=doc.getRootElement();
        Element foo;

        //4.遍历xml文件中的Bean实例
        for(Iterator i=root.elementIterator(&quot;bean&quot;);i.hasNext();){
            foo= (Element) i.next();
            //5.针对每一个bean实例，获取bean的属性id和class
            Attribute id=foo.attribute(&quot;id&quot;);
            Attribute cls=foo.attribute(&quot;class&quot;);

            //6.利用Java反射机制，通过class的名称获取Class对象
            Class bean=Class.forName(cls.getText());
            //7.获取丢应class信息
            java.beans.BeanInfo info =java.beans.Introspector.getBeanInfo(bean);
            //8.获取其属性描述
            java.beans.PropertyDescriptor pd[]=info.getPropertyDescriptors();
            //9.创建一个对象，并在接下来的代码中为对象的属性赋值
            Object obj=bean.newInstance();
            //10.遍历该bean的property属性
            for(Iterator ite=foo.elementIterator(&quot;property&quot;);ite.hasNext();){
                Element foo2= (Element) ite.next();
                //11.获取该property的name属性
                Attribute name=foo2.attribute(&quot;name&quot;);
                String value=null;
                //12.获取该property的子元素的值
                for (Iterator ite1 = foo2.elementIterator(&quot;value&quot;); ite1.hasNext();)
                {
                    Element node = (Element) ite1.next();
                    value = node.getText();
                    break;
                }

                //13.利用Java的反射机制调用对象的某个set方法，并将值设置进去
                for (int k = 0; k &lt; pd.length; k++) {
                    if (pd[k].getName().equalsIgnoreCase(name.getText()))
                    {
                        Method mSet = null;
                        mSet = pd[k].getWriteMethod();
                        mSet.invoke(obj, value);
                    }
                }
            }
            //14.将对象放入beanMap中，其中key为id值，value为对象
            beanmap.put(id.getText(), obj);
        }
    }
    /**
     * 通过bean的id获取bean的对象.
     *
     * @param beanName
     *            bean的id
     * @return 返回对应对象
     */
    public Object getBean(String beanName) {
        Object obj = beanmap.get(beanName);
        return obj;
    }
}
</code></pre>
<p><code>config.xml</code></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans&gt;
    &lt;bean id=&quot;javaBean&quot; class=&quot;JavaBean&quot;&gt;
        &lt;property name=&quot;username&quot;&gt;
            &lt;value&gt;mic_swift&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name=&quot;password&quot;&gt;
            &lt;value&gt;010101010110&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h5 id="spring资源访问工具类">Spring资源访问工具类</h5>
<p>JDK所提供的访问资源类并不能很好的满足各种底层资源的访问需求，因此，Spring设计了一个Resource接口，它为应用提供了更强大的访问底层资源的能力：<br>
<code>主要方法：</code></p>
<ul>
<li>boolean exists()</li>
<li>boolean isOpen()</li>
<li>URL getURL();</li>
<li>File getFile();</li>
<li>inputStream getInputStream();</li>
</ul>
<p><code>具体实现类</code></p>
<ul>
<li>ByteArrayResource</li>
<li>ClassPathResource</li>
<li>FileSystemResource</li>
<li>InputStreamResource</li>
<li>ServletContextResource</li>
<li>UrlResource</li>
</ul>
<p>为了访问不同类型的资源，必须使用相应的Resource实现类，Spring提供了一个强大的加载资源的机制，能够自动识别不同的资源类型。<br>
<code>资源类型地址前缀</code></p>
<ul>
<li>classpath classpath:com/example/config.xml</li>
<li>File file:/com/example/config.xml</li>
<li>Http http://www.baidu.com</li>
<li>Ftp ftp://www.baidu.com</li>
<li>无前缀 com/example/config.xml<br>
######BeanFactory和ApplicationContext<br>
BeanFactory时Spring框架的最核心接口，它提供高级的Ioc配置机制，AppliactionContext建立在BeanFactory基础上，提供了更多面向应用的功能，它提供了国际化支持和框架事件体系，更易于创建实际应用一般成BeanFactory为Ioc容器，而称ApplicationContext为应用上下文</li>
</ul>
<p>BeanFactory是一个类工厂，可以常见并管理各种类的对象，Spring称这些创建和管理的java对象为bean，在Spring中，java对象的范围更加宽泛，接下来我们对BeanFactory的类体系结构以及装载初始化顺序进行说明：</p>
<h5 id="类体系结构">类体系结构</h5>
<ul>
<li>XmlBeanFactory</li>
<li>ListableBeanFactory</li>
<li>HierarhicalBeanFactory</li>
<li>ConfigurableBeanFactory</li>
<li>AutowireCapableBeanFactory</li>
<li>SingletonBeanFactory</li>
<li>BeanDefinitionRegistry</li>
</ul>
<h5 id="初始化顺序">初始化顺序</h5>
<ul>
<li>创建配置文件</li>
<li>装载配置文件</li>
<li>启动Ioc容器</li>
<li>获取Bean实例</li>
</ul>
<p>ApplicationContext由BeanFactory派生而来，提供了更多面向实际的功能。在BeanFactory中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置的方式实现，接下来介绍一下ApplicationContext的实现类以及类体系结构：</p>
<p><code>具体实现类</code></p>
<ul>
<li>ClassPathXmlApplicationContext</li>
<li>FileSystemXmlApplicationContext</li>
<li>ConfigurableApplicationContext<br>
<code>类继承体系</code>(扩展接口)</li>
<li>ApplicationEventPublisher</li>
<li>MessageSource</li>
<li>ResourcePatternResolver</li>
<li>LifeCycle(用于处理异步)</li>
</ul>
<p>Spring容器中的Bean拥有明确的生命周期，由多个特定的生命阶段组成，每个生命阶段都允许外界对Bean进行控制，在Spring中，我们从Bean的作用范围和实例化Bean时所经历的一系列阶段来描述Bean的生命周期</p>
<ul>
<li>BeanFactory中的Bean的生命周期</li>
<li>ApplicationContext中的Bean的生命周期</li>
</ul>
<h5 id="spring容器启动基本条件">Spring容器启动基本条件</h5>
<ul>
<li>Spring框架类包</li>
<li>Bean配置信息</li>
<li>Bean类满足</li>
</ul>
<h5 id="bean的元数据信息">Bean的元数据信息</h5>
<ul>
<li>Bean的实现类</li>
<li>Bean的属性信息</li>
<li>Bean的依赖关系</li>
<li>Bean的行为配置</li>
<li>Bean的创建方式</li>
</ul>
<p>使用静态工厂的方式除了指定必须的class属性，还要指定factory-method属性来指定实例化Bean的方法，而且使用静态工厂方法也允许指定方法参数，SpringIoc容器将调用此属性的方法来获取Bean。</p>
<p>使用实例工厂方法不能指定clas属性，此时必须使用factory-bean来指定工厂Bean，factory-method属性指定实例化Bean的方法，而且使用实例工厂方法允许指定方法参数，方式和使用构造器方式一样</p>
<pre><code>&lt;bean id=&quot;beanInstanceFactory&quot; class=&quot;com.beijinghuayi.spring.Instance&quot;/&gt;
	&lt;bean id=&quot;helloWorldInstance&quot; factory-bean=&quot;beanInstanceFactory&quot; factory-method=&quot;newInstance&quot;&gt;
		&lt;constructor-arg index=&quot;0&quot; value=&quot;Hello Instance Factory!&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="spring多个配置文件的整合">Spring多个配置文件的整合</h5>
<pre><code>&lt;beans&gt;
    &lt;import resource=&quot;common/Spring-Common.xml&quot;/&gt;
    &lt;import resource=&quot;common/Spring-Connect.xml&quot;/&gt;
    &lt;import resource=&quot;common/Spring-Moudel.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h5 id="spring-bean-定义继承">Spring Bean 定义继承</h5>
<ul>
<li>Bean可以通过设置配置文件来定义继承关系</li>
<li>子 bean 的定义继承父定义的配置数据。子定义可以根据需要重写一些值，或者添加其他值。<code>tip:</code>Spring Bean 定义的继承与 Java 类的继承无关，但是继承的概念是一样的。</li>
<li>当你使用基于 XML 的配置元数据时，通过使用父属性，指定父 bean 作为该属性的值来表明子 bean 的定义。</li>
</ul>
<p>通过XML配置文件实现继承关系实例</p>
<pre><code>&lt;bean id=&quot;person&quot; class=&quot;com.example.Person&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;swift&quot;/&gt;
      &lt;property name=&quot;details&quot; value=&quot;animal can speak&quot;/&gt;
   &lt;/bean&gt;

   &lt;bean id=&quot;student&quot; class=&quot;com.example.Student&quot; parent=&quot;person&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;study&quot;/&gt;
      &lt;property name=&quot;details&quot; value=&quot;good good study, day day up!&quot;/&gt;
   &lt;/bean&gt;
</code></pre>
<p><code>tip：</code>在定义Student类的时候我们不再需要继承Person类</p>
<h5 id="bean-定义模板">Bean 定义模板</h5>
<pre><code>&lt;bean id=&quot;person&quot; abstract=&quot;true&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;swift&quot;/&gt;
      &lt;property name=&quot;details&quot; value=&quot;animal can speak&quot;/&gt;
   &lt;/bean&gt;

   &lt;bean id=&quot;student&quot; class=&quot;com.example.Student&quot; parent=&quot;person&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;study&quot;/&gt;
      &lt;property name=&quot;details&quot; value=&quot;good good study, day day up!&quot;/&gt;
   &lt;/bean&gt;
</code></pre>
<p>person 自身不能被实例化，因为它是不完整的(没有指定class属性)，而且它也被明确地标记为抽象的。当一个定义是抽象的，它仅仅作为一个纯粹的模板 bean 定义来使用的，充当子定义的父定义使用。</p>
<h5 id="spring-依赖注入">Spring 依赖注入</h5>
<p>当编写一个复杂的 Java 应用程序时，应用程序的 java 有多个对象，应用程序类应该尽可能独立于其他 Java 类来增加这些类重用的可能性，依赖注入DI<br>
（或有时称为布线）有助于把这些类粘合在一起，同时保持他们<code>独立</code>。</p>
<ul>
<li>构造函数注入</li>
</ul>
<pre><code>public class Person{
   private Speak speak;
   public Person(Speak speak) {
      this.speak= speak;
   }
}
</code></pre>
<p>依赖关系通过<code>类构造函数</code>被注入到 Person类中。</p>
<ul>
<li>setter方法注入</li>
</ul>
<pre><code>public class Person{
   private Speak speak;
   public void setSpeak(Speak speak){
	   this.speak=speak;
   }
}
</code></pre>
<p>依赖关系通过<code>类构造函数</code>被注入到 Person类中。控制流通过依赖注入（DI）已经“反转”，因为你已经有效地委托依赖关系到一些外部系统。</p>
<ul>
<li>XML配置文件注入</li>
</ul>
<pre><code> &lt;bean id=&quot;person&quot; class=&quot;com.example.Person&quot;&gt;
      &lt;constructor-arg ref=&quot;speak&quot;/&gt;
&lt;/bean&gt;
&lt;!-- Definition for speak bean --&gt;
&lt;bean id=&quot;speak&quot; class=&quot;com.example.Speak&quot;&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="spring-基于设值函数的依赖注入">Spring 基于设值函数的依赖注入</h5>
<p>当容器调用一个无参的构造函数或一个无参的静态 factory 方法来初始化你的 bean 后，通过容器在你的 bean 上调用设值函数，基于设值函数的 DI 就完成了。</p>
<pre><code> &lt;bean id=&quot;person&quot; class=&quot;com.example.Person&quot;&gt;
      &lt;property name=&quot;speak&quot; ref=&quot;speak&quot;&gt;
&lt;/bean&gt;
&lt;!-- Definition for speak bean --&gt;
&lt;bean id=&quot;speak&quot; class=&quot;com.example.Speak&quot;&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>
<p><code>Tip：</code>此方法和构造函数注入唯一的区别就是在基于构造函数注入中，我们使用的是标签中的元素，而在基于设值函数的注入中，我们使用的是标签。</p>
</li>
<li>
<p><code>tip：</code>如果你要把一个引用传递给一个对象，那么你需要使用 标签的 ref 属性，而如果你要直接传递一个值，那么你应该使用 value 属性。</p>
</li>
</ul>
<h5 id="p-namespace"><code>p-namespace</code></h5>
<pre><code>&lt;bean id=&quot;test&quot; class=&quot;com.example.Person&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;swift&quot;/&gt;
      &lt;property name=&quot;method&quot; ref=&quot;speak&quot;/&gt;
&lt;/bean&gt;
//可以通过如下方式简化表示
&lt;bean id=&quot;test&quot; class=&quot;com.example.Person&quot;
      p:name=&quot;swift&quot;
      p:method=&quot;speak&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="注入内部bean">注入内部bean</h5>
<p>inner bean是在bean类中添加的内部类（java内部类）</p>
<pre><code>&lt;bean id=&quot;person&quot; class=&quot;com.sunxiaohang.Person&quot;&gt;
        &lt;property name=&quot;speak&quot;&gt;
            &lt;bean id=&quot;speak&quot; class=&quot;com.sunxiaohang.Speak&quot;&gt;&lt;/bean&gt;
        &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>tip:<code>&lt;!--property需要提供set方法才能使用--&gt;</code></p>
<h5 id="spring注入集合">Spring注入集合</h5>
<p>Spring提供了四种集合类</p>
<table>
<thead>
<tr>
<th>Spring集合类</th>
</tr>
</thead>
<tbody>
<tr>
<td>Map</td>
</tr>
<tr>
<td>Properties</td>
</tr>
<tr>
<td>Set</td>
</tr>
<tr>
<td>List</td>
</tr>
</tbody>
</table>
<p>以下是<code>Collections</code>类和<code>springbean.xml</code>的配置代码</p>
<pre><code>package com.sunxiaohang;

import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

public class Collections {
    private Set collectionSet;
    private Map collectionMap;
    private Properties collectionProperties;
    private List collectionList;

    public Collections() {
    }

    public Set getCollectionSet() {
        System.out.println(&quot;Set Element:&quot;+collectionSet);
        return collectionSet;
    }

    public void setCollectionSet(Set collectionSet) {
        this.collectionSet = collectionSet;
    }

    public Map getCollectionMap() {
        System.out.println(&quot;Map Element:&quot;+collectionMap);
        return collectionMap;
    }

    public void setCollectionMap(Map collectionMap) {
        this.collectionMap = collectionMap;
    }

    public Properties getCollectionProperties() {
        System.out.println(&quot;Properties Element:&quot;+collectionProperties);
        return collectionProperties;
    }

    public void setCollectionProperties(Properties collectionProperties) {
        this.collectionProperties = collectionProperties;
    }

    public List getCollectionList() {
        System.out.println(&quot;list Element:&quot;+collectionList);
        return collectionList;
    }

    public void setCollectionList(List collectionList) {
        this.collectionList = collectionList;
    }
}

</code></pre>
<pre><code>&lt;bean id=&quot;collections&quot; class=&quot;com.sunxiaohang.Collections&quot;&gt;
    &lt;property name=&quot;collectionList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;张三&lt;/value&gt;
            &lt;value&gt;李四&lt;/value&gt;
            &lt;value&gt;王五&lt;/value&gt;
            &lt;value&gt;马六&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;collectionSet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;北京&lt;/value&gt;
            &lt;value&gt;天津&lt;/value&gt;
            &lt;value&gt;上海&lt;/value&gt;
            &lt;value&gt;广州&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
    &lt;property name=&quot;collectionMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;1&quot; value=&quot;one&quot;/&gt;
            &lt;entry key=&quot;2&quot; value=&quot;two&quot;/&gt;
            &lt;entry key=&quot;3&quot; value=&quot;three&quot;/&gt;
            &lt;entry key=&quot;4&quot; value=&quot;four&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name=&quot;collectionProperties&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;1&quot;&gt;姓名&lt;/prop&gt;
            &lt;prop key=&quot;2&quot;&gt;性别&lt;/prop&gt;
            &lt;prop key=&quot;3&quot;&gt;年龄&lt;/prop&gt;
            &lt;prop key=&quot;4&quot;&gt;出生日期&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://sunxiaohang.github.io/post/she-ji-mo-shi/">
              <h3 class="post-title">
                下一篇：设计模式
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">KnowledgeBase</div>
  <div class="social-container">
    
      
        <a href="https://github.com/sunxiaohang" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="mailto:cssunhang@outlook.com" target="_blank">hangsun</a> | <a class="rss" href="https://sunxiaohang.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
