
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>Shader | KnowledgeBase</title>
<meta name="description" content="KnowledgeBase">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://sunxiaohang.github.io/favicon.ico?v=1586847630761">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://sunxiaohang.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://sunxiaohang.github.io">
        <img class="avatar" src="https://sunxiaohang.github.io/images/avatar.png?v=1586847630761" alt="" width="32px" height="32px">
      </a>
      <a href="https://sunxiaohang.github.io">
        <h1 class="site-title">KnowledgeBase</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
          <h2 class="post-title">Shader</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-04-14</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://sunxiaohang.github.io/tag/1gmIsfBLO/">
                    Unity
                    
                      ，
                    
                  </a>
                
                  <a href="https://sunxiaohang.github.io/tag/11sEhzdYL/">
                    游戏开发
                    
                      ，
                    
                  </a>
                
                  <a href="https://sunxiaohang.github.io/tag/ru-1V6NlW/">
                    计算机图形学
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p>Unity shader的渲染流程，模型空间，世界空间，裁切空间，屏幕空间的转换，顶点着色器，片元着色器的一般原理，基础光照模型分析。透明，光线追踪等高特性光照模型原理。主要侧重于移动端的轻量级渲染管线，不考虑主机或PC设备。</p>
<p>tips:渲染流水线的最终目的是渲染一张二维纹理</p>
<p>输入：1.虚拟相机 2.光源 3.一些shader及纹理</p>
<figure data-type="image" tabindex="1"><img src="https://sunxiaohang.github.io/post-images/1586845473202.png" alt="" loading="lazy"></figure>
<h5 id="应用阶段">应用阶段</h5>
<p><em>应用主导</em>,通常由CPU负责实现（开发者具有绝对控制权）</p>
<ul>
<li>准备场景数据</li>
<li>优化(粗粒度剔除(culling)工作,剔除不可见物体)</li>
<li>设置好每个模型的渲染状态(材质，纹理，使用的shader等)</li>
<li>输出是渲染所需的几何信息，即<strong>渲染图元</strong>(rendering primitives)</li>
</ul>
<h5 id="几何阶段">几何阶段</h5>
<p><em>几何阶段</em>用于处理所有要绘制的几何相关（图元是什么，怎么绘制，在哪绘制）</p>
<p>负责和每个渲染图元交互，进行逐顶点、逐多边形的操作。这一阶段会将输出屏幕空间的二位顶点坐标，每个定点对应的深度值，着色等相关信息，并传递给下一阶段</p>
<h5 id="光栅化阶段">光栅化阶段</h5>
<p>使用上个阶段产生的数据产生屏幕上的像素，并渲染出最终的图像，这一阶段实在GPU上执行（决定每个渲染图元上的哪些元素被绘制到屏幕上）</p>
<h5 id="cpu和gpu之间的通信">CPU和GPU之间的通信</h5>
<p>应用阶段</p>
<ul>
<li>把数据加载到显存（VideoRAM）[RAM=&gt;VRAM]{GPU无法直接访问RAM}</li>
<li>设置渲染状态（场景中的网格怎么被渲染[使用哪个顶点着色器(Vertex Shader)/片元着色器(Fragment Shader),光源属性，材质等]）</li>
<li>调用Draw Call（CPU=&gt;GPU）指令仅仅会指向一个需要被渲染的图元(primitives)列表（材质信息已在上一阶段处理完成）</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://sunxiaohang.github.io/post-images/1586845497549.png" alt="" loading="lazy"></figure>
<p><strong>顶点着色器(Vertex Shader):</strong> <em>-完全可编程-</em>，通常用于实现定点的空间变换、顶点着色等</p>
<blockquote>
<p>顶点着色器输入来自CPU，处理单位是顶点（输入进来的每个顶点都会调用一次顶点着色器）【顶点之间是相互独立的可并行】</p>
<ul>
<li>坐标变换：把顶点坐标从模型空间转换到齐次裁剪空间</li>
<li>计算和输出顶点颜色：逐顶点光照</li>
</ul>
</blockquote>
<p>**曲面细分着色器(Tessellation Shader)😗*用于细分图元</p>
<p>**几何着色器(Geometry Shader)😗*可以被用于执行逐图元(Per-Primitive)的着色操作，或被用于产生更多的图元</p>
<p>**裁剪(Clipping)😗*裁剪掉不在摄像机视野内的顶点，并剔除掉某些三角图元的面片（归一化的设备坐标[Normalized Device Coordinates]）</p>
<p>一个图元和摄像机视野的三种关系：**1.**完全在视野内（继续传递给下一阶段） **2.**部分在视野内（<strong>裁剪</strong>） **3.**完全在视野外（不传递）</p>
<p>*--例如--：*一条线段的一个顶点在视野内，另一个定点在视野外，那么在事业外部的顶点应该带使用一个新的顶点代替（位于线段与视野边界的交点处）</p>
<p>**屏幕映射:**把每个图元的x和y坐标转换到屏幕坐标系</p>
<ul>
<li>OpenGL：零点在左下角</li>
<li>DirectX：零点在左上角</li>
</ul>
<p>**三角形设置：**会计算光栅化一个三角形网格所需的信息（为了能够计算边界像素的坐标信息，我们需要得到三角形边界的表示方式）</p>
<p><em><em>三角形遍历：<em><em>检查每个像素是否被一个三角网格覆盖，如果覆盖就生成一个</em>--片元(fragment)--*也被称为</em></em>扫描变换</em>*</p>
<p>**片元着色器(Fragment Shader)😗*实现逐片元的着色操作</p>
<p>根据从顶点着色器输出的数据插值得到一个或多个颜色值</p>
<p>**逐片元操作(Per-Fragment Operations)😗*负责很多重要操作，例如修改颜色，深度缓冲，混合等（逐片元合并）</p>
<ul>
<li>决定每个片元的可见性，涉及很多测试工作，如深度测试，模板测试等</li>
<li>如果一个片元<strong>通过了所有测试</strong>，仅需要把这个片元的颜色值和已经存储的颜色缓冲区中的颜色进行合并（混色）</li>
</ul>
<h5 id="qa">Q&amp;A</h5>
<p><strong>问题1:CPU和GPU是怎样实现并行工作的</strong></p>
<p>*--命令缓冲区(Command Buffer)--：*包含一个命令队列，CPU添加命令，GPU读取命令</p>
<p><strong>问题2:为什么DrawCall多了会影响帧率</strong></p>
<p><em>--每一个DrawCall都需要很多额外的操作--</em></p>
<p><strong>问题3:如何减少DrawCall</strong></p>
<p>*--批处理(Batching)--：*把大量小的DrawCall合并为大的DrawCall</p>
<ul>
<li>避免使用大量很小的网格（不可避免时考虑合并）</li>
<li>避免使用过多材质（尽量在不同网格之间公用同一个材质）</li>
</ul>
<h5 id="固定管线渲染">固定管线渲染</h5>
<p>**固定函数的流水线（Fixed-Function Pipeline）😗*提供一系列配置接口，开发者没有对流水线的完全控制权</p>
<h5 id="unity-shaderunity-shadermaterial">Unity Shader(Unity Shader&amp;Material)</h5>
<ul>
<li>创建一个材质</li>
<li>创建一个Unity Shader，并把它赋给上一步创建的材质</li>
<li>把材质赋给需要渲染的对象</li>
<li>在材质面盘调整Unity Shader属性得到免疫的效果</li>
</ul>
<p>**Material：**材质需要结合一个GameObject的Mesh或者Particle System组件工作，它决定游戏对象的样子</p>
<figure data-type="image" tabindex="3"><img src="https://sunxiaohang.github.io/post-images/1586845518401.png" alt="" loading="lazy"></figure>
<pre><code class="language-c#">Shader &quot;shader路径/Shader名&quot;
{
    Properties
    {
		//属性
        Name(&quot;display name&quot;,PropertyType)=DefaultValue;
        //PropertyType====Int,Float,Range(min,max),Color,Vector,2D,Cube,3D
        //实例
        _Color (&quot;Color&quot;, Color) = (1,1,1,1)
        _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}
        _Glossiness (&quot;Smoothness&quot;, Range(0,1)) = 0.5
        _Metallic (&quot;Metallic&quot;, Range(0,1)) = 0.0
    }
    SubShader
    {
        //-------------显卡A使用的子着色器
        //真正意义上的shader代码
        //Surface Shader/ Vertex Shader / Fragment Shader / Fixed Function Shader
        //表面着色器/顶点着色器/片元着色器/固定函数着色器
        //标签设置 [Tags]
        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
        //状态[RenderSetup]
        
        //Pass 每个Pass定义了一次完整的渲染流程(Pass过多会造成渲染性能的下降)
        Pass{}
    }
    FallBack &quot;Diffuse&quot;
}
</code></pre>
<p><strong>状态设置</strong></p>
<p><em>--定义在SubShader中会应用到所有Pass，定义在单独Pass中仅作用与单个Pass--</em></p>
<ul>
<li><strong>-Cull-:</strong> -Cull Back- | -Front- | -Off- 设置剔除模式：剔除背面/正面/关闭剔除</li>
<li><strong>-ZTest-:</strong> ZTest Less Greater | LEqual | Equal | NotEqual | Always 设置深度测试时使用的函数</li>
<li><strong>-ZWrite-:</strong> ZWrite On | Off 开启/关闭深度写入</li>
<li><strong>-Blend-:</strong> Blend SrcFactor DstFactor开启并设置混合模式</li>
</ul>
<p><strong>SubShader的标签</strong></p>
<pre><code class="language-c#">Tags{&quot;TageName&quot;=&quot;Value&quot; &quot;TagName&quot;=&quot;Value&quot;}
//Queue:控制渲染顺序，指定该物体属于哪一个渲染队列，这种凡是可以保证所有的透明物体可以在所有不透明物体后被渲染
Tags{&quot;Queue&quot;=&quot;Transparent&quot;}
//RenderType:对着色器进行分类，例如透明着色器和不透明着色器
Tags{&quot;RenderType&quot;=&quot;Opaque&quot;}
//DisableBatching:一些SubShader在使用Unity的批处理功能时会出现问题
Tags{&quot;DsiableBatching&quot;=&quot;True&quot;}
//ForceNoShadowCasting:控制使用该SubShader的物体是否会投射阴影
Tags{&quot;ForceNoShadowCasting&quot;=&quot;True&quot;}
//IgnoreProjector:如果该标签为True，那么使用该SubShader的物体将不会受Projector的影响，通常用于半透明物体
Tags{&quot;IgnoreProjector&quot;=&quot;True&quot;}
//CanUseSpriteAtlas:当该标签适用于精灵(sprites)时，将该标签设置为false
Tags{&quot;CanUseSpriteAtlas&quot;=&quot;False&quot;}
//PreviewType:知名材质面板将如何预览该材质，默认情况下，材质显示为一个sphere，可设置为Plane，SkyBox
Tags{&quot;PreviewType&quot;=&quot;Plane&quot;}
</code></pre>
<ul>
<li>**Queue:**控制渲染顺序，指定该物体属于哪一个渲染队列，这种凡是可以保证所有的透明物体可以在所有不透明物体后被渲染=》Tags{&quot;Q&quot;}</li>
</ul>
<p><strong>Pass语义块</strong></p>
<pre><code class="language-c#">//Pass的使用
UsePass &quot;MyShader/PASSNAME&quot;//Pass的名字会被转换为全部大写
...
Pass{
	//[Name]
    Name &quot;PassName&quot;
    //可以在Pass里面通过UsePass复用其他Pass
    UsePass &quot;PassPath/PASSNAME&quot;
    //GrabPass:该Pass负责抓取屏幕并将结果存储在一张纹理中，用于后续的Pass处理
    //[Tags]=&gt;Tags{&quot;tagName&quot;=&quot;tagValue&quot;}
    Tags{&quot;LightMode&quot;=&quot;ForwardBase&quot;}
    Tags{&quot;RequireOptions&quot;=&quot;SoftVegetation&quot;}
    //[RenderSetup]
}
</code></pre>
<h5 id="surface-shader表面着色器无pass">Surface Shader表面着色器（无Pass）</h5>
<pre><code class="language-C#">Shader &quot;Custom/CustomTestShader&quot;
{
    Properties{}
    SubShader
    {
        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
        CGPROGRAM
        //表面着色器的特定语法放在CGPROGRAM和ENDCG之间
        //CG/HLSL编写
        ENDCG
    }
    FallBack &quot;Diffuse&quot;
}
</code></pre>
<h5 id="vertex-fragment-shader顶点片元着色器pass内">Vertex / Fragment Shader顶点/片元着色器（Pass内）</h5>
<pre><code class="language-c#">Shader &quot;Custom/CustomVertexShader&quot;
{
    SubShader
    {
		Pass
		{
			CGPROGRAM
			float4 vert(float4 v:POSITION):SV_POSITION
			{return UnityObjectToClipPos(V);}
			float4 frag() : SV_Target
			{return fixed4(1.0,0.0,0.0,1.0);}
			ENDCG
		}
    }
    FallBack &quot;Diffuse&quot;
}
</code></pre>
<p><strong>着色器选择</strong></p>
<ul>
<li>兼容旧设备(Fixed Function Shader)</li>
<li>光源相关(Surface Shader)，移动平台表现不佳</li>
<li>使用光源较少||自定义渲染效果较多(Vertex/Fragment Shader)</li>
</ul>
<h5 id="坐标系">坐标系</h5>
<ul>
<li>左手坐标系=》旋转{左手法则}</li>
<li>右手坐标系=》旋转{右手法则}</li>
</ul>
<p>在模型空间和世界空间，Unity使用的是左手坐标系</p>
<p>在观察者空间(摄像机)，Unity使用的是右手坐标系，摄像机的前向是z轴的负方向</p>
<p><strong>模型空间(对象空间)(局部空间)坐标系</strong></p>
<p><strong>世界空间</strong></p>
<p><strong>观察者空间</strong>(右手坐标系)</p>
<p>**裁剪空间(齐次裁剪空间)*<em>空间是由</em>--视锥体(View Frustum)--*确定</p>
<p>视锥体有两种投影类型</p>
<ul>
<li>1.正交投影(orthographic projection)
<ul>
<li>正交投影网格大小相同(保留了物体的距离和角度)<strong>[2D游戏或渲染小地图]</strong></li>
<li>正交投影近裁剪平面和远裁剪平面<strong>大小相等</strong></li>
</ul>
</li>
<li>2.透视投影(perspective projection)
<ul>
<li>透视投影网格近大远小(模拟了人眼看世界的方式)<strong>[模拟3D世界物体]</strong></li>
<li>透视投影近裁剪平面和远裁剪平面<strong>近小远大</strong><br>
<img src="https://sunxiaohang.github.io/post-images/1586845545157.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h5 id="unity-shader-内置变量">Unity Shader 内置变量</h5>
<p>模型空间(M&gt;&gt;)世界空间(V&gt;&gt;)观察空间(P&gt;&gt;)裁剪空间</p>
<p><strong>UNITY_MATRIX_MVP</strong> 当前的模型观察投影矩阵，用于将顶点/ 方向矢量从<strong>模型空间</strong>变换到<strong>裁剪空间</strong></p>
<p><strong>UNITY_ MATRIX_MV</strong> 当前的模型观察矩阵， 用于将顶点/ 方向矢量从<strong>模型空间</strong>变换到<strong>观察空间</strong></p>
<p><strong>UNITY_MATRIX_V</strong> 当前的观察矩阵， 用于 将 顶点/ 方向 矢量 从<strong>世界空间</strong> 变换 到 <strong>观察空间</strong></p>
<p><strong>UNITY_MATRIX_P</strong> 当前的投影矩阵， 用于 将 顶点/ 方向 矢量 从<strong>观察空间</strong> 变换 到 <strong>裁剪空间</strong></p>
<p><strong>UNITY_MATRIX_VP</strong> 当前 的 观察 投影 矩阵， 用于 将 顶点/ 方向 矢量 从<strong>世界空间</strong> 变换 到 <strong>裁剪空间</strong></p>
<p><strong>UNITY_ MATRIX_T_MV</strong> UNITY_ MATRIX_ MV 的 <strong>转置矩阵</strong></p>
<p><strong>UNITY_ MATRIX_IT_MV</strong> UNITY_ MATRIX_ MV 的 <strong>逆转置矩阵</strong>， 用于将法线从<strong>模型空间</strong>变换 到<strong>观察空间</strong>， 也可 用于 得到 UNITY_ MATRIX_ MV 的 逆 矩阵</p>
<p><strong>_Object2World</strong> 当前 的 <strong>模型矩阵</strong>， 用于将 顶点/ 方向矢量 <strong>模型空间</strong> 变换到<strong>世界空间</strong></p>
<p><strong>_World2Object <strong>_Object2World 的 <strong>逆矩阵</strong>, 用于将顶点/方向矢量从</strong>世界空间</strong>变换到<strong>模型空间</strong></p>
<h5 id="camera和屏幕参数">Camera和屏幕参数</h5>
<p><strong>_WorldSpaceCameraPos</strong> float3 该 摄像机 在世 界 空间 中的 位置 _</p>
<p><strong>_ProjectionParams</strong> float4 x = 1. 0（ 或 ? 1. 0， 如果 正在 使用 一个 翻转 的 投影 矩阵 进行 渲染）， y = Near， z = Far， w = 1. 0 + 1. 0/ Far， 其中 Near 和 Far 分 别是 近 裁剪 平面 和 远 裁剪 平面 和 摄像机 的 距离</p>
<p><strong>_ScreenParams</strong> float4 x = width， y = height， z = 1. 0 + 1. 0/ width， w = 1. 0 + 1. 0/ height， 其中 width 和 height 分 别是 该 摄像机 的 渲染 目标（ render target） 的 像素 宽度 和 高度</p>
<p><strong>_ZBufferParams</strong> float4 x = 1 ? Far/ Near， y = Far/ Near， z = x/ Far， w = y/ Far， 该 变量 用于 线性化 Z 缓存 中的 深度 值（ 可 参考 13. 1 节）</p>
<p><strong>unity_ OrthoParams</strong> float4 x = width， y = heigth， z 没有 定义， w = 1. 0（ 该 摄像机 是 正交 摄像机） 或 w = 0. 0（ 该 摄像机 是 透视 摄像机）， 其中 width 和 height 是 正交 投影 摄像机 的 宽度 和 高度</p>
<p><strong>unity_ CameraProjection</strong> float4x4 该 摄像机 的 投影 矩阵</p>
<p><strong>unity_ CameraInvProjection</strong> float4x4 该 摄像机 的 投影 矩阵 的 逆 矩阵</p>
<p><strong>unity_ CameraWorldClipPlanes[ 6]</strong> float4 该 摄像机 的 6 个 裁剪 平面 在世 界 空间 下 的 等式， 按 如下 顺序： 左、 右、 下、 上、 近、 远 裁剪 平面</p>
<h5 id="unity中的屏幕坐标">Unity中的屏幕坐标</h5>
<p>**VPOS/WPOS:**分别是HLSL和Cg对屏幕坐标的定义，两者在unity中等价</p>
<pre><code class="language-C#">//VPOS/WPOS语义定义的输入是一个float4类型的变量
//xy值代表在屏幕空间中的像素坐标，[0.5-400.5]
//unity中，VPOS/WPOS的z分量范围是[0,1]，在摄像机近裁剪平面，z值为0，远裁剪平面，z为1
//w分量表示摄像机的投影类型{透视投影[1/Near,1/Far](Near和Far对应裁剪平面到摄像机的距离)}{正交投影[恒为1]}
//把屏幕空间初一屏幕分辨率来得到{视口空间(viewspace)}中的坐标
//视口坐标是把屏幕坐标归一化，左下角(0,0)右上角就是(1,1)[xy值除以屏幕分辨率即可]或者用ComputeScreenPos函数：
fixed4 frag(float4 sp:VPOS):SV_Target
{
    return fixed4(sp.xy/ScreenParams.xy,0.0,1.0);
}
//ComputeScreenPos函数使用示例
struct vertOut{
	float pos:SV_POSITION;
	float scrPos:TEXCOORD0;
}
vertOut vert(appdata_base v){
	vertOut o;
	o.pos = mul(UNITY_MATRIX_MVP,v.vertex);
	o.scrPos = ComputeScreenPos(o.pos);
	return 0;
}
fixed4 frag(vertOut i):SV_Target{
	float2 wcoord = (i.scrPos.xy/i.scrPos.w);
	return fixed3(wcoord,0.0,1.0);
}

</code></pre>
<h5 id="unity-cg语法汇总">Unity Cg语法汇总</h5>
<p><strong>额外基础类型</strong></p>
<ul>
<li><strong>half</strong> 16位浮点数 [-60000,60000]精度{小数点后3.3位}</li>
<li><strong>fixed</strong> 12位定点数[-2,2]，精度1/256</li>
<li><strong>sampler</strong>* 分为sampler,sampler1D,sampler2D,sampler3D,samplerCUBE和samplerRECT</li>
</ul>
<p><strong>Swizzle操作符</strong>（只能用于<strong>结构体</strong>和<strong>向量</strong>）</p>
<p>float4(a,b,c,d).xwz等价于 float(a,d,c)</p>
<p><strong>输入数据关键字</strong></p>
<ul>
<li><strong>Varying：<strong>在Cg程序中通过语义进行绑定Cg语言提供了一组语义词，用以表示参数是由顶点的哪些数据初始化的，语义词绑定后=&gt;变量被初始化的同时也以为这变量有了特殊含义，如表示位置、法线等{语义提供了一种使用</strong>随顶点变化</strong>或随<strong>片段变化</strong>的值来初始化Cg程序参数的方法，如：顶点位置，法向量，纹理坐标等}</li>
<li><strong>Uniform参数：<strong>Uniform是用来</strong>限制一个变量的初始值的来源</strong>，表示该变量初始值来源于外部环境，【Unity内置Uniform输入参数列表(部分如：模型矩阵，视锥体，时间量，相机位置，光源位置等)】</li>
</ul>
<p>**语义：**表示图元数据的含义(顶点位置，法向量或者纹理信息)也表示这些图元数据存放的硬件资源，<strong>顶点着色器的输出即是片段着色器的输入</strong>（因此两者输出输入语义必须是一致的）[语义只对这两个阶段有意义，且只在入口函数有效，在内部函数无效]<strong>可以理解为输出&gt;输入关系映射</strong>，语义词和语义绑定如下：</p>
<ul>
<li>**POSITION/SV_POSITION：<strong>模型坐标位置{两者唯一区别是：当用在顶点着色器中</strong>+**作为语义输出时，SV_POSITION表示的顶点位置会被固定，不能改变}</li>
<li>**TANGENT：**正交于表面法线的向量</li>
<li>**NORMAL：**表面法线向量，需要进行归一化</li>
<li>**TEXCOORDi：**第i组纹理坐标(即UV坐标，范围在0-1之间)，i是0-7中的一个数字</li>
<li>**COLOR：**颜色(光照计算公式=ambient+Diffuse+Specular)</li>
<li>**PSIZE：**点的大小</li>
<li>**BLENDINGICES：**通用属性，可以用它和TANGENT替换TEXCOORDi</li>
</ul>
<p><strong>顶点着色器的输出语义词：</strong></p>
<ul>
<li>**COLOR：**颜色</li>
<li>**FOG：**输入雾坐标</li>
<li>**PSIZE：**大小</li>
<li>**POSITION：**模型坐标位置</li>
<li>**TEXCOORD0-TEXCOORD7：**第i组纹理坐标</li>
</ul>
<p><strong>片段着色器输入语义定义：</strong></p>
<ul>
<li>**COLOR：**颜色</li>
<li>**DEPTH：**片段深度</li>
</ul>
<p><strong>语义绑定三种方法</strong></p>
<pre><code class="language-C#">//方法一:绑定语义放在函数的参数列表的参数声明后[]：表示可选项&lt;&gt;：表示必选项
[const][in|out|inout|uniform]&lt;type&gt;&lt;identifier&gt;[ :&lt;binding-semantic&gt;][=&lt;initializer&gt;]  
void vert(float4 obj_position:POSITION,float4 obj_normal:NORMAL,out float4 outPos:POSITION,uniform float4 uColor:COLOR){}
//方法二:绑定语义放在结构体的成员变量后
Struct&lt;struct-tag&gt;{
	&lt;type&gt;&lt;identifier&gt;[:binding-semantic];
	//sample
	float4 pos : SV_POSITION;
	float4 col:TEXCOORD0;
}
//方法三:绑定语义放在函数生命后面
&lt;type&gt;&lt;identifier&gt;(&lt;parameter-list&gt;)[:&lt;binding-semantic&gt;]{&lt;body&gt;}
float4 frag(vertexOutPut input):COLOR{
    float4 color = float4(1,0,0,1);
    return color;
}

</code></pre>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://sunxiaohang.github.io/post/unity3d/">
              <h3 class="post-title">
                下一篇：Unity3D
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">KnowledgeBase</div>
  <div class="social-container">
    
      
        <a href="https://github.com/sunxiaohang" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="mailto:cssunhang@outlook.com" target="_blank">hangsun</a> | <a class="rss" href="https://sunxiaohang.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
