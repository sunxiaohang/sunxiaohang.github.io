
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>Unity3d扩展编辑器 | KnowledgeBase</title>
<meta name="description" content="KnowledgeBase">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://sunxiaohang.github.io/favicon.ico?v=1586403305895">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://sunxiaohang.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://sunxiaohang.github.io">
        <img class="avatar" src="https://sunxiaohang.github.io/images/avatar.png?v=1586403305895" alt="" width="32px" height="32px">
      </a>
      <a href="https://sunxiaohang.github.io">
        <h1 class="site-title">KnowledgeBase</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
          <h2 class="post-title">Unity3d扩展编辑器</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-04-06</span>
            
          </div>
          <div class="post-content">
            <p>Unity3D扩展编辑器的一些常规操作，深入浅出，属于读书笔记，参考Unity3D游戏开发</p>
<!-- more -->
<h5 id="扩展右键菜单">扩展右键菜单</h5>
<pre><code class="language-c#">//[MenuItem(&quot;Assets/Tools/Debug&quot;,isValidateFunction,priority)]
public class Extension
{
    [MenuItem(&quot;Assets/CustomTools/Debug&quot;,false,2)]
    static void DebugFunction()
    {
        Debug.Log(Selection.activeObject.name);
    }
}
</code></pre>
<h5 id="创建菜单">创建菜单</h5>
<pre><code class="language-c#">//[MenuItem(&quot;Assets/Create/ObjectName&quot;,isValidateFunction,priority)]
public class Extension
{
    [MenuItem(&quot;Assets/Create/Debug&quot;,false,2)]
    static void CreateObjectName()
    {
        GameObject.CreatePrimitive(PrimitiveType.Sphere);
    }
}
</code></pre>
<h5 id="扩展布局">扩展布局</h5>
<pre><code class="language-c#">public class Extension
{
    //表示此方法会在C#代码每次编译完成后首先调用
    [InitializeOnLoadMethod]
    static void Function()
    {
        //监听EditorApplication.projectWindowItemOnGUI委托，即可使用GUI方法来绘制自定义UI元素
        EditorApplication.projectWindowItemOnGUI = delegate(string guid, Rect rect) { 
            //在project视图中选择一个资源
            if (Selection.activeObject &amp;&amp;guid == AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(Selection.activeObject)))
            {
                //设置拓展按钮区域
                float width = 50f;
                rect.x += rect.width - width;
                rect.y += 2f;
                rect.width = width;
                GUI.color = Color.red;
                //点击事件处理的简单写法
                if(GUI.Button(rect,&quot;click&quot;)){
                    Debug.LogFormat(&quot;click:{0}&quot;,Selection.activeObject.name); 
                };
                GUI.color= Color.white;
            }
        };
    }
}
</code></pre>
<h5 id="监听事件">监听事件</h5>
<pre><code class="language-C#">//事件监听需要继承父类UnityEditor.AssetModificationProcessor
public class Extension:UnityEditor.AssetModificationProcessor{
    //全局监听Project视图下的资源是否发生变化
    [InitializeOnLoadMethod]
    static void Function(){
    	EditorApplication.projectChanged += delegate(){Debug.Log(&quot;change&quot;);};
    }
    //监听双击鼠标左键，打开资源事件
    public static bool IsOpenForEdit(string assetPath, out string message){
        return true;//true 表示该资源可以打开，false表示不允许在unity中打开该资源
    }
    //监听资源即将被创建
    private static void OnWillCreateAsset(string assetName){ 
    	Debug.LogFormat(&quot;path:{0}&quot;,assetName);
    }
    //监听资源即将被保存
    private static string[] OnWillSaveAssets(string[] paths){
        if (paths != null)Debug.LogFormat(&quot;path:{0}&quot;,string.Join(&quot;,&quot;,paths));
        return paths;
    }
    //监听资源即将被移动
    private static AssetMoveResult OnWillMoveAsset(string sourcePath, string destinationPath){
        Debug.LogFormat(&quot;from:{0} to {1}&quot;,sourcePath,destinationPath);
        return AssetMoveResult.DidMove;//AssetMoveResult.DidMove表示资源可以移动
    }
    //监听资源即将被删除
    private static AssetDeleteResult OnWillDeleteAsset(string assetPath, RemoveAssetOptions options){
        Debug.LogFormat(&quot;delete:{0}&quot;,assetPath);
        return AssetDeleteResult.DidNotDelete;//表示该资源可以被删除
    }
}
</code></pre>
<h4 id="拓展hierarchy视图">拓展Hierarchy视图</h4>
<h5 id="拓展菜单">拓展菜单</h5>
<pre><code class="language-c#">public class Extension{
    [MenuItem(&quot;GameObject/CustomCreate/Cube&quot;, false, 1)]
    static void CreateCube()
    {
        GameObject.CreatePrimitive(PrimitiveType.Cube);
    }
}
</code></pre>
<h5 id="拓展布局">拓展布局</h5>
<pre><code class="language-C#">public class Extension
{
    [InitializeOnLoadMethod]
    static void InitializeOnLoad()
    {
        EditorApplication.hierarchyWindowItemOnGUI = delegate(int id, Rect rect) {  
            //在hierarchy视图中选择一个资源
            if (Selection.activeObject &amp;&amp; id == Selection.activeObject.GetInstanceID())
            {
                float width = 50f;
                float height = 20f;
                rect.x = rect.width - width;
                rect.width = width;
                rect.height = height;
                if (GUI.Button(rect, AssetDatabase.LoadAssetAtPath&lt;Texture&gt;(&quot;Assets/Unity.png&quot;)))
                {
                    Debug.LogFormat(&quot;click:{0}&quot;,Selection.activeObject.name);
                }
            }
        };
    }
}
</code></pre>
<h5 id="重写菜单">重写菜单</h5>
<pre><code class="language-c#">public class Extension
{
    [InitializeOnLoadMethod]
    static void StartInitializeOnLoadMethod() {
        EditorApplication.hierarchyWindowItemOnGUI += OnHierarchyGUI;
    }
    static void OnHierarchyGUI(int instanceId, Rect selectionRect) {
        if (Event.current != null 
            &amp;&amp; selectionRect.Contains(Event.current.mousePosition)
            &amp;&amp;Event.current.button==1&amp;&amp;Event.current.type&lt;=EventType.MouseUp) {
            GameObject selectedGameObject = EditorUtility.InstanceIDToObject(instanceId) as GameObject;
            if (selectedGameObject) {
                Vector2 mousePosition = Event.current.mousePosition;
                EditorUtility.DisplayPopupMenu(new Rect(mousePosition.x,mousePosition.y,0,0),&quot;Window/Test&quot;,null );
                Event.current.Use();
            }
        }
    }
    [MenuItem(&quot;Window/Test/tools1&quot;)]
    static void Test() {}
    [MenuItem(&quot;Window/Test/tools2&quot;)]
    static void Test1() { }
    [MenuItem(&quot;Window/Test/tools3&quot;)]
    static void Test2() { }
}
</code></pre>
<h4 id="拓展inspector视图">拓展Inspector视图</h4>
<h5 id="拓展原生组件">拓展原生组件</h5>
<pre><code class="language-c#">[CustomEditor(typeof(Camera))]
public class Extension:Editor{
    public override void OnInspectorGUI(){
        if (GUILayout.Button(&quot;extensionButton&quot;)) {/*function*/ }
        base.OnInspectorGUI();
    }
}
</code></pre>
<h5 id="拓展继承组件">拓展继承组件</h5>
<p>Unity将大量的Editor绘制方法封装在内部DLL文件里，开发者无法调用它的方法，只能通过反射的方式调用内部未公开的方法。</p>
<pre><code class="language-C#">[CustomEditor(typeof(Transform))]
public class Extension:Editor{
    private Editor m_Editor;
    private void OnEnable(){
        m_Editor = Editor.CreateEditor(target,     Assembly.GetAssembly(typeof(Editor)).GetType(&quot;UnityEditor.TransformInspector&quot;, true));
    }
    public override void OnInspectorGUI(){
        if (GUILayout.Button(&quot;extensionButton&quot;)) { }
        GUI.enabled = false;//------------开始禁止
        m_Editor.OnInspectorGUI();//调用系统绘制方法
        GUI.enabled = true;//------------结束禁止
        if (GUILayout.Button(&quot;extensionButton2&quot;)) { }
    }
}
</code></pre>
<h5 id="组件不可编辑">组件不可编辑</h5>
<p>HideFlag可以使用按位或(|)同时保持多个属性</p>
<pre><code class="language-c#">GUI.enabled = false;//------------开始禁止
////m_Editor.OnInspectorGUI();//调用系统绘制方法
GUI.enabled = true;//------------结束禁止

//全局锁定与解锁修改
public class Extension{
    [MenuItem(&quot;GameObject/3D Object/Lock/Lock&quot;)]
    static void Lock(){
        if (Selection.gameObjects != null){
            foreach (var gameObject in Selection.gameObjects)       			                       gameObject.hideFlags = HideFlags.NotEditable;
        }
    }
    [MenuItem(&quot;GameObject/3D Object/Lock/Unlock&quot;)]
    static void Unlock(){
        if (Selection.gameObjects != null){
            foreach (var gameObject in Selection.gameObjects) {
                gameObject.hideFlags = HideFlags.None;
            }
        }
    }
}
</code></pre>
<h5 id="context菜单">Context菜单</h5>
<p>Inspector中的组件右键菜单，如果想给所有组件都添加上该菜单<code>Transform</code>&gt;&gt;&gt;<code>Component</code></p>
<pre><code class="language-c#">public class Extension {
    [MenuItem(&quot;CONTEXT/Transform/NewContext1&quot;)]
    static void NewContext1(MenuCommand command) {
        Debug.Log(command.context.name);
    }
}
</code></pre>
<p>该设置也可以用在自己写的脚本中,用于读取和写入组件属性</p>
<pre><code class="language-c#">using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
public class Extension:MonoBehaviour{
    public string contextName;
    #if UNITY_EDITOR
    [MenuItem(&quot;CONTEXT/Extension/NewContext1&quot;)]
    static void NewContext1(MenuCommand command) {
        Extension extension = command.context as Extension;
        if(extension!=null)extension.contextName = &quot;HelloWorld&quot;;
    }
    #endif
}
//#if UNITY_EDITOR     #endif只会在Editor模式下执行，发布后会被剔除
</code></pre>
<p>如果自定义菜单和系统菜单项目重名，还可以覆盖</p>
<pre><code class="language-c#">[ContextMenu(&quot;Remove Component&quot;)]
void RemoveComponent(){
    Debug.Log(&quot;RemoveComponent&quot;);
    //等一会在删除自己
    UnityEditor.EditorApplication.delayCall = delegate(){DestoryImmediate(this);};
}
</code></pre>
<h4 id="拓展scene视图">拓展Scene视图</h4>
<h5 id="辅助元素该类不在editor目录下">辅助元素（该类不在Editor目录下）</h5>
<pre><code class="language-c#">public class Extension:MonoBehaviour{
    private void OnDrawGizmosSelected(){
        Gizmos.color = Color.red;
        Gizmos.DrawLine(transform.position,Vector3.zero);
        Gizmos.DrawCube(Vector3.zero, Vector3.one);
        //其他Gizmos.function()
    }
    //辅助元素不依赖选择对象出现(始终显示zaiScene视图中)
    private void OnDrawGizmos(){
        Gizmos.DrawSphere(transform.position,1);
    }
}
</code></pre>
<h5 id="辅助ui">辅助UI</h5>
<p>在Scene中我们可以添加EditorGUI，方便在视图中处理一些操作。EditorGUI的代码需要在**Handles.BeginGUI()<strong>和</strong>Handles.EndGUI()**中间绘制完成。</p>
<pre><code class="language-c#">[CustomEditor(typeof(Camera))]
public class Extension:Editor{
    private void OnSceneGUI(){
        Camera camera = target as Camera;
        if (camera != null){
            Handles.color = Color.red;
         Handles.Label(camera.transform.position,camera.transform.position.ToString());
            Handles.BeginGUI();
            GUI.backgroundColor = Color.red;
            if (GUILayout.Button(&quot;click&quot;, GUILayout.Width(200f))){
                Debug.LogFormat(&quot;click={0}&quot;,camera.name);
            }
            GUILayout.Label(&quot;Label&quot;);
            Handles.EndGUI();
        }
    }
}
</code></pre>
<h5 id="常驻辅助ui">常驻辅助UI</h5>
<pre><code class="language-c#">public class Extension{
    [InitializeOnLoadMethod]
    static void InitializeOnLoadMethod(){
        SceneView.duringSceneGui += delegate(SceneView sceneView){
            Handles.BeginGUI();
            GUI.Label(new Rect(0,0,50,15),&quot;title&quot; );
            GUI.Button(new Rect(0, 20, 50, 50)
                , AssetDatabase.GetBuiltinExtraResource&lt;Texture&gt;(&quot;Assets/unity.png&quot;));
            Handles.EndGUI();
        };
    }
}
</code></pre>
<h5 id="禁用选中对象">禁用选中对象</h5>
<pre><code class="language-c#">public class Extension{
    [InitializeOnLoadMethod]
    static void InitializeOnLoadMethod(){
        SceneView.duringSceneGui += delegate(SceneView sceneView){
            Event e = Event.current;
            if (e != null){
                //获取它的controllID后，即可禁止将点击事件穿透下去
                //表示禁止接收控制焦点
                int controlID = GUIUtility.GetControlID(FocusType.Passive);
                if (e.type == EventType.Layout){
                    HandleUtility.AddDefaultControl(controlID);
                }
            }
        };
    }
}
</code></pre>
<h4 id="拓展game视图">拓展Game视图</h4>
<p>Game视图拓展分**1.<strong>运行模式</strong>2.**非运行模式</p>
<pre><code class="language-C#">#if UNITY_EDITOR
[ExecuteInEditMode]//非运行模式下也会执行代码的生命周期
public class Extension:MonoBehaviour{
    void OnGUI(){
        if(GUILayout.Button(&quot;Click&quot;)){
            Debug.Log(&quot;Click!&quot;);
        }
        GUILayout.Label(&quot;HelloWorld&quot;);
    }
}
#endif
</code></pre>
<h4 id="menuitem菜单">MenuItem菜单</h4>
<h5 id="覆盖系统菜单">覆盖系统菜单</h5>
<pre><code class="language-c#">[MenuItem(&quot;GameObject/UI/Text&quot;)]
static void CreateNewText(){
    //todo
}
</code></pre>
<h5 id="自定义菜单">自定义菜单</h5>
<pre><code class="language-c#">[MenuItem(&quot;Root/TestCheck&quot;,false,1)]
static void checkFunction() {
    var menuPath = &quot;Root/TestCheck&quot;;
    bool m_Checked = Menu.GetChecked(menuPath);
    Menu.SetChecked(menuPath,!m_Checked);
}
[MenuItem(&quot;Root/TestGray&quot;)]
static void grayFunction() { }
[MenuItem(&quot;Root/TestGray&quot;,true,20)]
static bool grayFunctionValidate() {
    return false;//false表示置灰，不可点击
}
</code></pre>
<h4 id="面板拓展">面板拓展</h4>
<h5 id="inspector面板">Inspector面板</h5>
<pre><code class="language-C#">#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEditor.Experimental.TerrainAPI;
using UnityEngine;

#if UNITY_EDITOR
[CustomEditor(typeof(PoJo))]
public class Extension:Editor
{
    private bool m_EnableToogle;
    public override void OnInspectorGUI()
    {
        PoJo poJo = target as PoJo;
        poJo.scrollPos = EditorGUILayout.BeginScrollView(poJo.scrollPos, false, true);
        poJo.myName = EditorGUILayout.TextField(&quot;text&quot;, poJo.myName);
        poJo.myId = EditorGUILayout.IntField(&quot;int&quot;, poJo.myId);

        poJo.prefab = EditorGUILayout.ObjectField(&quot;GameObject&quot;, poJo.prefab,typeof(GameObject),true)as GameObject;
        //绘制按钮
        EditorGUILayout.BeginHorizontal();
        GUILayout.Button(&quot;1&quot;);
        GUILayout.Button(&quot;2&quot;);
        poJo.myEnum = (PoJo.MyEnum) EditorGUILayout.EnumPopup(&quot;MyEnum:&quot;, poJo.myEnum);
        EditorGUILayout.EndHorizontal();
        
        //toogle component
        m_EnableToogle = EditorGUILayout.BeginToggleGroup(&quot;EnableToogle&quot;, m_EnableToogle);
        poJo.toogle1 = EditorGUILayout.Toggle(&quot;toogle1&quot;, poJo.toogle1);
        poJo.toogle2 = EditorGUILayout.Toggle(&quot;toogle2&quot;, poJo.toogle2);
        EditorGUILayout.EndToggleGroup();
        EditorGUILayout.EndScrollView();
    }
}
#endif
</code></pre>
<h5 id="编辑器窗口editor-window">编辑器窗口Editor Window</h5>
<pre><code class="language-c#">public class CustomWindow:EditorWindow,IHasCustomMenu
{
    [MenuItem(&quot;Window/CustomWindow&quot;)]
    static void Init(){
        CustomWindow window = (CustomWindow) EditorWindow.GetWindow(typeof(CustomWindow));
        window.Show();
    }
    private Texture m_MyTexture = null;
    private float m_MyFloat = 0.5f;
    private void Awake(){
        Debug.LogFormat(&quot;窗口初始化调用&quot;);
        m_MyTexture = AssetDatabase.LoadAssetAtPath&lt;Texture&gt;(&quot;Assets/unity.png&quot;);
    }
    private void OnGUI(){
        GUILayout.Label(&quot;HelloWorld&quot;,EditorStyles.boldLabel);
        m_MyFloat = EditorGUILayout.Slider(&quot;Slide&quot;, m_MyFloat, -5, 5);
        GUI.DrawTexture(new Rect(0,30,100,100),m_MyTexture);
    }
    private void OnDestroy(){/*销毁时调用*/}
    private void OnFocus(){/*拥有焦点时调用*/}
    private void OnHierarchyChange(){/*hierarchy视图发生变化时调用*/}
    private void OnInspectorUpdate(){/*Inspector每帧更新*/}
    private void OnLostFocus(){ /*失去焦点时调用*/}
    private void OnProjectChange(){/*Project视图发生变化时调用*/}
    private void OnSelectionChange(){/*在hierarchy或project视图中选择一个对象时调用*/}
    private void Update(){/*每帧调用*/}
    public void AddItemsToMenu(GenericMenu menu){
        menu.AddDisabledItem(new GUIContent(&quot;Disable&quot;));
        menu.AddItem(new GUIContent(&quot;Test1&quot;),true, () =&gt;{/*todo*/});
        menu.AddSeparator(&quot;Test/&quot;);
        menu.AddItem(new GUIContent(&quot;Test/Test3&quot;),true, () =&gt; { });
    }
}
</code></pre>
<h4 id="自定义导入类型">自定义导入类型</h4>
<pre><code class="language-c#">[ScriptedImporter(1,&quot;custom&quot;)]
public class ImportListener : ScriptedImporter{
    public override void OnImportAsset(AssetImportContext ctx){
        var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
        var position = JsonUtility.FromJson&lt;Vector3&gt;(File.ReadAllText(ctx.assetPath));
        cube.transform.position = position;
        cube.transform.localScale = Vector3.one;
        ctx.AddObjectToAsset(&quot;obj&quot;,cube);
        ctx.SetMainObject(cube);
        //添加材质
        var material = new Material(Shader.Find(&quot;Standard&quot;));
        material.color = Color.red;
        ctx.AddObjectToAsset(&quot;material&quot;,material);
        var tempMesh = new Mesh();
        DestroyImmediate(tempMesh);
    }
}
</code></pre>
<h3 id="游戏脚本">游戏脚本</h3>
<h5 id="脚本序列化">脚本序列化</h5>
<pre><code class="language-c#">#if UNITY_EDITOR
[CustomEditor(typeof(SerializedClass))]
public class ScriptInspector : Editor{
    public override void OnInspectorGUI(){
        serializedObject.Update();//更新最新数据
        EditorGUI.BeginChangeCheck();//标记检查
        SerializedProperty property = serializedObject.FindProperty(&quot;id&quot;);//获取数据信息
        property.intValue = EditorGUILayout.IntField(&quot;主键&quot;, property.intValue);//保存数据
        property = serializedObject.FindProperty(&quot;name&quot;);
        property.stringValue = EditorGUILayout.TextField(&quot;姓名&quot;, property.stringValue);
        property = serializedObject.FindProperty(&quot;prefab&quot;);
        property.objectReferenceValue = EditorGUILayout.ObjectField(&quot;游戏对象&quot;,property.objectReferenceValue,typeof(GameObject),true);
        EditorGUILayout.PropertyField(serializedObject.FindProperty(&quot;targets&quot;), true);
        //标记检查发生变化
        if (EditorGUI.EndChangeCheck());//标记检查发生变化
        if (GUI.changed);//判断面板元素变化
        //保存全部数据
        serializedObject.ApplyModifiedProperties();
    }
}
#endif
</code></pre>
<h5 id="序列化反序列化">序列化反序列化</h5>
<pre><code class="language-c#">public class SerializedClass:MonoBehaviour,ISerializationCallbackReceiver{
    [SerializeField] private List&lt;Sprite&gt; m_Values = new List&lt;Sprite&gt;();
    [SerializeField]private List&lt;string&gt; m_Keys = new List&lt;string&gt;();
    public Dictionary&lt;string, Sprite&gt; m_SpriteDic = new Dictionary&lt;string, Sprite&gt;();
    public void OnBeforeSerialize(){
        m_Keys.Clear();
        m_Values.Clear();
        foreach (KeyValuePair&lt;string,Sprite&gt; pair in m_SpriteDic){
            m_Keys.Add(pair.Key);
            m_Values.Add(pair.Value);
        }
    }
    public void OnAfterDeserialize(){
        m_SpriteDic.Clear();
        for (int i = 0; i &lt; m_Keys.Count; i++){
            m_SpriteDic[m_Keys[i]] = m_Values[i];
        }
    }
}

#if UNITY_EDITOR
[CustomEditor(typeof(SerializedClass))]
public class Extension:Editor{
    public override void OnInspectorGUI(){
        serializedObject.Update();
        SerializedProperty propertyKey = serializedObject.FindProperty(&quot;m_Keys&quot;);
        SerializedProperty propertyValue = serializedObject.FindProperty(&quot;m_Values&quot;);
        GUILayout.BeginVertical();
        for (int i = 0; i &lt; propertyKey.arraySize; i++){
            GUILayout.BeginHorizontal();
            SerializedProperty key = propertyKey.GetArrayElementAtIndex(i);
            SerializedProperty value = propertyValue.GetArrayElementAtIndex(i);
            key.stringValue = EditorGUILayout.TextField(&quot;Key&quot;, key.stringValue);
            value.objectReferenceValue =
                EditorGUILayout.ObjectField(&quot;Value&quot;, value.objectReferenceValue, typeof(Sprite),false);
            GUILayout.EndHorizontal();
        }
        GUILayout.EndVertical();
        GUILayout.BeginHorizontal();
        if (GUILayout.Button(&quot;+&quot;)){
            (target as SerializedClass).m_SpriteDic[propertyKey.arraySize.ToString()] = null;
        }
        GUILayout.EndHorizontal();
        serializedObject.ApplyModifiedProperties();
    }
}
#endif
</code></pre>
<h5 id="scriptable-object">Scriptable Object</h5>
<pre><code class="language-C#">//菜单点击生成
[CreateAssetMenu]
public class Displayer : ScriptableObject{
    [SerializeField] public List&lt;DisplayerInfo&gt; m_DisplayerInfo;
    [Serializable]public class DisplayerInfo{
        public int id;
        public string name;
    }
}
public class DisplayerReader : MonoBehaviour{
    private void Start(){
        Displayer display = Resources.Load&lt;Displayer&gt;(&quot;Path&quot;);//读取
    }
}
</code></pre>
<pre><code class="language-c#">public class Extension{
    [MenuItem(&quot;Assets/Create ScriptableObject&quot;)]
    static void CreateScriptableObject(){
        Displayer displayer = ScriptableObject.CreateInstance&lt;Displayer&gt;();
        displayer.m_DisplayerInfo = new List&lt;Displayer.DisplayerInfo&gt;();
        displayer.m_DisplayerInfo.Add(new Displayer.DisplayerInfo() {id = 100, name = &quot;test&quot;});
        //将资源保存到本地
        AssetDatabase.CreateAsset(displayer,&quot;Assets/Resources/displayer.asset&quot;);
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();
    }
}
</code></pre>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://sunxiaohang.github.io/post/android/">
              <h3 class="post-title">
                下一篇：Android
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">KnowledgeBase</div>
  <div class="social-container">
    
      
        <a href="https://github.com/sunxiaohang" target="_blank">
          <i class="fab fa-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="mailto:cssunhang@outlook.com" target="_blank">hangsun</a> | <a class="rss" href="https://sunxiaohang.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
