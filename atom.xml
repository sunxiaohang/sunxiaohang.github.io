<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sunxiaohang.github.io</id>
    <title>KnowledgeBase</title>
    <updated>2020-04-14T07:00:33.807Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sunxiaohang.github.io"/>
    <link rel="self" href="https://sunxiaohang.github.io/atom.xml"/>
    <subtitle>KnowledgeBase</subtitle>
    <logo>https://sunxiaohang.github.io/images/avatar.png</logo>
    <icon>https://sunxiaohang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, KnowledgeBase</rights>
    <entry>
        <title type="html"><![CDATA[Shader]]></title>
        <id>https://sunxiaohang.github.io/post/shader/</id>
        <link href="https://sunxiaohang.github.io/post/shader/">
        </link>
        <updated>2020-04-14T06:15:44.000Z</updated>
        <content type="html"><![CDATA[<p>Unity shader的渲染流程，模型空间，世界空间，裁切空间，屏幕空间的转换，顶点着色器，片元着色器的一般原理，基础光照模型分析。透明，光线追踪等高特性光照模型原理。主要侧重于移动端的轻量级渲染管线，不考虑主机或PC设备。</p>
<p>tips:渲染流水线的最终目的是渲染一张二维纹理</p>
<p>输入：1.虚拟相机 2.光源 3.一些shader及纹理</p>
<figure data-type="image" tabindex="1"><img src="https://sunxiaohang.github.io/post-images/1586845473202.png" alt="" loading="lazy"></figure>
<h5 id="应用阶段">应用阶段</h5>
<p><em>应用主导</em>,通常由CPU负责实现（开发者具有绝对控制权）</p>
<ul>
<li>准备场景数据</li>
<li>优化(粗粒度剔除(culling)工作,剔除不可见物体)</li>
<li>设置好每个模型的渲染状态(材质，纹理，使用的shader等)</li>
<li>输出是渲染所需的几何信息，即<strong>渲染图元</strong>(rendering primitives)</li>
</ul>
<h5 id="几何阶段">几何阶段</h5>
<p><em>几何阶段</em>用于处理所有要绘制的几何相关（图元是什么，怎么绘制，在哪绘制）</p>
<p>负责和每个渲染图元交互，进行逐顶点、逐多边形的操作。这一阶段会将输出屏幕空间的二位顶点坐标，每个定点对应的深度值，着色等相关信息，并传递给下一阶段</p>
<h5 id="光栅化阶段">光栅化阶段</h5>
<p>使用上个阶段产生的数据产生屏幕上的像素，并渲染出最终的图像，这一阶段实在GPU上执行（决定每个渲染图元上的哪些元素被绘制到屏幕上）</p>
<h5 id="cpu和gpu之间的通信">CPU和GPU之间的通信</h5>
<p>应用阶段</p>
<ul>
<li>把数据加载到显存（VideoRAM）[RAM=&gt;VRAM]{GPU无法直接访问RAM}</li>
<li>设置渲染状态（场景中的网格怎么被渲染[使用哪个顶点着色器(Vertex Shader)/片元着色器(Fragment Shader),光源属性，材质等]）</li>
<li>调用Draw Call（CPU=&gt;GPU）指令仅仅会指向一个需要被渲染的图元(primitives)列表（材质信息已在上一阶段处理完成）</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://sunxiaohang.github.io/post-images/1586845497549.png" alt="" loading="lazy"></figure>
<p><strong>顶点着色器(Vertex Shader):</strong> <em>-完全可编程-</em>，通常用于实现定点的空间变换、顶点着色等</p>
<blockquote>
<p>顶点着色器输入来自CPU，处理单位是顶点（输入进来的每个顶点都会调用一次顶点着色器）【顶点之间是相互独立的可并行】</p>
<ul>
<li>坐标变换：把顶点坐标从模型空间转换到齐次裁剪空间</li>
<li>计算和输出顶点颜色：逐顶点光照</li>
</ul>
</blockquote>
<p>**曲面细分着色器(Tessellation Shader)😗*用于细分图元</p>
<p>**几何着色器(Geometry Shader)😗*可以被用于执行逐图元(Per-Primitive)的着色操作，或被用于产生更多的图元</p>
<p>**裁剪(Clipping)😗*裁剪掉不在摄像机视野内的顶点，并剔除掉某些三角图元的面片（归一化的设备坐标[Normalized Device Coordinates]）</p>
<p>一个图元和摄像机视野的三种关系：**1.**完全在视野内（继续传递给下一阶段） **2.**部分在视野内（<strong>裁剪</strong>） **3.**完全在视野外（不传递）</p>
<p>*--例如--：*一条线段的一个顶点在视野内，另一个定点在视野外，那么在事业外部的顶点应该带使用一个新的顶点代替（位于线段与视野边界的交点处）</p>
<p>**屏幕映射:**把每个图元的x和y坐标转换到屏幕坐标系</p>
<ul>
<li>OpenGL：零点在左下角</li>
<li>DirectX：零点在左上角</li>
</ul>
<p>**三角形设置：**会计算光栅化一个三角形网格所需的信息（为了能够计算边界像素的坐标信息，我们需要得到三角形边界的表示方式）</p>
<p><em><em>三角形遍历：<em><em>检查每个像素是否被一个三角网格覆盖，如果覆盖就生成一个</em>--片元(fragment)--*也被称为</em></em>扫描变换</em>*</p>
<p>**片元着色器(Fragment Shader)😗*实现逐片元的着色操作</p>
<p>根据从顶点着色器输出的数据插值得到一个或多个颜色值</p>
<p>**逐片元操作(Per-Fragment Operations)😗*负责很多重要操作，例如修改颜色，深度缓冲，混合等（逐片元合并）</p>
<ul>
<li>决定每个片元的可见性，涉及很多测试工作，如深度测试，模板测试等</li>
<li>如果一个片元<strong>通过了所有测试</strong>，仅需要把这个片元的颜色值和已经存储的颜色缓冲区中的颜色进行合并（混色）</li>
</ul>
<h5 id="qa">Q&amp;A</h5>
<p><strong>问题1:CPU和GPU是怎样实现并行工作的</strong></p>
<p>*--命令缓冲区(Command Buffer)--：*包含一个命令队列，CPU添加命令，GPU读取命令</p>
<p><strong>问题2:为什么DrawCall多了会影响帧率</strong></p>
<p><em>--每一个DrawCall都需要很多额外的操作--</em></p>
<p><strong>问题3:如何减少DrawCall</strong></p>
<p>*--批处理(Batching)--：*把大量小的DrawCall合并为大的DrawCall</p>
<ul>
<li>避免使用大量很小的网格（不可避免时考虑合并）</li>
<li>避免使用过多材质（尽量在不同网格之间公用同一个材质）</li>
</ul>
<h5 id="固定管线渲染">固定管线渲染</h5>
<p>**固定函数的流水线（Fixed-Function Pipeline）😗*提供一系列配置接口，开发者没有对流水线的完全控制权</p>
<h5 id="unity-shaderunity-shadermaterial">Unity Shader(Unity Shader&amp;Material)</h5>
<ul>
<li>创建一个材质</li>
<li>创建一个Unity Shader，并把它赋给上一步创建的材质</li>
<li>把材质赋给需要渲染的对象</li>
<li>在材质面盘调整Unity Shader属性得到免疫的效果</li>
</ul>
<p>**Material：**材质需要结合一个GameObject的Mesh或者Particle System组件工作，它决定游戏对象的样子</p>
<figure data-type="image" tabindex="3"><img src="https://sunxiaohang.github.io/post-images/1586845518401.png" alt="" loading="lazy"></figure>
<pre><code class="language-c#">Shader &quot;shader路径/Shader名&quot;
{
    Properties
    {
		//属性
        Name(&quot;display name&quot;,PropertyType)=DefaultValue;
        //PropertyType====Int,Float,Range(min,max),Color,Vector,2D,Cube,3D
        //实例
        _Color (&quot;Color&quot;, Color) = (1,1,1,1)
        _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}
        _Glossiness (&quot;Smoothness&quot;, Range(0,1)) = 0.5
        _Metallic (&quot;Metallic&quot;, Range(0,1)) = 0.0
    }
    SubShader
    {
        //-------------显卡A使用的子着色器
        //真正意义上的shader代码
        //Surface Shader/ Vertex Shader / Fragment Shader / Fixed Function Shader
        //表面着色器/顶点着色器/片元着色器/固定函数着色器
        //标签设置 [Tags]
        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
        //状态[RenderSetup]
        
        //Pass 每个Pass定义了一次完整的渲染流程(Pass过多会造成渲染性能的下降)
        Pass{}
    }
    FallBack &quot;Diffuse&quot;
}
</code></pre>
<p><strong>状态设置</strong></p>
<p><em>--定义在SubShader中会应用到所有Pass，定义在单独Pass中仅作用与单个Pass--</em></p>
<ul>
<li><strong>-Cull-:</strong> -Cull Back- | -Front- | -Off- 设置剔除模式：剔除背面/正面/关闭剔除</li>
<li><strong>-ZTest-:</strong> ZTest Less Greater | LEqual | Equal | NotEqual | Always 设置深度测试时使用的函数</li>
<li><strong>-ZWrite-:</strong> ZWrite On | Off 开启/关闭深度写入</li>
<li><strong>-Blend-:</strong> Blend SrcFactor DstFactor开启并设置混合模式</li>
</ul>
<p><strong>SubShader的标签</strong></p>
<pre><code class="language-c#">Tags{&quot;TageName&quot;=&quot;Value&quot; &quot;TagName&quot;=&quot;Value&quot;}
//Queue:控制渲染顺序，指定该物体属于哪一个渲染队列，这种凡是可以保证所有的透明物体可以在所有不透明物体后被渲染
Tags{&quot;Queue&quot;=&quot;Transparent&quot;}
//RenderType:对着色器进行分类，例如透明着色器和不透明着色器
Tags{&quot;RenderType&quot;=&quot;Opaque&quot;}
//DisableBatching:一些SubShader在使用Unity的批处理功能时会出现问题
Tags{&quot;DsiableBatching&quot;=&quot;True&quot;}
//ForceNoShadowCasting:控制使用该SubShader的物体是否会投射阴影
Tags{&quot;ForceNoShadowCasting&quot;=&quot;True&quot;}
//IgnoreProjector:如果该标签为True，那么使用该SubShader的物体将不会受Projector的影响，通常用于半透明物体
Tags{&quot;IgnoreProjector&quot;=&quot;True&quot;}
//CanUseSpriteAtlas:当该标签适用于精灵(sprites)时，将该标签设置为false
Tags{&quot;CanUseSpriteAtlas&quot;=&quot;False&quot;}
//PreviewType:知名材质面板将如何预览该材质，默认情况下，材质显示为一个sphere，可设置为Plane，SkyBox
Tags{&quot;PreviewType&quot;=&quot;Plane&quot;}
</code></pre>
<ul>
<li>**Queue:**控制渲染顺序，指定该物体属于哪一个渲染队列，这种凡是可以保证所有的透明物体可以在所有不透明物体后被渲染=》Tags{&quot;Q&quot;}</li>
</ul>
<p><strong>Pass语义块</strong></p>
<pre><code class="language-c#">//Pass的使用
UsePass &quot;MyShader/PASSNAME&quot;//Pass的名字会被转换为全部大写
...
Pass{
	//[Name]
    Name &quot;PassName&quot;
    //可以在Pass里面通过UsePass复用其他Pass
    UsePass &quot;PassPath/PASSNAME&quot;
    //GrabPass:该Pass负责抓取屏幕并将结果存储在一张纹理中，用于后续的Pass处理
    //[Tags]=&gt;Tags{&quot;tagName&quot;=&quot;tagValue&quot;}
    Tags{&quot;LightMode&quot;=&quot;ForwardBase&quot;}
    Tags{&quot;RequireOptions&quot;=&quot;SoftVegetation&quot;}
    //[RenderSetup]
}
</code></pre>
<h5 id="surface-shader表面着色器无pass">Surface Shader表面着色器（无Pass）</h5>
<pre><code class="language-C#">Shader &quot;Custom/CustomTestShader&quot;
{
    Properties{}
    SubShader
    {
        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
        CGPROGRAM
        //表面着色器的特定语法放在CGPROGRAM和ENDCG之间
        //CG/HLSL编写
        ENDCG
    }
    FallBack &quot;Diffuse&quot;
}
</code></pre>
<h5 id="vertex-fragment-shader顶点片元着色器pass内">Vertex / Fragment Shader顶点/片元着色器（Pass内）</h5>
<pre><code class="language-c#">Shader &quot;Custom/CustomVertexShader&quot;
{
    SubShader
    {
		Pass
		{
			CGPROGRAM
			float4 vert(float4 v:POSITION):SV_POSITION
			{return UnityObjectToClipPos(V);}
			float4 frag() : SV_Target
			{return fixed4(1.0,0.0,0.0,1.0);}
			ENDCG
		}
    }
    FallBack &quot;Diffuse&quot;
}
</code></pre>
<p><strong>着色器选择</strong></p>
<ul>
<li>兼容旧设备(Fixed Function Shader)</li>
<li>光源相关(Surface Shader)，移动平台表现不佳</li>
<li>使用光源较少||自定义渲染效果较多(Vertex/Fragment Shader)</li>
</ul>
<h5 id="坐标系">坐标系</h5>
<ul>
<li>左手坐标系=》旋转{左手法则}</li>
<li>右手坐标系=》旋转{右手法则}</li>
</ul>
<p>在模型空间和世界空间，Unity使用的是左手坐标系</p>
<p>在观察者空间(摄像机)，Unity使用的是右手坐标系，摄像机的前向是z轴的负方向</p>
<p><strong>模型空间(对象空间)(局部空间)坐标系</strong></p>
<p><strong>世界空间</strong></p>
<p><strong>观察者空间</strong>(右手坐标系)</p>
<p>**裁剪空间(齐次裁剪空间)*<em>空间是由</em>--视锥体(View Frustum)--*确定</p>
<p>视锥体有两种投影类型</p>
<ul>
<li>1.正交投影(orthographic projection)
<ul>
<li>正交投影网格大小相同(保留了物体的距离和角度)<strong>[2D游戏或渲染小地图]</strong></li>
<li>正交投影近裁剪平面和远裁剪平面<strong>大小相等</strong></li>
</ul>
</li>
<li>2.透视投影(perspective projection)
<ul>
<li>透视投影网格近大远小(模拟了人眼看世界的方式)<strong>[模拟3D世界物体]</strong></li>
<li>透视投影近裁剪平面和远裁剪平面<strong>近小远大</strong><br>
<img src="https://sunxiaohang.github.io/post-images/1586845545157.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h5 id="unity-shader-内置变量">Unity Shader 内置变量</h5>
<p>模型空间(M&gt;&gt;)世界空间(V&gt;&gt;)观察空间(P&gt;&gt;)裁剪空间</p>
<p><strong>UNITY_MATRIX_MVP</strong> 当前的模型观察投影矩阵，用于将顶点/ 方向矢量从<strong>模型空间</strong>变换到<strong>裁剪空间</strong></p>
<p><strong>UNITY_ MATRIX_MV</strong> 当前的模型观察矩阵， 用于将顶点/ 方向矢量从<strong>模型空间</strong>变换到<strong>观察空间</strong></p>
<p><strong>UNITY_MATRIX_V</strong> 当前的观察矩阵， 用于 将 顶点/ 方向 矢量 从<strong>世界空间</strong> 变换 到 <strong>观察空间</strong></p>
<p><strong>UNITY_MATRIX_P</strong> 当前的投影矩阵， 用于 将 顶点/ 方向 矢量 从<strong>观察空间</strong> 变换 到 <strong>裁剪空间</strong></p>
<p><strong>UNITY_MATRIX_VP</strong> 当前 的 观察 投影 矩阵， 用于 将 顶点/ 方向 矢量 从<strong>世界空间</strong> 变换 到 <strong>裁剪空间</strong></p>
<p><strong>UNITY_ MATRIX_T_MV</strong> UNITY_ MATRIX_ MV 的 <strong>转置矩阵</strong></p>
<p><strong>UNITY_ MATRIX_IT_MV</strong> UNITY_ MATRIX_ MV 的 <strong>逆转置矩阵</strong>， 用于将法线从<strong>模型空间</strong>变换 到<strong>观察空间</strong>， 也可 用于 得到 UNITY_ MATRIX_ MV 的 逆 矩阵</p>
<p><strong>_Object2World</strong> 当前 的 <strong>模型矩阵</strong>， 用于将 顶点/ 方向矢量 <strong>模型空间</strong> 变换到<strong>世界空间</strong></p>
<p><strong>_World2Object <strong>_Object2World 的 <strong>逆矩阵</strong>, 用于将顶点/方向矢量从</strong>世界空间</strong>变换到<strong>模型空间</strong></p>
<h5 id="camera和屏幕参数">Camera和屏幕参数</h5>
<p><strong>_WorldSpaceCameraPos</strong> float3 该 摄像机 在世 界 空间 中的 位置 _</p>
<p><strong>_ProjectionParams</strong> float4 x = 1. 0（ 或 ? 1. 0， 如果 正在 使用 一个 翻转 的 投影 矩阵 进行 渲染）， y = Near， z = Far， w = 1. 0 + 1. 0/ Far， 其中 Near 和 Far 分 别是 近 裁剪 平面 和 远 裁剪 平面 和 摄像机 的 距离</p>
<p><strong>_ScreenParams</strong> float4 x = width， y = height， z = 1. 0 + 1. 0/ width， w = 1. 0 + 1. 0/ height， 其中 width 和 height 分 别是 该 摄像机 的 渲染 目标（ render target） 的 像素 宽度 和 高度</p>
<p><strong>_ZBufferParams</strong> float4 x = 1 ? Far/ Near， y = Far/ Near， z = x/ Far， w = y/ Far， 该 变量 用于 线性化 Z 缓存 中的 深度 值（ 可 参考 13. 1 节）</p>
<p><strong>unity_ OrthoParams</strong> float4 x = width， y = heigth， z 没有 定义， w = 1. 0（ 该 摄像机 是 正交 摄像机） 或 w = 0. 0（ 该 摄像机 是 透视 摄像机）， 其中 width 和 height 是 正交 投影 摄像机 的 宽度 和 高度</p>
<p><strong>unity_ CameraProjection</strong> float4x4 该 摄像机 的 投影 矩阵</p>
<p><strong>unity_ CameraInvProjection</strong> float4x4 该 摄像机 的 投影 矩阵 的 逆 矩阵</p>
<p><strong>unity_ CameraWorldClipPlanes[ 6]</strong> float4 该 摄像机 的 6 个 裁剪 平面 在世 界 空间 下 的 等式， 按 如下 顺序： 左、 右、 下、 上、 近、 远 裁剪 平面</p>
<h5 id="unity中的屏幕坐标">Unity中的屏幕坐标</h5>
<p>**VPOS/WPOS:**分别是HLSL和Cg对屏幕坐标的定义，两者在unity中等价</p>
<pre><code class="language-C#">//VPOS/WPOS语义定义的输入是一个float4类型的变量
//xy值代表在屏幕空间中的像素坐标，[0.5-400.5]
//unity中，VPOS/WPOS的z分量范围是[0,1]，在摄像机近裁剪平面，z值为0，远裁剪平面，z为1
//w分量表示摄像机的投影类型{透视投影[1/Near,1/Far](Near和Far对应裁剪平面到摄像机的距离)}{正交投影[恒为1]}
//把屏幕空间初一屏幕分辨率来得到{视口空间(viewspace)}中的坐标
//视口坐标是把屏幕坐标归一化，左下角(0,0)右上角就是(1,1)[xy值除以屏幕分辨率即可]或者用ComputeScreenPos函数：
fixed4 frag(float4 sp:VPOS):SV_Target
{
    return fixed4(sp.xy/ScreenParams.xy,0.0,1.0);
}
//ComputeScreenPos函数使用示例
struct vertOut{
	float pos:SV_POSITION;
	float scrPos:TEXCOORD0;
}
vertOut vert(appdata_base v){
	vertOut o;
	o.pos = mul(UNITY_MATRIX_MVP,v.vertex);
	o.scrPos = ComputeScreenPos(o.pos);
	return 0;
}
fixed4 frag(vertOut i):SV_Target{
	float2 wcoord = (i.scrPos.xy/i.scrPos.w);
	return fixed3(wcoord,0.0,1.0);
}

</code></pre>
<h5 id="unity-cg语法汇总">Unity Cg语法汇总</h5>
<p><strong>额外基础类型</strong></p>
<ul>
<li><strong>half</strong> 16位浮点数 [-60000,60000]精度{小数点后3.3位}</li>
<li><strong>fixed</strong> 12位定点数[-2,2]，精度1/256</li>
<li><strong>sampler</strong>* 分为sampler,sampler1D,sampler2D,sampler3D,samplerCUBE和samplerRECT</li>
</ul>
<p><strong>Swizzle操作符</strong>（只能用于<strong>结构体</strong>和<strong>向量</strong>）</p>
<p>float4(a,b,c,d).xwz等价于 float(a,d,c)</p>
<p><strong>输入数据关键字</strong></p>
<ul>
<li><strong>Varying：<strong>在Cg程序中通过语义进行绑定Cg语言提供了一组语义词，用以表示参数是由顶点的哪些数据初始化的，语义词绑定后=&gt;变量被初始化的同时也以为这变量有了特殊含义，如表示位置、法线等{语义提供了一种使用</strong>随顶点变化</strong>或随<strong>片段变化</strong>的值来初始化Cg程序参数的方法，如：顶点位置，法向量，纹理坐标等}</li>
<li><strong>Uniform参数：<strong>Uniform是用来</strong>限制一个变量的初始值的来源</strong>，表示该变量初始值来源于外部环境，【Unity内置Uniform输入参数列表(部分如：模型矩阵，视锥体，时间量，相机位置，光源位置等)】</li>
</ul>
<p>**语义：**表示图元数据的含义(顶点位置，法向量或者纹理信息)也表示这些图元数据存放的硬件资源，<strong>顶点着色器的输出即是片段着色器的输入</strong>（因此两者输出输入语义必须是一致的）[语义只对这两个阶段有意义，且只在入口函数有效，在内部函数无效]<strong>可以理解为输出&gt;输入关系映射</strong>，语义词和语义绑定如下：</p>
<ul>
<li>**POSITION/SV_POSITION：<strong>模型坐标位置{两者唯一区别是：当用在顶点着色器中</strong>+**作为语义输出时，SV_POSITION表示的顶点位置会被固定，不能改变}</li>
<li>**TANGENT：**正交于表面法线的向量</li>
<li>**NORMAL：**表面法线向量，需要进行归一化</li>
<li>**TEXCOORDi：**第i组纹理坐标(即UV坐标，范围在0-1之间)，i是0-7中的一个数字</li>
<li>**COLOR：**颜色(光照计算公式=ambient+Diffuse+Specular)</li>
<li>**PSIZE：**点的大小</li>
<li>**BLENDINGICES：**通用属性，可以用它和TANGENT替换TEXCOORDi</li>
</ul>
<p><strong>顶点着色器的输出语义词：</strong></p>
<ul>
<li>**COLOR：**颜色</li>
<li>**FOG：**输入雾坐标</li>
<li>**PSIZE：**大小</li>
<li>**POSITION：**模型坐标位置</li>
<li>**TEXCOORD0-TEXCOORD7：**第i组纹理坐标</li>
</ul>
<p><strong>片段着色器输入语义定义：</strong></p>
<ul>
<li>**COLOR：**颜色</li>
<li>**DEPTH：**片段深度</li>
</ul>
<p><strong>语义绑定三种方法</strong></p>
<pre><code class="language-C#">//方法一:绑定语义放在函数的参数列表的参数声明后[]：表示可选项&lt;&gt;：表示必选项
[const][in|out|inout|uniform]&lt;type&gt;&lt;identifier&gt;[ :&lt;binding-semantic&gt;][=&lt;initializer&gt;]  
void vert(float4 obj_position:POSITION,float4 obj_normal:NORMAL,out float4 outPos:POSITION,uniform float4 uColor:COLOR){}
//方法二:绑定语义放在结构体的成员变量后
Struct&lt;struct-tag&gt;{
	&lt;type&gt;&lt;identifier&gt;[:binding-semantic];
	//sample
	float4 pos : SV_POSITION;
	float4 col:TEXCOORD0;
}
//方法三:绑定语义放在函数生命后面
&lt;type&gt;&lt;identifier&gt;(&lt;parameter-list&gt;)[:&lt;binding-semantic&gt;]{&lt;body&gt;}
float4 frag(vertexOutPut input):COLOR{
    float4 color = float4(1,0,0,1);
    return color;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity3D]]></title>
        <id>https://sunxiaohang.github.io/post/unity3d/</id>
        <link href="https://sunxiaohang.github.io/post/unity3d/">
        </link>
        <updated>2020-04-06T11:49:39.000Z</updated>
        <summary type="html"><![CDATA[<p>Unity3D项目关键知识点汇总，方便后期复习巩固，包括关键的monobehaviour生命周期，协程，工作线程，相机变换相关，射线投射，对象池化技术，unity中常用到的一半3D数学运算，点积、差积、欧拉角和四元数等相关笔记。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Unity3D项目关键知识点汇总，方便后期复习巩固，包括关键的monobehaviour生命周期，协程，工作线程，相机变换相关，射线投射，对象池化技术，unity中常用到的一半3D数学运算，点积、差积、欧拉角和四元数等相关笔记。</p>
<!-- more -->
<h4 id="unity-基础类图">Unity 基础类图</h4>
<figure data-type="image" tabindex="1"><img src="https://sunxiaohang.github.io/post-images/1586173848463.png" alt="" loading="lazy"></figure>
<h4 id="unity生命周期">Unity生命周期</h4>
<figure data-type="image" tabindex="2"><img src="https://sunxiaohang.github.io/post-images/1586173894549.png" alt="" loading="lazy"></figure>
<h4 id="camera">Camera</h4>
<pre><code>//-----------------------------------------------------
//-------------------通过相机的切换来实现场景的切换
/////渲染画中画(多相机){如：赛车游戏的后视镜，小地图}
/////高depth相机的画面会覆盖低depth相机画面
/////推拉变焦是摄像机同时向目标对象移动并将其缩小的视觉效果(对象大小看起来大致相同，从而达到改变其他对象视角的目的)
void Start(){
    distance = Vector3.Distance(transform.position,target.position);
    heightAtDistance = FrustumHeightAtDistance(distance);
    EnabledE();
}
void Update(){
    var distance = Vector3.Distance(transform.position,target.position);
    Camera.fieldOfView = FovForHeightAtDistance(initialDistance,CurrentDistance);
}
//----------------------------------------------------------
//------------------------射线投射-------------------------
void Start(){
    RayCastHit hit;
    //Camera.ViewPortPointToRay(0..1)坐标[0表示左下，1表示右上]
    Ray ray = Camera.ScreenPointToRay(Input.mousePosition);
    if(Physics.RayCast(ray,out hit)){
        Transform objectHit =hit.transform;
        //命中 to do
    }
}
//----------------------------------------------------------
//--------------------沿射线移动相机(缩放)----------------
void Update(){
    Ray ray = camera.ScreenPointToRay(Input.mousePOsition);
    float zoomDistance = zoomSpeed*Input.GetAxis(&quot;Vertical&quot;)*Time.deltaTime;
    Camera.tranform.Translate(ray.direction*zoomDistance,Space.world);
}
//----------------------------------------------------------
//---------------------修改斜视锥体pivot------------------
Matrix4*4 mat = Camera.main.projectionMatrix;
mat[0,2] = horizontalObl;//float(horizontal) 水平倾斜量 &lt;&quot;+&quot;&gt;向上
mat[1,2] = VerticalObl;//float(vertical) 垂直倾斜量 &lt;&quot;-&quot;&gt;向下
Camera.main.projectionMatrix = mat;
</code></pre>
<h4 id="pool">Pool</h4>
<pre><code>//----------------------------------------------------------
//---------------------game object pool------------------
public class ObjectPool : MonoBehaviour
{
   public static ObjectPool instance;
   public GameObject[] objectPrefabs;
   public List&lt;GameObject&gt;[] pooledObjects;
   public int[] amountToBuffer;
   public int defaultBufferAmount = 3;
   protected GameObject containerObject;
   void Awake (){instance = this;}
   void Start (){
       containerObject = new GameObject(&quot;ObjectPool&quot;);
       pooledObjects = new List&lt;GameObject&gt;[objectPrefabs.Length];
       int i = 0;
       foreach ( GameObject objectPrefab in objectPrefabs ){
           pooledObjects[i] = new List&lt;GameObject&gt;();  
           int bufferAmount;
           if(i &lt; amountToBuffer.Length) bufferAmount = amountToBuffer[i];
           else bufferAmount = defaultBufferAmount;
           for ( int n=0; n&lt;bufferAmount; n++){
               GameObject newObj = Instantiate(objectPrefab) as GameObject;
               newObj.name = objectPrefab.name;
               PoolObject(newObj);
           }
           i++;
       }
   }
   public GameObject GetObjectForType ( string objectType , bool onlyPooled ){
       for(int i=0; i&lt;objectPrefabs.Length; i++){
           GameObject prefab = objectPrefabs[i];
           if(prefab.name == objectType){
               if(pooledObjects[i].Count &gt; 0){
                   GameObject pooledObject = pooledObjects[i][0];
                   pooledObjects[i].RemoveAt(0);
                   pooledObject.transform.parent = null;
                   pooledObject.SetActiveRecursively(true);
                   return pooledObject;
               } else if(!onlyPooled) {
                   return Instantiate(objectPrefabs[i]) as GameObject;
               }
               break;
           }
       }
       return null;
   }
   public void PoolObject ( GameObject obj ){
       for ( int i=0; i&lt;objectPrefabs.Length; i++){
           if(objectPrefabs[i].name == obj.name){
               obj.SetActiveRecursively(false);
               obj.transform.parent = containerObject.transform;
               pooledObjects[i].Add(obj);
               return;
           }
       }
   }
}
//----------------------------------------------------------
//--------------------------effect pool--------------------
public class Effect : MonoBehaviour{
   public ParticleEmitter[] emitters;
   public float effectLength = 1f;
   public bool poolAfterComplete = true;
   public virtual void ResetEffect (){
       if(poolAfterComplete){
           ObjectPool.instance.PoolObject(gameObject);
       } else {
           Destroy(gameObject);
       }
   }
   public virtual void StartEffect (){
       foreach ( ParticleEmitter emitter in emitters ){
           emitter.Emit();
       }
       StartCoroutine(WaitForCompletion());
   }
   public IEnumerator WaitForCompletion (){
       yield return new WaitForSeconds(effectLength);
       ResetEffect();  
   }
}
//----------------------------------------------------------
//--------------------------sound pool--------------------
public class SoundEffect : MonoBehaviour{
   public AudioSource soundSource;
   public AudioClip[] soundClips;
   public float effectLength = 1f;
   public bool poolAfterComplete = true;
   public virtual void ResetEffect (){
       if(poolAfterComplete){
           ObjectPool.instance.PoolObject(gameObject);
       } else {
           Destroy(gameObject);
       }
   }
   public virtual void StartEffect (){
       soundSource.PlayOneShot(soundClips[Random.Range(0,soundClips.Length)]);
       StartCoroutine(WaitForCompletion());
   }
   public IEnumerator WaitForCompletion (){
       yield return new WaitForSeconds(effectLength);
       ResetEffect();
   }
}
</code></pre>
<h4 id="点积magnitude">点积（Magnitude）</h4>
<p>Dot Product = Ax<em>Bx+Ay</em>By+Az*Bz<br>
点积可以用于判断一个多边形是面向摄像机还是背向摄像机,(或模拟飞机飞行，通过判断飞机飞行方向与垂直地面方向的夹角判断飞机是上升还是下降)在U，V非零前提下<br>
• 点积为负=&gt;(U,V&gt;90)<br>
• 点积为正=&gt;(U,V&lt;90)<br>
• 点积为零=&gt;(U,V=90)</p>
<h4 id="差积左手定则中指为result方向结果矢量垂直与ab矢量">差积[左手定则]{中指为result方向}(结果矢量垂直与ab矢量)</h4>
<p>Vector2：A<em>B=X1</em>Y2+X2*Y1<br>
Vector3:(yz,zx,xy)<br>
Cx = AyBz-AzBy<br>
Cy = AzBx-AxBz<br>
Cz = AxBy-AyBx<br>
result = (Cx,Cy,Cz)<br>
角动量（当前指向的方向向量a，目标方向的方向向量b）求[叉积]=旋转轴</p>
<h4 id="enable-and-disable-component">Enable and Disable Component</h4>
<p>Component.enable = true|false<br>
控制一个物体是否在屏幕上渲染或显示</p>
<h4 id="active-and-deactivate-component">Active and Deactivate Component</h4>
<p>component.SetActive(false);<br>
控制是否在场景中使用该物体，findObject是否能找到<br>
SetActiveRecursively()控制递归子物体</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity3d扩展编辑器]]></title>
        <id>https://sunxiaohang.github.io/post/unity3d-kuo-zhan-bian-ji-qi/</id>
        <link href="https://sunxiaohang.github.io/post/unity3d-kuo-zhan-bian-ji-qi/">
        </link>
        <updated>2020-02-11T11:44:11.000Z</updated>
        <summary type="html"><![CDATA[<p>Unity3D扩展编辑器的一些常规操作，包括扩展菜单栏，扩展属性Inspector操作，以及扩展自定义工具窗体，设计基本C#处理流程，表格读取处理，剧情编辑，表现组处理，以及其他外链批处理操作。参考Unity3D游戏开发以及日常项目开发经验。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Unity3D扩展编辑器的一些常规操作，包括扩展菜单栏，扩展属性Inspector操作，以及扩展自定义工具窗体，设计基本C#处理流程，表格读取处理，剧情编辑，表现组处理，以及其他外链批处理操作。参考Unity3D游戏开发以及日常项目开发经验。</p>
<!-- more -->
<h5 id="扩展右键菜单">扩展右键菜单</h5>
<pre><code class="language-c#">//[MenuItem(&quot;Assets/Tools/Debug&quot;,isValidateFunction,priority)]
public class Extension
{
    [MenuItem(&quot;Assets/CustomTools/Debug&quot;,false,2)]
    static void DebugFunction()
    {
        Debug.Log(Selection.activeObject.name);
    }
}
</code></pre>
<h5 id="创建菜单">创建菜单</h5>
<pre><code class="language-c#">//[MenuItem(&quot;Assets/Create/ObjectName&quot;,isValidateFunction,priority)]
public class Extension
{
    [MenuItem(&quot;Assets/Create/Debug&quot;,false,2)]
    static void CreateObjectName()
    {
        GameObject.CreatePrimitive(PrimitiveType.Sphere);
    }
}
</code></pre>
<h5 id="扩展布局">扩展布局</h5>
<pre><code class="language-c#">public class Extension
{
    //表示此方法会在C#代码每次编译完成后首先调用
    [InitializeOnLoadMethod]
    static void Function()
    {
        //监听EditorApplication.projectWindowItemOnGUI委托，即可使用GUI方法来绘制自定义UI元素
        EditorApplication.projectWindowItemOnGUI = delegate(string guid, Rect rect) { 
            //在project视图中选择一个资源
            if (Selection.activeObject &amp;&amp;guid == AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(Selection.activeObject)))
            {
                //设置拓展按钮区域
                float width = 50f;
                rect.x += rect.width - width;
                rect.y += 2f;
                rect.width = width;
                GUI.color = Color.red;
                //点击事件处理的简单写法
                if(GUI.Button(rect,&quot;click&quot;)){
                    Debug.LogFormat(&quot;click:{0}&quot;,Selection.activeObject.name); 
                };
                GUI.color= Color.white;
            }
        };
    }
}
</code></pre>
<h5 id="监听事件">监听事件</h5>
<pre><code class="language-C#">//事件监听需要继承父类UnityEditor.AssetModificationProcessor
public class Extension:UnityEditor.AssetModificationProcessor{
    //全局监听Project视图下的资源是否发生变化
    [InitializeOnLoadMethod]
    static void Function(){
    	EditorApplication.projectChanged += delegate(){Debug.Log(&quot;change&quot;);};
    }
    //监听双击鼠标左键，打开资源事件
    public static bool IsOpenForEdit(string assetPath, out string message){
        return true;//true 表示该资源可以打开，false表示不允许在unity中打开该资源
    }
    //监听资源即将被创建
    private static void OnWillCreateAsset(string assetName){ 
    	Debug.LogFormat(&quot;path:{0}&quot;,assetName);
    }
    //监听资源即将被保存
    private static string[] OnWillSaveAssets(string[] paths){
        if (paths != null)Debug.LogFormat(&quot;path:{0}&quot;,string.Join(&quot;,&quot;,paths));
        return paths;
    }
    //监听资源即将被移动
    private static AssetMoveResult OnWillMoveAsset(string sourcePath, string destinationPath){
        Debug.LogFormat(&quot;from:{0} to {1}&quot;,sourcePath,destinationPath);
        return AssetMoveResult.DidMove;//AssetMoveResult.DidMove表示资源可以移动
    }
    //监听资源即将被删除
    private static AssetDeleteResult OnWillDeleteAsset(string assetPath, RemoveAssetOptions options){
        Debug.LogFormat(&quot;delete:{0}&quot;,assetPath);
        return AssetDeleteResult.DidNotDelete;//表示该资源可以被删除
    }
}
</code></pre>
<h4 id="拓展hierarchy视图">拓展Hierarchy视图</h4>
<h5 id="拓展菜单">拓展菜单</h5>
<pre><code class="language-c#">public class Extension{
    [MenuItem(&quot;GameObject/CustomCreate/Cube&quot;, false, 1)]
    static void CreateCube()
    {
        GameObject.CreatePrimitive(PrimitiveType.Cube);
    }
}
</code></pre>
<h5 id="拓展布局">拓展布局</h5>
<pre><code class="language-C#">public class Extension
{
    [InitializeOnLoadMethod]
    static void InitializeOnLoad()
    {
        EditorApplication.hierarchyWindowItemOnGUI = delegate(int id, Rect rect) {  
            //在hierarchy视图中选择一个资源
            if (Selection.activeObject &amp;&amp; id == Selection.activeObject.GetInstanceID())
            {
                float width = 50f;
                float height = 20f;
                rect.x = rect.width - width;
                rect.width = width;
                rect.height = height;
                if (GUI.Button(rect, AssetDatabase.LoadAssetAtPath&lt;Texture&gt;(&quot;Assets/Unity.png&quot;)))
                {
                    Debug.LogFormat(&quot;click:{0}&quot;,Selection.activeObject.name);
                }
            }
        };
    }
}
</code></pre>
<h5 id="重写菜单">重写菜单</h5>
<pre><code class="language-c#">public class Extension
{
    [InitializeOnLoadMethod]
    static void StartInitializeOnLoadMethod() {
        EditorApplication.hierarchyWindowItemOnGUI += OnHierarchyGUI;
    }
    static void OnHierarchyGUI(int instanceId, Rect selectionRect) {
        if (Event.current != null 
            &amp;&amp; selectionRect.Contains(Event.current.mousePosition)
            &amp;&amp;Event.current.button==1&amp;&amp;Event.current.type&lt;=EventType.MouseUp) {
            GameObject selectedGameObject = EditorUtility.InstanceIDToObject(instanceId) as GameObject;
            if (selectedGameObject) {
                Vector2 mousePosition = Event.current.mousePosition;
                EditorUtility.DisplayPopupMenu(new Rect(mousePosition.x,mousePosition.y,0,0),&quot;Window/Test&quot;,null );
                Event.current.Use();
            }
        }
    }
    [MenuItem(&quot;Window/Test/tools1&quot;)]
    static void Test() {}
    [MenuItem(&quot;Window/Test/tools2&quot;)]
    static void Test1() { }
    [MenuItem(&quot;Window/Test/tools3&quot;)]
    static void Test2() { }
}
</code></pre>
<h4 id="拓展inspector视图">拓展Inspector视图</h4>
<h5 id="拓展原生组件">拓展原生组件</h5>
<pre><code class="language-c#">[CustomEditor(typeof(Camera))]
public class Extension:Editor{
    public override void OnInspectorGUI(){
        if (GUILayout.Button(&quot;extensionButton&quot;)) {/*function*/ }
        base.OnInspectorGUI();
    }
}
</code></pre>
<h5 id="拓展继承组件">拓展继承组件</h5>
<p>Unity将大量的Editor绘制方法封装在内部DLL文件里，开发者无法调用它的方法，只能通过反射的方式调用内部未公开的方法。</p>
<pre><code class="language-C#">[CustomEditor(typeof(Transform))]
public class Extension:Editor{
    private Editor m_Editor;
    private void OnEnable(){
        m_Editor = Editor.CreateEditor(target,     Assembly.GetAssembly(typeof(Editor)).GetType(&quot;UnityEditor.TransformInspector&quot;, true));
    }
    public override void OnInspectorGUI(){
        if (GUILayout.Button(&quot;extensionButton&quot;)) { }
        GUI.enabled = false;//------------开始禁止
        m_Editor.OnInspectorGUI();//调用系统绘制方法
        GUI.enabled = true;//------------结束禁止
        if (GUILayout.Button(&quot;extensionButton2&quot;)) { }
    }
}
</code></pre>
<h5 id="组件不可编辑">组件不可编辑</h5>
<p>HideFlag可以使用按位或(|)同时保持多个属性</p>
<pre><code class="language-c#">GUI.enabled = false;//------------开始禁止
////m_Editor.OnInspectorGUI();//调用系统绘制方法
GUI.enabled = true;//------------结束禁止

//全局锁定与解锁修改
public class Extension{
    [MenuItem(&quot;GameObject/3D Object/Lock/Lock&quot;)]
    static void Lock(){
        if (Selection.gameObjects != null){
            foreach (var gameObject in Selection.gameObjects)       			                       gameObject.hideFlags = HideFlags.NotEditable;
        }
    }
    [MenuItem(&quot;GameObject/3D Object/Lock/Unlock&quot;)]
    static void Unlock(){
        if (Selection.gameObjects != null){
            foreach (var gameObject in Selection.gameObjects) {
                gameObject.hideFlags = HideFlags.None;
            }
        }
    }
}
</code></pre>
<h5 id="context菜单">Context菜单</h5>
<p>Inspector中的组件右键菜单，如果想给所有组件都添加上该菜单<code>Transform</code>&gt;&gt;&gt;<code>Component</code></p>
<pre><code class="language-c#">public class Extension {
    [MenuItem(&quot;CONTEXT/Transform/NewContext1&quot;)]
    static void NewContext1(MenuCommand command) {
        Debug.Log(command.context.name);
    }
}
</code></pre>
<p>该设置也可以用在自己写的脚本中,用于读取和写入组件属性</p>
<pre><code class="language-c#">using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
public class Extension:MonoBehaviour{
    public string contextName;
    #if UNITY_EDITOR
    [MenuItem(&quot;CONTEXT/Extension/NewContext1&quot;)]
    static void NewContext1(MenuCommand command) {
        Extension extension = command.context as Extension;
        if(extension!=null)extension.contextName = &quot;HelloWorld&quot;;
    }
    #endif
}
//#if UNITY_EDITOR     #endif只会在Editor模式下执行，发布后会被剔除
</code></pre>
<p>如果自定义菜单和系统菜单项目重名，还可以覆盖</p>
<pre><code class="language-c#">[ContextMenu(&quot;Remove Component&quot;)]
void RemoveComponent(){
    Debug.Log(&quot;RemoveComponent&quot;);
    //等一会在删除自己
    UnityEditor.EditorApplication.delayCall = delegate(){DestoryImmediate(this);};
}
</code></pre>
<h4 id="拓展scene视图">拓展Scene视图</h4>
<h5 id="辅助元素该类不在editor目录下">辅助元素（该类不在Editor目录下）</h5>
<pre><code class="language-c#">public class Extension:MonoBehaviour{
    private void OnDrawGizmosSelected(){
        Gizmos.color = Color.red;
        Gizmos.DrawLine(transform.position,Vector3.zero);
        Gizmos.DrawCube(Vector3.zero, Vector3.one);
        //其他Gizmos.function()
    }
    //辅助元素不依赖选择对象出现(始终显示zaiScene视图中)
    private void OnDrawGizmos(){
        Gizmos.DrawSphere(transform.position,1);
    }
}
</code></pre>
<h5 id="辅助ui">辅助UI</h5>
<p>在Scene中我们可以添加EditorGUI，方便在视图中处理一些操作。EditorGUI的代码需要在**Handles.BeginGUI()<strong>和</strong>Handles.EndGUI()**中间绘制完成。</p>
<pre><code class="language-c#">[CustomEditor(typeof(Camera))]
public class Extension:Editor{
    private void OnSceneGUI(){
        Camera camera = target as Camera;
        if (camera != null){
            Handles.color = Color.red;
         Handles.Label(camera.transform.position,camera.transform.position.ToString());
            Handles.BeginGUI();
            GUI.backgroundColor = Color.red;
            if (GUILayout.Button(&quot;click&quot;, GUILayout.Width(200f))){
                Debug.LogFormat(&quot;click={0}&quot;,camera.name);
            }
            GUILayout.Label(&quot;Label&quot;);
            Handles.EndGUI();
        }
    }
}
</code></pre>
<h5 id="常驻辅助ui">常驻辅助UI</h5>
<pre><code class="language-c#">public class Extension{
    [InitializeOnLoadMethod]
    static void InitializeOnLoadMethod(){
        SceneView.duringSceneGui += delegate(SceneView sceneView){
            Handles.BeginGUI();
            GUI.Label(new Rect(0,0,50,15),&quot;title&quot; );
            GUI.Button(new Rect(0, 20, 50, 50)
                , AssetDatabase.GetBuiltinExtraResource&lt;Texture&gt;(&quot;Assets/unity.png&quot;));
            Handles.EndGUI();
        };
    }
}
</code></pre>
<h5 id="禁用选中对象">禁用选中对象</h5>
<pre><code class="language-c#">public class Extension{
    [InitializeOnLoadMethod]
    static void InitializeOnLoadMethod(){
        SceneView.duringSceneGui += delegate(SceneView sceneView){
            Event e = Event.current;
            if (e != null){
                //获取它的controllID后，即可禁止将点击事件穿透下去
                //表示禁止接收控制焦点
                int controlID = GUIUtility.GetControlID(FocusType.Passive);
                if (e.type == EventType.Layout){
                    HandleUtility.AddDefaultControl(controlID);
                }
            }
        };
    }
}
</code></pre>
<h4 id="拓展game视图">拓展Game视图</h4>
<p>Game视图拓展分**1.<strong>运行模式</strong>2.**非运行模式</p>
<pre><code class="language-C#">#if UNITY_EDITOR
[ExecuteInEditMode]//非运行模式下也会执行代码的生命周期
public class Extension:MonoBehaviour{
    void OnGUI(){
        if(GUILayout.Button(&quot;Click&quot;)){
            Debug.Log(&quot;Click!&quot;);
        }
        GUILayout.Label(&quot;HelloWorld&quot;);
    }
}
#endif
</code></pre>
<h4 id="menuitem菜单">MenuItem菜单</h4>
<h5 id="覆盖系统菜单">覆盖系统菜单</h5>
<pre><code class="language-c#">[MenuItem(&quot;GameObject/UI/Text&quot;)]
static void CreateNewText(){
    //todo
}
</code></pre>
<h5 id="自定义菜单">自定义菜单</h5>
<pre><code class="language-c#">[MenuItem(&quot;Root/TestCheck&quot;,false,1)]
static void checkFunction() {
    var menuPath = &quot;Root/TestCheck&quot;;
    bool m_Checked = Menu.GetChecked(menuPath);
    Menu.SetChecked(menuPath,!m_Checked);
}
[MenuItem(&quot;Root/TestGray&quot;)]
static void grayFunction() { }
[MenuItem(&quot;Root/TestGray&quot;,true,20)]
static bool grayFunctionValidate() {
    return false;//false表示置灰，不可点击
}
</code></pre>
<h4 id="面板拓展">面板拓展</h4>
<h5 id="inspector面板">Inspector面板</h5>
<pre><code class="language-C#">#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEditor.Experimental.TerrainAPI;
using UnityEngine;

#if UNITY_EDITOR
[CustomEditor(typeof(PoJo))]
public class Extension:Editor
{
    private bool m_EnableToogle;
    public override void OnInspectorGUI()
    {
        PoJo poJo = target as PoJo;
        poJo.scrollPos = EditorGUILayout.BeginScrollView(poJo.scrollPos, false, true);
        poJo.myName = EditorGUILayout.TextField(&quot;text&quot;, poJo.myName);
        poJo.myId = EditorGUILayout.IntField(&quot;int&quot;, poJo.myId);

        poJo.prefab = EditorGUILayout.ObjectField(&quot;GameObject&quot;, poJo.prefab,typeof(GameObject),true)as GameObject;
        //绘制按钮
        EditorGUILayout.BeginHorizontal();
        GUILayout.Button(&quot;1&quot;);
        GUILayout.Button(&quot;2&quot;);
        poJo.myEnum = (PoJo.MyEnum) EditorGUILayout.EnumPopup(&quot;MyEnum:&quot;, poJo.myEnum);
        EditorGUILayout.EndHorizontal();
        
        //toogle component
        m_EnableToogle = EditorGUILayout.BeginToggleGroup(&quot;EnableToogle&quot;, m_EnableToogle);
        poJo.toogle1 = EditorGUILayout.Toggle(&quot;toogle1&quot;, poJo.toogle1);
        poJo.toogle2 = EditorGUILayout.Toggle(&quot;toogle2&quot;, poJo.toogle2);
        EditorGUILayout.EndToggleGroup();
        EditorGUILayout.EndScrollView();
    }
}
#endif
</code></pre>
<h5 id="编辑器窗口editor-window">编辑器窗口Editor Window</h5>
<pre><code class="language-c#">public class CustomWindow:EditorWindow,IHasCustomMenu
{
    [MenuItem(&quot;Window/CustomWindow&quot;)]
    static void Init(){
        CustomWindow window = (CustomWindow) EditorWindow.GetWindow(typeof(CustomWindow));
        window.Show();
    }
    private Texture m_MyTexture = null;
    private float m_MyFloat = 0.5f;
    private void Awake(){
        Debug.LogFormat(&quot;窗口初始化调用&quot;);
        m_MyTexture = AssetDatabase.LoadAssetAtPath&lt;Texture&gt;(&quot;Assets/unity.png&quot;);
    }
    private void OnGUI(){
        GUILayout.Label(&quot;HelloWorld&quot;,EditorStyles.boldLabel);
        m_MyFloat = EditorGUILayout.Slider(&quot;Slide&quot;, m_MyFloat, -5, 5);
        GUI.DrawTexture(new Rect(0,30,100,100),m_MyTexture);
    }
    private void OnDestroy(){/*销毁时调用*/}
    private void OnFocus(){/*拥有焦点时调用*/}
    private void OnHierarchyChange(){/*hierarchy视图发生变化时调用*/}
    private void OnInspectorUpdate(){/*Inspector每帧更新*/}
    private void OnLostFocus(){ /*失去焦点时调用*/}
    private void OnProjectChange(){/*Project视图发生变化时调用*/}
    private void OnSelectionChange(){/*在hierarchy或project视图中选择一个对象时调用*/}
    private void Update(){/*每帧调用*/}
    public void AddItemsToMenu(GenericMenu menu){
        menu.AddDisabledItem(new GUIContent(&quot;Disable&quot;));
        menu.AddItem(new GUIContent(&quot;Test1&quot;),true, () =&gt;{/*todo*/});
        menu.AddSeparator(&quot;Test/&quot;);
        menu.AddItem(new GUIContent(&quot;Test/Test3&quot;),true, () =&gt; { });
    }
}
</code></pre>
<h4 id="自定义导入类型">自定义导入类型</h4>
<pre><code class="language-c#">[ScriptedImporter(1,&quot;custom&quot;)]
public class ImportListener : ScriptedImporter{
    public override void OnImportAsset(AssetImportContext ctx){
        var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
        var position = JsonUtility.FromJson&lt;Vector3&gt;(File.ReadAllText(ctx.assetPath));
        cube.transform.position = position;
        cube.transform.localScale = Vector3.one;
        ctx.AddObjectToAsset(&quot;obj&quot;,cube);
        ctx.SetMainObject(cube);
        //添加材质
        var material = new Material(Shader.Find(&quot;Standard&quot;));
        material.color = Color.red;
        ctx.AddObjectToAsset(&quot;material&quot;,material);
        var tempMesh = new Mesh();
        DestroyImmediate(tempMesh);
    }
}
</code></pre>
<h3 id="游戏脚本">游戏脚本</h3>
<h5 id="脚本序列化">脚本序列化</h5>
<pre><code class="language-c#">#if UNITY_EDITOR
[CustomEditor(typeof(SerializedClass))]
public class ScriptInspector : Editor{
    public override void OnInspectorGUI(){
        serializedObject.Update();//更新最新数据
        EditorGUI.BeginChangeCheck();//标记检查
        SerializedProperty property = serializedObject.FindProperty(&quot;id&quot;);//获取数据信息
        property.intValue = EditorGUILayout.IntField(&quot;主键&quot;, property.intValue);//保存数据
        property = serializedObject.FindProperty(&quot;name&quot;);
        property.stringValue = EditorGUILayout.TextField(&quot;姓名&quot;, property.stringValue);
        property = serializedObject.FindProperty(&quot;prefab&quot;);
        property.objectReferenceValue = EditorGUILayout.ObjectField(&quot;游戏对象&quot;,property.objectReferenceValue,typeof(GameObject),true);
        EditorGUILayout.PropertyField(serializedObject.FindProperty(&quot;targets&quot;), true);
        //标记检查发生变化
        if (EditorGUI.EndChangeCheck());//标记检查发生变化
        if (GUI.changed);//判断面板元素变化
        //保存全部数据
        serializedObject.ApplyModifiedProperties();
    }
}
#endif
</code></pre>
<h5 id="序列化反序列化">序列化反序列化</h5>
<pre><code class="language-c#">public class SerializedClass:MonoBehaviour,ISerializationCallbackReceiver{
    [SerializeField] private List&lt;Sprite&gt; m_Values = new List&lt;Sprite&gt;();
    [SerializeField]private List&lt;string&gt; m_Keys = new List&lt;string&gt;();
    public Dictionary&lt;string, Sprite&gt; m_SpriteDic = new Dictionary&lt;string, Sprite&gt;();
    public void OnBeforeSerialize(){
        m_Keys.Clear();
        m_Values.Clear();
        foreach (KeyValuePair&lt;string,Sprite&gt; pair in m_SpriteDic){
            m_Keys.Add(pair.Key);
            m_Values.Add(pair.Value);
        }
    }
    public void OnAfterDeserialize(){
        m_SpriteDic.Clear();
        for (int i = 0; i &lt; m_Keys.Count; i++){
            m_SpriteDic[m_Keys[i]] = m_Values[i];
        }
    }
}

#if UNITY_EDITOR
[CustomEditor(typeof(SerializedClass))]
public class Extension:Editor{
    public override void OnInspectorGUI(){
        serializedObject.Update();
        SerializedProperty propertyKey = serializedObject.FindProperty(&quot;m_Keys&quot;);
        SerializedProperty propertyValue = serializedObject.FindProperty(&quot;m_Values&quot;);
        GUILayout.BeginVertical();
        for (int i = 0; i &lt; propertyKey.arraySize; i++){
            GUILayout.BeginHorizontal();
            SerializedProperty key = propertyKey.GetArrayElementAtIndex(i);
            SerializedProperty value = propertyValue.GetArrayElementAtIndex(i);
            key.stringValue = EditorGUILayout.TextField(&quot;Key&quot;, key.stringValue);
            value.objectReferenceValue =
                EditorGUILayout.ObjectField(&quot;Value&quot;, value.objectReferenceValue, typeof(Sprite),false);
            GUILayout.EndHorizontal();
        }
        GUILayout.EndVertical();
        GUILayout.BeginHorizontal();
        if (GUILayout.Button(&quot;+&quot;)){
            (target as SerializedClass).m_SpriteDic[propertyKey.arraySize.ToString()] = null;
        }
        GUILayout.EndHorizontal();
        serializedObject.ApplyModifiedProperties();
    }
}
#endif
</code></pre>
<h5 id="scriptable-object">Scriptable Object</h5>
<pre><code class="language-C#">//菜单点击生成
[CreateAssetMenu]
public class Displayer : ScriptableObject{
    [SerializeField] public List&lt;DisplayerInfo&gt; m_DisplayerInfo;
    [Serializable]public class DisplayerInfo{
        public int id;
        public string name;
    }
}
public class DisplayerReader : MonoBehaviour{
    private void Start(){
        Displayer display = Resources.Load&lt;Displayer&gt;(&quot;Path&quot;);//读取
    }
}
</code></pre>
<pre><code class="language-c#">public class Extension{
    [MenuItem(&quot;Assets/Create ScriptableObject&quot;)]
    static void CreateScriptableObject(){
        Displayer displayer = ScriptableObject.CreateInstance&lt;Displayer&gt;();
        displayer.m_DisplayerInfo = new List&lt;Displayer.DisplayerInfo&gt;();
        displayer.m_DisplayerInfo.Add(new Displayer.DisplayerInfo() {id = 100, name = &quot;test&quot;});
        //将资源保存到本地
        AssetDatabase.CreateAsset(displayer,&quot;Assets/Resources/displayer.asset&quot;);
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity InAction]]></title>
        <id>https://sunxiaohang.github.io/post/unity-inaction/</id>
        <link href="https://sunxiaohang.github.io/post/unity-inaction/">
        </link>
        <updated>2020-02-06T12:09:00.000Z</updated>
        <summary type="html"><![CDATA[<p>Untiy常用逻辑代码的实现方式，归纳总结，用于标准化代码结构，巩固加强，包括基本的平移旋转缩放操作，相机视角变换，Cinemachine，自定义track，表现组，以及playable接口的自定义实现。日常开发过程中的一些小trick标准实现。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Untiy常用逻辑代码的实现方式，归纳总结，用于标准化代码结构，巩固加强，包括基本的平移旋转缩放操作，相机视角变换，Cinemachine，自定义track，表现组，以及playable接口的自定义实现。日常开发过程中的一些小trick标准实现。</p>
<!-- more -->
<h4 id="movement">Movement</h4>
<pre><code>public class FPSInput : MonoBehaviour
{
    public float m_speed = 6.0f;
    private CharacterController m_CharacterController;
    public float gravity = -9.8f;

    private void Start()
    {
        m_CharacterController = GetComponent&lt;CharacterController&gt;();
    }

    private void Update()
    {
        //移动的代码依赖于游戏的帧率，frame rate dependence
        float deltaX = Input.GetAxis(&quot;Horizontal&quot;) * m_speed;
        float deltaZ = Input.GetAxis(&quot;Vertical&quot;) * m_speed;
        Vector3 movement = new Vector3(deltaX,0,deltaZ);
        movement = Vector3.ClampMagnitude(movement, m_speed) * Time.deltaTime;//使对角移动的速度和沿轴移动的速度一样
        movement = transform.TransformDirection(movement);//把movement向量丛本地坐标变换为全局坐标
        movement.y = gravity;
        m_CharacterController.Move(movement);
    }
}
</code></pre>
<h4 id="rotation">Rotation</h4>
<pre><code>public class MouseLook : MonoBehaviour
{
    public enum RotationAxes
    {
        MouseXAndY,
        MouseX,
        MouseY
    }

    public RotationAxes axes = RotationAxes.MouseXAndY;
    public float sensitivityHor = 9.0f;
    public float sensitivityVert = 9.0f;
    public float miniMumVert = -45.0f;
    public float maxiMumVert = 45.0f;
    private float _rotationX = 0;
    private Rigidbody m_Rigidbody;

    private void Start()
    {
        m_Rigidbody = GetComponent&lt;Rigidbody&gt;();
        if(m_Rigidbody!=null)m_Rigidbody.freezeRotation = true;
    }

    private void Update()
    {
        if (axes == RotationAxes.MouseX)
        {
            transform.Rotate(0,Input.GetAxisRaw(&quot;Mouse X&quot;)*sensitivityHor,0);
        }
        else if (axes == RotationAxes.MouseY)
        {
            _rotationX -= Input.GetAxis(&quot;Mouse Y&quot;) * sensitivityVert;
            _rotationX = Mathf.Clamp(_rotationX,miniMumVert,maxiMumVert);
            float rotationY = transform.localEulerAngles.y;//获取当前y轴的欧拉角
            transform.localEulerAngles = new Vector3(_rotationX,rotationY,0);
        }
        else if (axes == RotationAxes.MouseXAndY)
        {
            _rotationX -= Input.GetAxis(&quot;Mouse Y&quot;) * sensitivityHor;
            _rotationX = Mathf.Clamp(_rotationX, miniMumVert, maxiMumVert);
            float rotationY = Input.GetAxis(&quot;Mouse X&quot;) * sensitivityVert+transform.localEulerAngles.y;
            transform.localEulerAngles = new Vector3(_rotationX,rotationY,0);
        }
    }
}
</code></pre>
<h4 id="messenger">Messenger</h4>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
 
public enum MessengerMode {
    DONT_REQUIRE_LISTENER,
    REQUIRE_LISTENER,
}
 
static internal class MessengerInternal {
    readonly public static Dictionary&lt;string, Delegate&gt; eventTable = new Dictionary&lt;string, Delegate&gt;();
    static public MessengerMode DEFAULT_MODE = MessengerMode.REQUIRE_LISTENER;
 
    static public void AddListener(string eventType, Delegate callback) {
        MessengerInternal.OnListenerAdding(eventType, callback);
        eventTable[eventType] = Delegate.Combine(eventTable[eventType], callback);
    }
 
    static public void RemoveListener(string eventType, Delegate handler) {
        MessengerInternal.OnListenerRemoving(eventType, handler);   
        eventTable[eventType] = Delegate.Remove(eventTable[eventType], handler);
        MessengerInternal.OnListenerRemoved(eventType);
    }
 
    static public T[] GetInvocationList&lt;T&gt;(string eventType) {
        Delegate d;
        if(eventTable.TryGetValue(eventType, out d)) {
            try {
                return d.GetInvocationList().Cast&lt;T&gt;().ToArray();
            } catch {
                throw MessengerInternal.CreateBroadcastSignatureException(eventType);
            }
        }
        return new T[0];
    }
 
    static public void OnListenerAdding(string eventType, Delegate listenerBeingAdded) {
        if (!eventTable.ContainsKey(eventType)) {
            eventTable.Add(eventType, null);
        }
 
        var d = eventTable[eventType];
        if (d != null &amp;&amp; d.GetType() != listenerBeingAdded.GetType()) {
            throw new ListenerException(string.Format(&quot;Attempting to add listener with inconsistent signature for event type {0}. Current listeners have type {1} and listener being added has type {2}&quot;, eventType, d.GetType().Name, listenerBeingAdded.GetType().Name));
        }
    }
 
    static public void OnListenerRemoving(string eventType, Delegate listenerBeingRemoved) {
        if (eventTable.ContainsKey(eventType)) {
            var d = eventTable[eventType];
 
            if (d == null) {
                throw new ListenerException(string.Format(&quot;Attempting to remove listener with for event type {0} but current listener is null.&quot;, eventType));
            } else if (d.GetType() != listenerBeingRemoved.GetType()) {
                throw new ListenerException(string.Format(&quot;Attempting to remove listener with inconsistent signature for event type {0}. Current listeners have type {1} and listener being removed has type {2}&quot;, eventType, d.GetType().Name, listenerBeingRemoved.GetType().Name));
            }
        } else {
            throw new ListenerException(string.Format(&quot;Attempting to remove listener for type {0} but Messenger doesn't know about this event type.&quot;, eventType));
        }
    }
 
    static public void OnListenerRemoved(string eventType) {
        if (eventTable[eventType] == null) {
            eventTable.Remove(eventType);
        }
    }
 
    static public void OnBroadcasting(string eventType, MessengerMode mode) {
        if (mode == MessengerMode.REQUIRE_LISTENER &amp;&amp; !eventTable.ContainsKey(eventType)) {
            throw new MessengerInternal.BroadcastException(string.Format(&quot;Broadcasting message {0} but no listener found.&quot;, eventType));
        }
    }
 
    static public BroadcastException CreateBroadcastSignatureException(string eventType) {
        return new BroadcastException(string.Format(&quot;Broadcasting message {0} but listeners have a different signature than the broadcaster.&quot;, eventType));
    }
 
    public class BroadcastException : Exception {
        public BroadcastException(string msg)
            : base(msg) {
        }
    }
 
    public class ListenerException : Exception {
        public ListenerException(string msg)
            : base(msg) {
        }
    }
}
 
// No parameters
static public class Messenger { 
    static public void AddListener(string eventType, Action handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void AddListener&lt;TReturn&gt;(string eventType, Func&lt;TReturn&gt; handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void RemoveListener(string eventType, Action handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void RemoveListener&lt;TReturn&gt;(string eventType, Func&lt;TReturn&gt; handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void Broadcast(string eventType) {
        Broadcast(eventType, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, Action&lt;TReturn&gt; returnCall) {
        Broadcast(eventType, returnCall, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast(string eventType, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Action&gt;(eventType);
 
        foreach(var callback in invocationList)
            callback.Invoke();
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, Action&lt;TReturn&gt; returnCall, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Func&lt;TReturn&gt;&gt;(eventType);
 
        foreach(var result in invocationList.Select(del =&gt; del.Invoke()).Cast&lt;TReturn&gt;()) {
            returnCall.Invoke(result);
        }
    }
}
 
// One parameter
static public class Messenger&lt;T&gt; {
    static public void AddListener(string eventType, Action&lt;T&gt; handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void AddListener&lt;TReturn&gt;(string eventType, Func&lt;T, TReturn&gt; handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void RemoveListener(string eventType, Action&lt;T&gt; handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void RemoveListener&lt;TReturn&gt;(string eventType, Func&lt;T, TReturn&gt; handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void Broadcast(string eventType, T arg1) {
        Broadcast(eventType, arg1, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, T arg1, Action&lt;TReturn&gt; returnCall) {
        Broadcast(eventType, arg1, returnCall, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast(string eventType, T arg1, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Action&lt;T&gt;&gt;(eventType);
 
        foreach(var callback in invocationList)
            callback.Invoke(arg1);
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, T arg1, Action&lt;TReturn&gt; returnCall, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Func&lt;T, TReturn&gt;&gt;(eventType);
 
        foreach(var result in invocationList.Select(del =&gt; del.Invoke(arg1)).Cast&lt;TReturn&gt;()) {
            returnCall.Invoke(result);
        }
    }
}
 
 
// Two parameters
static public class Messenger&lt;T, U&gt; { 
    static public void AddListener(string eventType, Action&lt;T, U&gt; handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void AddListener&lt;TReturn&gt;(string eventType, Func&lt;T, U, TReturn&gt; handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void RemoveListener(string eventType, Action&lt;T, U&gt; handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void RemoveListener&lt;TReturn&gt;(string eventType, Func&lt;T, U, TReturn&gt; handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void Broadcast(string eventType, T arg1, U arg2) {
        Broadcast(eventType, arg1, arg2, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, T arg1, U arg2, Action&lt;TReturn&gt; returnCall) {
        Broadcast(eventType, arg1, arg2, returnCall, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast(string eventType, T arg1, U arg2, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Action&lt;T, U&gt;&gt;(eventType);
 
        foreach(var callback in invocationList)
            callback.Invoke(arg1, arg2);
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, T arg1, U arg2, Action&lt;TReturn&gt; returnCall, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Func&lt;T, U, TReturn&gt;&gt;(eventType);
 
        foreach(var result in invocationList.Select(del =&gt; del.Invoke(arg1, arg2)).Cast&lt;TReturn&gt;()) {
            returnCall.Invoke(result);
        }
    }
}
 
 
// Three parameters
static public class Messenger&lt;T, U, V&gt; { 
    static public void AddListener(string eventType, Action&lt;T, U, V&gt; handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void AddListener&lt;TReturn&gt;(string eventType, Func&lt;T, U, V, TReturn&gt; handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void RemoveListener(string eventType, Action&lt;T, U, V&gt; handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void RemoveListener&lt;TReturn&gt;(string eventType, Func&lt;T, U, V, TReturn&gt; handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void Broadcast(string eventType, T arg1, U arg2, V arg3) {
        Broadcast(eventType, arg1, arg2, arg3, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, T arg1, U arg2, V arg3, Action&lt;TReturn&gt; returnCall) {
        Broadcast(eventType, arg1, arg2, arg3, returnCall, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast(string eventType, T arg1, U arg2, V arg3, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Action&lt;T, U, V&gt;&gt;(eventType);
 
        foreach(var callback in invocationList)
            callback.Invoke(arg1, arg2, arg3);
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, T arg1, U arg2, V arg3, Action&lt;TReturn&gt; returnCall, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Func&lt;T, U, V, TReturn&gt;&gt;(eventType);
 
        foreach(var result in invocationList.Select(del =&gt; del.Invoke(arg1, arg2, arg3)).Cast&lt;TReturn&gt;()) {
            returnCall.Invoke(result);
        }
    }
}
</code></pre>
<h4 id="playable">Playable</h4>
<pre><code>//---------------------------------------------------
//-----------------------播放动画-------------------
public class PlayAnimation : MonoBehaviour
{
    public AnimationClip AnimationClip1;
    public AnimationClip AnimationClip2;

    private PlayableGraph m_PlayableGraph;
    private void OnGUI()
    {
        if (GUILayout.Button(&quot;&lt;size=80&gt;play clips1&lt;/size&gt;&quot;))
        {
            AnimationPlayableUtilities.PlayClip(GetComponent&lt;Animator&gt;(),AnimationClip1,out m_PlayableGraph);
        }
        if (GUILayout.Button(&quot;&lt;size=80&gt;play clips2&lt;/size&gt;&quot;))
        {
            AnimationPlayableUtilities.PlayClip(GetComponent&lt;Animator&gt;(),AnimationClip2,out m_PlayableGraph);
        }
    }

    private void OnDisable()
    {
        m_PlayableGraph.Destroy();
    }
}
//---------------------------------------------------
//---------------------PlayableAssets--------------
//自定义timeline assets
[Serializable]
public class CustomPlayableAssets : PlayableAsset
{
    public ExposedReference&lt;GameObject&gt; ExposedReference;
    public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
    {
        CustomPlayableBehaviour behaviour = new CustomPlayableBehaviour();
        behaviour.eposedObjectValue = ExposedReference.Resolve(graph.GetResolver());
        return ScriptPlayable&lt;CustomPlayableBehaviour&gt;.Create(graph, behaviour);
    }
}

//自定义timeline behaviour
public class CustomPlayableBehaviour : PlayableBehaviour
{
    //graphStart&gt;&gt;BehaviourPause&gt;&gt;BehaviourStart&gt;&gt;BehaviourPause&gt;&gt;graphStop
    //接收序列化对象
    public GameObject eposedObjectValue;

    //graph开始运行时调用
    public override void OnGraphStart(Playable playable)
    {
        base.OnGraphStart(playable);
    }
    //graph结束时调用
    public override void OnGraphStop(Playable playable)
    {
        base.OnGraphStop(playable);
    }
    //playable播放时调用
    public override void OnBehaviourPlay(Playable playable, FrameData info)
    {
        base.OnBehaviourPlay(playable, info);
    }
    //playable暂停时调用
    public override void OnBehaviourPause(Playable playable, FrameData info)
    {
        base.OnBehaviourPause(playable, info);
    }
    //每帧调用
    public override void PrepareFrame(Playable playable, FrameData info)
    {
        //可能此时还没绑定对象，所以需要判空
        if (eposedObjectValue != null)
        {
            PlayableDirector director = playable.GetGraph&lt;Playable&gt;().GetResolver() as PlayableDirector;
            Debug.LogFormat(&quot;PlayableDirector:{0},eposedObjectValue:{1}&quot;,director.gameObject.name,eposedObjectValue.name);
        }
    }
}
//---------------------------------------------------
//-----------------------自定义track----------------
[TrackColor(1f,0f,0f)]
[TrackClipType(typeof(CustomPlayableAssets))]
[TrackBindingType(typeof(CustomTrack))]
public class CustomTrack : TrackAsset
{
    protected override Playable CreatePlayable(PlayableGraph graph, GameObject gameObject, TimelineClip clip)
    {
        return base.CreatePlayable(graph, gameObject, clip);
    }

    public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
    {
        return base.CreateTrackMixer(graph, go, inputCount);
    }
}

//---------------------------------------------------
//-----------------------动画融合-------------------
public class CustomPlayMixer : MonoBehaviour
{
    public AnimationClip AnimationClip1;
    public AnimationClip AnimationClip2;
    public float weight;
    private PlayableGraph m_PlayableGraph;
    private AnimationMixerPlayable m_AnimationMixerPlayable;
    private void Start()
    {
        m_AnimationMixerPlayable =
            AnimationPlayableUtilities.PlayMixer(GetComponent&lt;Animator&gt;(), 2, out m_PlayableGraph);
        AnimationClipPlayable clipPlayable1 = AnimationClipPlayable.Create(m_PlayableGraph,AnimationClip1);
        AnimationClipPlayable clipPlayable2 = AnimationClipPlayable.Create(m_PlayableGraph,AnimationClip2);
        m_PlayableGraph.Connect(clipPlayable1, 0, m_AnimationMixerPlayable, 0);
        m_PlayableGraph.Connect(clipPlayable2, 0, m_AnimationMixerPlayable, 1);
        AnimationPlayableOutput output = AnimationPlayableOutput.Create(m_PlayableGraph,&quot;AnimationOutput&quot;,GetComponent&lt;Animator&gt;());
        output.SetSourcePlayable(m_AnimationMixerPlayable);
        m_AnimationMixerPlayable.Play();
    }
    private void Update()
    {
        weight = Mathf.Clamp01(weight);
        m_AnimationMixerPlayable.SetInputWeight(0,1-weight);
        m_AnimationMixerPlayable.SetInputWeight(1,weight);
    }
    private void OnDestroy()
    {
        m_PlayableGraph.Destroy();
    }
}
//---------------------------------------------------
//-------------------------音频融合-----------------
public class AudioMixer : MonoBehaviour
{
    public AudioClip m_AudioClip1;
    public AudioClip m_AudioClip2;
    public float weight;
    private PlayableGraph m_PlayableGraph;
    public AudioMixerPlayable m_AudioMixerPlayable;
    private void Start()
    {
        m_PlayableGraph = PlayableGraph.Create();
        m_AudioMixerPlayable = AudioMixerPlayable.Create(m_PlayableGraph,2);
        var audioClipPlayable1 = AudioClipPlayable.Create(m_PlayableGraph, m_AudioClip1, true);
        var audioClipPlayable2 = AudioClipPlayable.Create(m_PlayableGraph, m_AudioClip2, true);
        m_PlayableGraph.Connect(audioClipPlayable1,0,m_AudioMixerPlayable,0);
        m_PlayableGraph.Connect(audioClipPlayable2,0,m_AudioMixerPlayable,1);
        var audioPlayableOutput = AudioPlayableOutput.Create(m_PlayableGraph, &quot;Audio&quot;, GetComponent&lt;AudioSource&gt;());
        audioPlayableOutput.SetSourcePlayable(m_AudioMixerPlayable);
        m_AudioMixerPlayable.Play();
    }
    private void Update()
    {
        weight = Mathf.Clamp01(weight);
        m_AudioMixerPlayable.SetInputWeight(0,1-weight);
        m_AudioMixerPlayable.SetInputWeight(1,weight);
    }

    private void OnDisable()
    {
        m_PlayableGraph.Destroy();
    }
}
//---------------------------------------------------
//-------------------------速度控制-----------------
public class MovingSphere : MonoBehaviour
{
    // Update is called once per frame
    [SerializeField, Range(0f, 100f)] private float max_Speed = 10f;
    [SerializeField, Range(0f, 100f)] private float max_Acceleration = 10f;
    [SerializeField]Rect allowedArea = new Rect(-5,-5,10,10);
    private float boundFactor = 0.7f;
    private Vector3 velocity;
    void Update()
    {
        Vector2 playerInput;
        playerInput.x = Input.GetAxis(&quot;Horizontal&quot;);
        playerInput.y = Input.GetAxis(&quot;Vertical&quot;);
        playerInput = Vector2.ClampMagnitude(playerInput, 1f);
        
        Vector3 desiredVelocity = new Vector3(playerInput.x,0f,playerInput.y)*max_Speed;
        float maxSpeedChange = max_Acceleration * Time.deltaTime;
        
        velocity.x = Mathf.MoveTowards(velocity.x, desiredVelocity.x, maxSpeedChange);
        velocity.z = Mathf.MoveTowards(velocity.z, desiredVelocity.z, maxSpeedChange);
        
        Vector3 displacement = velocity * Time.deltaTime;
        Vector3 targetPosition = transform.localPosition + displacement;
        if (targetPosition.x &lt; allowedArea.xMin)
        {
            targetPosition.x = allowedArea.xMin;
            velocity.x = -velocity.x*boundFactor;
        }else if (targetPosition.x &gt; allowedArea.xMax)
        {
            targetPosition.x = allowedArea.xMax;
            velocity.x = -velocity.x*boundFactor;
        }        
        if (targetPosition.z &lt; allowedArea.yMin)
        {
            targetPosition.z = allowedArea.yMin;
            velocity.z = -velocity.z*boundFactor;
        }else if (targetPosition.z &gt; allowedArea.yMax)
        {
            targetPosition.z = allowedArea.yMax;
            velocity.z = -velocity.z*boundFactor;
        }

        transform.localPosition = targetPosition;
    }
}
//---------------------------------------------------
//--------------------------TPS---------------------
//ThirdPersonCharacterControl
public class ThirdPersonCharacterControl : MonoBehaviour
{
    public float Speed;
    void Update (){
        PlayerMovement();
    }
    void PlayerMovement(){
        float hor = Input.GetAxis(&quot;Horizontal&quot;);
        float ver = Input.GetAxis(&quot;Vertical&quot;);
        Vector3 playerMovement = new Vector3(hor, 0f, ver) * Speed * Time.deltaTime;
        transform.Translate(playerMovement, Space.Self);
    }
}
//ThirdPersonCameraControl
public class ThirdPersonCameraControl : MonoBehaviour{
    float rotationSpeed = 1;
    public Transform Target, Player;
    float mouseX, mouseY;
    public Transform Obstruction;
    float zoomSpeed = 2f;
    void Start(){
        Obstruction = Target;
        Cursor.visible = false;
        Cursor.lockState = CursorLockMode.Locked;
    }
    private void LateUpdate(){
        CamControl();
        ViewObstructed();
    }
    void CamControl(){
        mouseX += Input.GetAxis(&quot;Mouse X&quot;) * rotationSpeed;
        mouseY -= Input.GetAxis(&quot;Mouse Y&quot;) * rotationSpeed;
        mouseY = Mathf.Clamp(mouseY, -35, 60);
        transform.LookAt(Target);
        if (Input.GetKey(KeyCode.LeftShift)){
            Target.rotation = Quaternion.Euler(mouseY, mouseX, 0);
        }
        else{
            Target.rotation = Quaternion.Euler(mouseY, mouseX, 0);
            Player.rotation = Quaternion.Euler(0, mouseX, 0);
        }
    }
    void ViewObstructed(){
        RaycastHit hit;
        if (Physics.Raycast(transform.position, Target.position - transform.position, out hit, 4.5f)){
            if (hit.collider.gameObject.tag != &quot;Player&quot;){
                Obstruction = hit.transform;
                Obstruction.gameObject.GetComponent&lt;MeshRenderer&gt;().shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.ShadowsOnly;
                if(Vector3.Distance(Obstruction.position, transform.position) &gt;= 3f &amp;&amp; Vector3.Distance(transform.position, Target.position) &gt;= 1.5f)
                    transform.Translate(Vector3.forward * zoomSpeed * Time.deltaTime);
            }
            else{
                Obstruction.gameObject.GetComponent&lt;MeshRenderer&gt;().shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.On;
                if (Vector3.Distance(transform.position, Target.position) &lt; 4.5f)
                    transform.Translate(Vector3.back * zoomSpeed * Time.deltaTime);
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#]]></title>
        <id>https://sunxiaohang.github.io/post/c/</id>
        <link href="https://sunxiaohang.github.io/post/c/">
        </link>
        <updated>2019-10-17T11:52:42.000Z</updated>
        <summary type="html"><![CDATA[<p>C#关键知识点总结，主要针对一些新特性和泛型，和C#事件系统，主要针对Unity3d，非标准C#<br>
注意在一些较新版本的.net 支持的新特性当中，要特别注意兼容性问题和性能问题，例如函数式，lambda以及null option.</p>
]]></summary>
        <content type="html"><![CDATA[<p>C#关键知识点总结，主要针对一些新特性和泛型，和C#事件系统，主要针对Unity3d，非标准C#<br>
注意在一些较新版本的.net 支持的新特性当中，要特别注意兼容性问题和性能问题，例如函数式，lambda以及null option.</p>
<!-- more -->
<h4 id="泛型委托">泛型委托</h4>
<pre><code>delegate void Del&lt;T&gt;(T item);
public static void Notify(int i) { }
...
Del&lt;int&gt; m1 = new Del&lt;int&gt;(Notify);
//Del&lt;int&gt; m2 = Notify;

//在泛型类中定义的委托可以用类方法使用的相同方式来使用泛型类类型参数
class Stack&lt;T&gt;
{
	T[] items;
	int index;
	public delegate void StackDelegate(T[] items);
}//引用委托的代码必须指定包含类的类型参数
class Instance
{
	private static void DoWork(float[] items){}
public static void TestStatck()
{
Stack&lt;float&gt; s = new Stack&lt;float&gt;();
Stack&lt;float&gt;.StackDelegate d = DoWork;
}
}

//常用事件发布订阅系统
public class PublicSubscribeManager
{
 //定义发布消息体extends EventArgs
 public class MessageBox : System.EventArgs{ public MessageBox(string subject, string content){}}
 //定义代理 parameter(object sender,SubEventArgs message)
 public delegate void PublishEventHandler(object sender, MessageBox message);
 //定义event DelegateType eventVariable;
 public event PublishEventHandler Publish;
 //定义执行函数
 protected virtual void OnPublished(MessageBox message){if (Publish != null)Publish(this,message);}
	public void Trigger(string subject,string content){OnPublished(new MessageBox(subject,content));}
}
class MainClass
{
 static void Main()
 {
  	PublicSubscribeManager manager = new PublicSubscribeManager();
  	manager.Publish += new PublicSubscribeManager.PublishEventHandler((sender,message)=&gt; { Console.WriteLine(&quot;{sender},{message}&quot;);});
  	manager.Trigger(&quot;_subject&quot;, &quot;_content&quot;);
 }
}
</code></pre>
<h4 id="特性解析">特性解析</h4>
<pre><code>Type type = typeof(class);
object[] XXX = type.GetXXX();
for(XX x int XXX)x.reduce();
---------------------------
System.Reflection.MemberInfo info = type.getMember(Type.MemberName);
System.Reflection.MethodInfo info = type.GetMethod(Type.MethodName);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[软件工程架构]]></title>
        <id>https://sunxiaohang.github.io/post/ruan-jian-gong-cheng-jia-gou/</id>
        <link href="https://sunxiaohang.github.io/post/ruan-jian-gong-cheng-jia-gou/">
        </link>
        <updated>2019-09-11T11:46:39.000Z</updated>
        <summary type="html"><![CDATA[<p>软件工程架构的一些想法和思路汇总，旨在从模型阶段建立一个相对完善的软件框架,重在积累软件工程开发相关的开发思路和注意事项。</p>
]]></summary>
        <content type="html"><![CDATA[<p>软件工程架构的一些想法和思路汇总，旨在从模型阶段建立一个相对完善的软件框架,重在积累软件工程开发相关的开发思路和注意事项。</p>
<!-- more -->
<h4 id="系统架构">系统架构</h4>
<p>系统架构衡量标准<br>
• 承载力<br>
• 可扩展度<br>
• 易用性<br>
• 可伸缩性<br>
• 容灾力</p>
<h4 id="分层思维">分层思维</h4>
<p>面对复杂的系统，往往需要把各个模块按照一定的规则进行分类分层，模块间各司其职协同工作,把复杂的问题简单化，<img src="https://sunxiaohang.github.io/post-images/1586173649489.png" alt="" loading="lazy"></p>
<h4 id="分治思维divide-and-conquer">分治思维(Divide and conquer)</h4>
<figure data-type="image" tabindex="1"><img src="https://sunxiaohang.github.io/post-images/1586173679513.png" alt="" loading="lazy"></figure>
<h4 id="演化思维">演化思维</h4>
<figure data-type="image" tabindex="2"><img src="https://sunxiaohang.github.io/post-images/1586173718360.png" alt="" loading="lazy"></figure>
<h4 id="数据表">数据表</h4>
<p>• Excel<br>
• 代码数据<br>
• txt<br>
• 比特流数据</p>
<h4 id="性能规范">性能规范</h4>
<h4 id="美术资源规范">美术资源规范</h4>
<p>• 根据运用场景<br>
• 反推计算<br>
• 实际测试</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring]]></title>
        <id>https://sunxiaohang.github.io/post/spring/</id>
        <link href="https://sunxiaohang.github.io/post/spring/">
        </link>
        <updated>2019-02-28T11:23:21.000Z</updated>
        <summary type="html"><![CDATA[<p>主要是一些读书笔记，总结java web项目常用框架的一些实现细节和基础理论。目前快速迭代开发过程完全可以依赖更新的快速框架代替，如SSM+thymeleaf+layui等</p>
]]></summary>
        <content type="html"><![CDATA[<p>主要是一些读书笔记，总结java web项目常用框架的一些实现细节和基础理论。目前快速迭代开发过程完全可以依赖更新的快速框架代替，如SSM+thymeleaf+layui等</p>
<!-- more -->
<h4 id="jsp">JSP</h4>
<h5 id="jsp内置对象">JSP内置对象</h5>
<table>
<thead>
<tr>
<th>JSP内置对象</th>
<th>对象描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Out</td>
<td>向客户端对象输出数据</td>
</tr>
<tr>
<td>Request</td>
<td>向服务器提交数据</td>
</tr>
<tr>
<td>Response</td>
<td>服务器项目信息</td>
</tr>
<tr>
<td>Exception</td>
<td>异常信息</td>
</tr>
<tr>
<td>Config</td>
<td>配置信息</td>
</tr>
<tr>
<td>Page</td>
<td>指向当前page本身</td>
</tr>
<tr>
<td>Session</td>
<td>保存会话信息（统一用户的不同对象之间共享信息）</td>
</tr>
<tr>
<td>Application</td>
<td>上下文（不同用户间共享信息）</td>
</tr>
<tr>
<td>PageContext</td>
<td>队jsp页面所有对象及命名空间的访问</td>
</tr>
</tbody>
</table>
<h5 id="out对象">out对象</h5>
<p><code>out.flush()</code><br>
<code>out.clearBuffer</code><br>
<code>out.clear</code></p>
<pre><code>out.print(&quot;获取当前缓冲区大小：&quot;+out.getBufferSize());
out.print(&quot;当前缓冲区剩余字节数目&quot;+out.getRemaining());
</code></pre>
<h5 id="request对象">Request对象</h5>
<table>
<thead>
<tr>
<th>Request对象</th>
<th>对象描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="简单语法格式整理">简单语法格式整理</h5>
<pre><code>&lt;jsp:forward page=&quot;login.jsp&quot;&gt;
    &lt;jsp:param value=&quot;jikexueyuan&quot; name=&quot;username&quot;/&gt;
    &lt;jsp:param value=&quot;sunxiaohang&quot; name=&quot;password&quot;/&gt;
&lt;/jsp:forward&gt;
&lt;%@page errorPage=&quot;error_page.jsp&quot; isErrorPage=&quot;true&quot; %&gt;


  String username=request.getParameter(&quot;username&quot;);
    String password=request.getParameter(&quot;password&quot;);
    out.println(&quot;username &quot;+username);
    out.println(&quot;&lt;br/&gt;&quot;);
    out.println(&quot;password &quot;+password);

&lt;jsp:include page=&quot;body.jsp&quot;&gt;
    &lt;jsp:param name=&quot;bgcolor&quot; value=&quot;red&quot;/&gt;
&lt;/jsp:include&gt;

&lt;body bgcolor=&quot;&lt;%=request.getParameter(&quot;bgcolor&quot;)%&gt;&quot;&gt;
&lt;/body&gt;

&lt;jsp:useBean id=&quot;person&quot; class=&quot;Person&quot;&gt;&lt;/jsp:useBean&gt;
&lt;jsp:setProperty property=&quot;name&quot; name=&quot;person&quot;/&gt;
&lt;jsp:setProperty property=&quot;sex&quot; name=&quot;person&quot;/&gt;

&lt;jsp:getProperty property=&quot;name&quot; name=&quot;person&quot;/&gt;
&lt;jsp:getProperty property=&quot;sex&quot; name=&quot;person&quot;/&gt;
需要添加statdard.jar jstl.jar包
</code></pre>
<h5 id="spring内置对象">Spring内置对象</h5>
<pre><code>  response.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);//无缓存
    response.setIntHeader(&quot;refresh&quot;,2);//设置两秒钟自动刷新
    out.print(&quot;this date is :&quot;+new java.util.Date().toString()+&quot;&lt;br&gt;&quot;);
    response.sendRedirect(&quot;https://www.baidu.com&quot;);//重定向页面
    Cookie cookie=new Cookie(&quot;username&quot;,&quot;password&quot;);
    cookie.setMaxAge(3600);
    response.addCookie(cookie);
    session.getId();
</code></pre>
<h5 id="面向方面的程序设计aop">面向<code>方面</code>的程序设计（AOP）</h5>
<p>Spring框架的一个关键组件是面向方面的程序设计（AOP）框架。一个程序中跨越多个点的功能被称为<code>横切关注点</code>，其在概念上独立于应用程序的业务逻辑（sample：日志记录、声明性事务）</p>
<p><code>OOP</code>中模块化的关键单元是类，<code>AOP</code>中模块化的关键单元室方面。<code>AOP</code>帮助你将横切关注点从他们所影响的对象中分离出来，<code>依赖注入</code>帮助你将你的应用程序对象从彼此中分离出来。</p>
<ul>
<li>
<p><code>控制反转IOC</code><br>
在编写一个复杂的java程序时应用程序类应当尽可能的独立于其他的java类来增加这些类的可重用性，当进行单元测试时，可以使他们独立于其他类进行测试。</p>
</li>
<li>
<p><code>依赖注入DI</code><br>
依赖注入可以以向构造函数传递参数的方式发生，或者通过使用setter方法post-construction。</p>
</li>
</ul>
<h5 id="spring体系结构">Spring体系结构</h5>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/2480310-1638858c768bd15f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Spring体系框架图" loading="lazy"></figure>
<h5 id="核心容器">核心容器</h5>
<p>核心容器由核心、bean、上下文的表达式语言模块组成</p>
<ul>
<li><code>核心</code>提供框架的基本组成部分、包括IOC和依赖注入功能。</li>
<li><code>Bean</code>提供BeanFactory，工厂模式的复杂实现。</li>
<li><code>上下文</code>建立在由core和bean提供的坚实基础上，他是访问定义和配置的任何对象的媒介。ApplicationContext接口是上下文模块的重点。</li>
<li><code>表达式语言</code>模块在运行时提供了查询和操作一个对象图的强大的表达式语言</li>
</ul>
<h5 id="数据集成-访问">数据集成、访问</h5>
<ul>
<li><code>JDBC</code>提供删除冗余的JDBC相关编码的JDBC抽象层</li>
<li><code>ORC</code>为流行的对象关系映射API，包括JPA、JDO、Hibernate和iBatis提供集成层</li>
<li><code>OXM</code>提供抽象层、它支持对JAXB、Castor、XMLBeans，JiBx和XStream的对象/XML映射实现</li>
<li><code>JMS</code>java消息服务包含生产和消费的信息的功能</li>
<li><code>事务</code>事务模块为实现特殊接口的类及所有的POJO支持编程式和声明式事务管理</li>
</ul>
<h5 id="web">Web</h5>
<ul>
<li><code>Web</code>提供基本的面向web的集成功能，例如多个文件上传的功能和使用servlet监听器和面向web应用程序的上下文来初始化IOC容器</li>
<li><code>Web-MVC</code>包含Spring的模型-视图-控制（MVC），实现了web应用程序</li>
<li><code>Web-Socket</code>为<code>WebSocket-Based</code>提供支持，而且在web应用程序中提供客户端和服务器端之间的通信的两种方式。</li>
<li><code>Web-Portlet</code>提供在portlet环境中实现MVC，并且反映了Web-Servlet模块的功能。</li>
</ul>
<h5 id="spring实例">Spring实例</h5>
<ul>
<li>1.生成工厂对象，加载完指定路径下bean配置文件，利用框架提供的<code>FileSystemXmlApplicationContext</code> API生成工厂bean<code>FileSystemXmlApplicationContext</code>负责生成和初始化所有对象，比如：所有XML bean配置文件中的bean</li>
<li>利用第一步生成的上下文中的<code>getBean()</code>方法得到所需要的bean，这个方法通过配置中的<code>beanID</code>来返回一个真正的对象，一旦得到这个对象就可以利用这个对象条用任何方法。</li>
</ul>
<pre><code> ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;/configure/beansConfigure.xml&quot;);
        HelloWord helloWord= (HelloWord) applicationContext.getBean(&quot;helloWord&quot;);
        helloWord.getMessage();
</code></pre>
<h5 id="bean-property">bean property</h5>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>强制属性，制定用来创建bean的bean类</td>
</tr>
<tr>
<td>name/id</td>
<td>指定唯一的bean的标识符</td>
</tr>
<tr>
<td>scope</td>
<td>指定由特定bean定义创建的对象的作用域</td>
</tr>
<tr>
<td>constructor-arg</td>
<td>用来注入依赖关系</td>
</tr>
<tr>
<td>properties</td>
<td>用来注入依赖关系</td>
</tr>
<tr>
<td>autowiring mode</td>
<td>用来注入依赖关系</td>
</tr>
<tr>
<td>lazy-initialization mode</td>
<td>第一次调用时创建对象（懒汉模式）</td>
</tr>
<tr>
<td>initialization</td>
<td>在bean的所有必须属性被容器设置之后，调用回调方法</td>
</tr>
<tr>
<td>destruction</td>
<td>当包含该bean的容器被销毁是，使用回调方法</td>
</tr>
</tbody>
</table>
<h5 id="spring配置元数据">Spring配置元数据</h5>
<p><code>Spring IoC</code>容器完全由实际编写的配置元数据的格式解耦</p>
<ul>
<li>基于XML的配置文件</li>
<li>基于注解的配置</li>
<li>基于java的配置</li>
</ul>
<h5 id="spring-bean的作用域">Spring Bean的作用域</h5>
<p>在Spring定义一个bean时，必须声明该bean的作用域.</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>singleTon</code></td>
<td>单例模式</td>
</tr>
<tr>
<td><code>prototype</code></td>
<td>普通模式，每次调用创建一个新的对象</td>
</tr>
<tr>
<td><code>request</code></td>
<td>作用域定义为HTTP请求，只在web-aware spring ApplicationContext的上下文中有效</td>
</tr>
<tr>
<td><code>session</code></td>
<td>作用域定义限制为HTTP会话，只在web-aware spring ApplicationContext的上下文中有效</td>
</tr>
<tr>
<td><code>global-session</code></td>
<td>作用域将bean的定义限制为全局HTTP绘画，只在web-aware spring ApplicationContext的上下文中有效</td>
</tr>
</tbody>
</table>
<p>作用域设置实例</p>
<pre><code> &lt;bean id=&quot;singleTon&quot; class=&quot;com.example.SingleTon&quot; 
      scope=&quot;singleton&quot;&gt;
</code></pre>
<h5 id="spring-bean的生命周期">Spring bean的生命周期</h5>
<p>声明带有 <code>init-method</code>和 <code>destroy-method</code> 参数的 。</p>
<ul>
<li><code>init-method</code> 属性指定一个方法，在实例化 bean 时调用该方法。</li>
<li><code>destroy-method</code> 指定一个方法，只有从容器中移除 bean 后，才能调用该方法。</li>
</ul>
<p>在<code>org.springframework.beans.factory.InitializingBean</code> 接口指定一个单一的方法：</p>
<pre><code>void afterPropertiesSet() throws Exception;
</code></pre>
<p>我们只需要在实现<code>InitializingBean</code>接口就可以在对象创建后做一些事情</p>
<pre><code>public class TestBean implements InitializingBean {
   public void afterPropertiesSet() throws Exception{
      // do some initialization work
   }
}
</code></pre>
<p>同样的在<code>org.springframework.beans.factory.DisposableBean</code> 接口指定一个单一的方法：</p>
<pre><code>void destroy() throws Exception;
</code></pre>
<p>然后在类对象中实现<code>DisposableBean</code>接口</p>
<pre><code>public class TestBean implements DisposableBean{
    @Override
    public void destroy() throws Exception {
        // do some initialization work
    }
}
</code></pre>
<p>除此之外，在基于XML元数据配置的境况下还可以通过设置<code>destroy-method</code>属性实现</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot;
         class=&quot;examples.ExampleBean&quot; destroy-method=&quot;destroy&quot;/&gt;
</code></pre>
<p>在类里面我们可以这样定义</p>
<pre><code>public class TestBean {
   public void destroy() {
      // do some destruction work
   }
}
</code></pre>
<h5 id="beanpostprocessor">BeanPostProcessor</h5>
<p>有时候会需要在bean实例化对象前后去做一些准备工作或预处理，可以在创建bean类时实现<code>BeanPostProcessor</code>接口去完成自定义工作。<br>
该接口定义了<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>两个带参函数，示例代码如下</p>
<pre><code>public class TestBean implements BeanPostProcessor {
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      System.out.println(&quot;BeforeInitialization : &quot; + beanName);
      return bean;  // you can return any other object as well
   }
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      System.out.println(&quot;AfterInitialization : &quot; + beanName);
      return bean;  // you can return any other object as well
   }
}
</code></pre>
<p><code>注意</code>：在main方法中需要注册一个在 AbstractApplicationContext 类中声明的关闭 hook 的 registerShutdownHook() 方法。它将确保正常关闭，并且调用相关的 destroy 方法。</p>
<pre><code>context.registerShutdownHook();
</code></pre>
<h4 id="java的反射机制">Java的反射机制</h4>
<p><code>写在Spring Ioc之前</code><br>
类装载器就是寻找类的字节码文件并构造出类在JVM内部表示的对象组件，主要工作由ClassLoader及其子类负责，ClassLoader是一个重要的java运行时系统组件，他负责在运行时查找和装入Class字节码文件</p>
<pre><code>public class ReflectCar {
    public static Car initCarByDefaultConst() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        ClassLoader loader=Thread.currentThread().getContextClassLoader();
        Class clazz=loader.loadClass(&quot;com.beijinghuayi.ioc.Car&quot;);
        //获取类默认实例化对象
        Constructor constructor=clazz.getDeclaredConstructor((Class[])null);
        Car car= (Car) constructor.newInstance();

        Method setBrand=clazz.getMethod(&quot;setBrand&quot;,String.class);
        setBrand.invoke(car,&quot;奔驰&quot;);
        Method setColor=clazz.getMethod(&quot;setColor&quot;,String.class);
        setColor.invoke(car,&quot;红色&quot;);
        Method setMaxspeed=clazz.getMethod(&quot;setMaxspeed&quot;,String.class);
        setMaxspeed.invoke(car,&quot;200码&quot;);
        return car;
    }
    public static Car initCarByParams() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        ClassLoader loader=Thread.currentThread().getContextClassLoader();
        Class clazz=loader.loadClass(&quot;com.beijinghuayi.ioc.Car&quot;);
        Constructor constructor=clazz.getDeclaredConstructor(new Class[]{String.class,String.class,String.class});
        Car car= (Car) constructor.newInstance(new Object[]{&quot;红色&quot;,&quot;宝马&quot;,&quot;180&quot;});
        return car;
    }
}
</code></pre>
<p><code>工作机制：</code></p>
<ul>
<li>1.装载：查找和导入Class文件</li>
<li>2.链接：执行校验，准备和解析步骤</li>
<li>3.初始化：对类的静态变量、静态代码块执行初始化操作</li>
</ul>
<p><code>Tip:</code>JVM在运行时会产生3个<code>classLoader</code></p>
<ul>
<li>根装载器（C++实现、不是classloader的子类）装载jre核心类库</li>
<li>ExtClassLoader（扩展类装载器）装载jre扩展目录ext中的jar类</li>
<li>AppClassLoader（系统类装载器）装载classpath中的内容</li>
</ul>
<p><code>ClassLoader</code>重要方法</p>
<ul>
<li>Class loadClass(String name);从文件中装在类</li>
<li>Class defineClass(String name,byte[]b,int off,int len)</li>
<li>Class findSystemClass(String name)</li>
<li>Class findLoadedClass(String name)</li>
<li>ClassLoader getParent()</li>
</ul>
<p>Class反射对象描述类语义结构，可以从Class对象中获得构造函数，成员变量，方法等元素的反射对象，并以编程的方法通过这些反射对象对目标类对象进行操作。这些反射对象类在java.reflect包中定义，下面是最主要的三个反射类</p>
<ul>
<li>1.Constructor类对象的反射类（通过getConstructor方法可以获得类的所有构造函数反射对象数组）NewInstance。</li>
<li>2.Method类方法的反射类invoke() getReturnType(),getParameterTypes();</li>
<li>3.Field 获取类的成员变量反射类（ 获取成员变量反射数组）<br>
<code>Tip</code>访问private，protect成员变量或方法时需添加<code>Field.setAccessible(true)</code>，<code>Method.setAccessible(true)</code>方法取消java语言检查，否则将会抛出<code>IllegalAccessException</code>异常.</li>
</ul>
<pre><code> ClassLoader loader=Thread.currentThread().getContextClassLoader();
        System.out.println(&quot;classLoader:&quot;+loader);
        System.out.println(&quot;parent classLoader:&quot;+loader.getParent());
        System.out.println(&quot;grandParent classLoader:&quot;+loader.getParent().getParent());
</code></pre>
<h5 id="引出spring-ioc">引出Spring Ioc</h5>
<p>在Spring中，通过IOC可以将实现类、参数信息等配置在对应的配置文件中，那么当需要更改实现类或参数信息时，只需要修改配置文件即可，我们还可以对某对象所需要的其他对象进行注入，这种注入都是在配置文件中实现。</p>
<h5 id="spring-bean的简单实现">Spring Bean的简单实现</h5>
<pre><code>public class BeanFactory {
    private Map&lt;String,Object&gt; beanmap=new HashMap&lt;&gt;();
    public void init(String xml) throws DocumentException, ClassNotFoundException, IntrospectionException, IllegalAccessException, InstantiationException, InvocationTargetException {
        //1.创建读取配置文件的reader对象
        SAXReader reader=new SAXReader();
        //2.获取当前线程的类加载器
        ClassLoader loader=Thread.currentThread().getContextClassLoader();
        //3.从class目录下获取指定的xml文件
        InputStream ins=loader.getResourceAsStream(xml);
        Document doc=reader.read(ins);
        Element root=doc.getRootElement();
        Element foo;

        //4.遍历xml文件中的Bean实例
        for(Iterator i=root.elementIterator(&quot;bean&quot;);i.hasNext();){
            foo= (Element) i.next();
            //5.针对每一个bean实例，获取bean的属性id和class
            Attribute id=foo.attribute(&quot;id&quot;);
            Attribute cls=foo.attribute(&quot;class&quot;);

            //6.利用Java反射机制，通过class的名称获取Class对象
            Class bean=Class.forName(cls.getText());
            //7.获取丢应class信息
            java.beans.BeanInfo info =java.beans.Introspector.getBeanInfo(bean);
            //8.获取其属性描述
            java.beans.PropertyDescriptor pd[]=info.getPropertyDescriptors();
            //9.创建一个对象，并在接下来的代码中为对象的属性赋值
            Object obj=bean.newInstance();
            //10.遍历该bean的property属性
            for(Iterator ite=foo.elementIterator(&quot;property&quot;);ite.hasNext();){
                Element foo2= (Element) ite.next();
                //11.获取该property的name属性
                Attribute name=foo2.attribute(&quot;name&quot;);
                String value=null;
                //12.获取该property的子元素的值
                for (Iterator ite1 = foo2.elementIterator(&quot;value&quot;); ite1.hasNext();)
                {
                    Element node = (Element) ite1.next();
                    value = node.getText();
                    break;
                }

                //13.利用Java的反射机制调用对象的某个set方法，并将值设置进去
                for (int k = 0; k &lt; pd.length; k++) {
                    if (pd[k].getName().equalsIgnoreCase(name.getText()))
                    {
                        Method mSet = null;
                        mSet = pd[k].getWriteMethod();
                        mSet.invoke(obj, value);
                    }
                }
            }
            //14.将对象放入beanMap中，其中key为id值，value为对象
            beanmap.put(id.getText(), obj);
        }
    }
    /**
     * 通过bean的id获取bean的对象.
     *
     * @param beanName
     *            bean的id
     * @return 返回对应对象
     */
    public Object getBean(String beanName) {
        Object obj = beanmap.get(beanName);
        return obj;
    }
}
</code></pre>
<p><code>config.xml</code></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans&gt;
    &lt;bean id=&quot;javaBean&quot; class=&quot;JavaBean&quot;&gt;
        &lt;property name=&quot;username&quot;&gt;
            &lt;value&gt;mic_swift&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name=&quot;password&quot;&gt;
            &lt;value&gt;010101010110&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h5 id="spring资源访问工具类">Spring资源访问工具类</h5>
<p>JDK所提供的访问资源类并不能很好的满足各种底层资源的访问需求，因此，Spring设计了一个Resource接口，它为应用提供了更强大的访问底层资源的能力：<br>
<code>主要方法：</code></p>
<ul>
<li>boolean exists()</li>
<li>boolean isOpen()</li>
<li>URL getURL();</li>
<li>File getFile();</li>
<li>inputStream getInputStream();</li>
</ul>
<p><code>具体实现类</code></p>
<ul>
<li>ByteArrayResource</li>
<li>ClassPathResource</li>
<li>FileSystemResource</li>
<li>InputStreamResource</li>
<li>ServletContextResource</li>
<li>UrlResource</li>
</ul>
<p>为了访问不同类型的资源，必须使用相应的Resource实现类，Spring提供了一个强大的加载资源的机制，能够自动识别不同的资源类型。<br>
<code>资源类型地址前缀</code></p>
<ul>
<li>classpath classpath:com/example/config.xml</li>
<li>File file:/com/example/config.xml</li>
<li>Http http://www.baidu.com</li>
<li>Ftp ftp://www.baidu.com</li>
<li>无前缀 com/example/config.xml<br>
######BeanFactory和ApplicationContext<br>
BeanFactory时Spring框架的最核心接口，它提供高级的Ioc配置机制，AppliactionContext建立在BeanFactory基础上，提供了更多面向应用的功能，它提供了国际化支持和框架事件体系，更易于创建实际应用一般成BeanFactory为Ioc容器，而称ApplicationContext为应用上下文</li>
</ul>
<p>BeanFactory是一个类工厂，可以常见并管理各种类的对象，Spring称这些创建和管理的java对象为bean，在Spring中，java对象的范围更加宽泛，接下来我们对BeanFactory的类体系结构以及装载初始化顺序进行说明：</p>
<h5 id="类体系结构">类体系结构</h5>
<ul>
<li>XmlBeanFactory</li>
<li>ListableBeanFactory</li>
<li>HierarhicalBeanFactory</li>
<li>ConfigurableBeanFactory</li>
<li>AutowireCapableBeanFactory</li>
<li>SingletonBeanFactory</li>
<li>BeanDefinitionRegistry</li>
</ul>
<h5 id="初始化顺序">初始化顺序</h5>
<ul>
<li>创建配置文件</li>
<li>装载配置文件</li>
<li>启动Ioc容器</li>
<li>获取Bean实例</li>
</ul>
<p>ApplicationContext由BeanFactory派生而来，提供了更多面向实际的功能。在BeanFactory中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置的方式实现，接下来介绍一下ApplicationContext的实现类以及类体系结构：</p>
<p><code>具体实现类</code></p>
<ul>
<li>ClassPathXmlApplicationContext</li>
<li>FileSystemXmlApplicationContext</li>
<li>ConfigurableApplicationContext<br>
<code>类继承体系</code>(扩展接口)</li>
<li>ApplicationEventPublisher</li>
<li>MessageSource</li>
<li>ResourcePatternResolver</li>
<li>LifeCycle(用于处理异步)</li>
</ul>
<p>Spring容器中的Bean拥有明确的生命周期，由多个特定的生命阶段组成，每个生命阶段都允许外界对Bean进行控制，在Spring中，我们从Bean的作用范围和实例化Bean时所经历的一系列阶段来描述Bean的生命周期</p>
<ul>
<li>BeanFactory中的Bean的生命周期</li>
<li>ApplicationContext中的Bean的生命周期</li>
</ul>
<h5 id="spring容器启动基本条件">Spring容器启动基本条件</h5>
<ul>
<li>Spring框架类包</li>
<li>Bean配置信息</li>
<li>Bean类满足</li>
</ul>
<h5 id="bean的元数据信息">Bean的元数据信息</h5>
<ul>
<li>Bean的实现类</li>
<li>Bean的属性信息</li>
<li>Bean的依赖关系</li>
<li>Bean的行为配置</li>
<li>Bean的创建方式</li>
</ul>
<p>使用静态工厂的方式除了指定必须的class属性，还要指定factory-method属性来指定实例化Bean的方法，而且使用静态工厂方法也允许指定方法参数，SpringIoc容器将调用此属性的方法来获取Bean。</p>
<p>使用实例工厂方法不能指定clas属性，此时必须使用factory-bean来指定工厂Bean，factory-method属性指定实例化Bean的方法，而且使用实例工厂方法允许指定方法参数，方式和使用构造器方式一样</p>
<pre><code>&lt;bean id=&quot;beanInstanceFactory&quot; class=&quot;com.beijinghuayi.spring.Instance&quot;/&gt;
	&lt;bean id=&quot;helloWorldInstance&quot; factory-bean=&quot;beanInstanceFactory&quot; factory-method=&quot;newInstance&quot;&gt;
		&lt;constructor-arg index=&quot;0&quot; value=&quot;Hello Instance Factory!&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="spring多个配置文件的整合">Spring多个配置文件的整合</h5>
<pre><code>&lt;beans&gt;
    &lt;import resource=&quot;common/Spring-Common.xml&quot;/&gt;
    &lt;import resource=&quot;common/Spring-Connect.xml&quot;/&gt;
    &lt;import resource=&quot;common/Spring-Moudel.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h5 id="spring-bean-定义继承">Spring Bean 定义继承</h5>
<ul>
<li>Bean可以通过设置配置文件来定义继承关系</li>
<li>子 bean 的定义继承父定义的配置数据。子定义可以根据需要重写一些值，或者添加其他值。<code>tip:</code>Spring Bean 定义的继承与 Java 类的继承无关，但是继承的概念是一样的。</li>
<li>当你使用基于 XML 的配置元数据时，通过使用父属性，指定父 bean 作为该属性的值来表明子 bean 的定义。</li>
</ul>
<p>通过XML配置文件实现继承关系实例</p>
<pre><code>&lt;bean id=&quot;person&quot; class=&quot;com.example.Person&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;swift&quot;/&gt;
      &lt;property name=&quot;details&quot; value=&quot;animal can speak&quot;/&gt;
   &lt;/bean&gt;

   &lt;bean id=&quot;student&quot; class=&quot;com.example.Student&quot; parent=&quot;person&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;study&quot;/&gt;
      &lt;property name=&quot;details&quot; value=&quot;good good study, day day up!&quot;/&gt;
   &lt;/bean&gt;
</code></pre>
<p><code>tip：</code>在定义Student类的时候我们不再需要继承Person类</p>
<h5 id="bean-定义模板">Bean 定义模板</h5>
<pre><code>&lt;bean id=&quot;person&quot; abstract=&quot;true&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;swift&quot;/&gt;
      &lt;property name=&quot;details&quot; value=&quot;animal can speak&quot;/&gt;
   &lt;/bean&gt;

   &lt;bean id=&quot;student&quot; class=&quot;com.example.Student&quot; parent=&quot;person&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;study&quot;/&gt;
      &lt;property name=&quot;details&quot; value=&quot;good good study, day day up!&quot;/&gt;
   &lt;/bean&gt;
</code></pre>
<p>person 自身不能被实例化，因为它是不完整的(没有指定class属性)，而且它也被明确地标记为抽象的。当一个定义是抽象的，它仅仅作为一个纯粹的模板 bean 定义来使用的，充当子定义的父定义使用。</p>
<h5 id="spring-依赖注入">Spring 依赖注入</h5>
<p>当编写一个复杂的 Java 应用程序时，应用程序的 java 有多个对象，应用程序类应该尽可能独立于其他 Java 类来增加这些类重用的可能性，依赖注入DI<br>
（或有时称为布线）有助于把这些类粘合在一起，同时保持他们<code>独立</code>。</p>
<ul>
<li>构造函数注入</li>
</ul>
<pre><code>public class Person{
   private Speak speak;
   public Person(Speak speak) {
      this.speak= speak;
   }
}
</code></pre>
<p>依赖关系通过<code>类构造函数</code>被注入到 Person类中。</p>
<ul>
<li>setter方法注入</li>
</ul>
<pre><code>public class Person{
   private Speak speak;
   public void setSpeak(Speak speak){
	   this.speak=speak;
   }
}
</code></pre>
<p>依赖关系通过<code>类构造函数</code>被注入到 Person类中。控制流通过依赖注入（DI）已经“反转”，因为你已经有效地委托依赖关系到一些外部系统。</p>
<ul>
<li>XML配置文件注入</li>
</ul>
<pre><code> &lt;bean id=&quot;person&quot; class=&quot;com.example.Person&quot;&gt;
      &lt;constructor-arg ref=&quot;speak&quot;/&gt;
&lt;/bean&gt;
&lt;!-- Definition for speak bean --&gt;
&lt;bean id=&quot;speak&quot; class=&quot;com.example.Speak&quot;&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="spring-基于设值函数的依赖注入">Spring 基于设值函数的依赖注入</h5>
<p>当容器调用一个无参的构造函数或一个无参的静态 factory 方法来初始化你的 bean 后，通过容器在你的 bean 上调用设值函数，基于设值函数的 DI 就完成了。</p>
<pre><code> &lt;bean id=&quot;person&quot; class=&quot;com.example.Person&quot;&gt;
      &lt;property name=&quot;speak&quot; ref=&quot;speak&quot;&gt;
&lt;/bean&gt;
&lt;!-- Definition for speak bean --&gt;
&lt;bean id=&quot;speak&quot; class=&quot;com.example.Speak&quot;&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>
<p><code>Tip：</code>此方法和构造函数注入唯一的区别就是在基于构造函数注入中，我们使用的是标签中的元素，而在基于设值函数的注入中，我们使用的是标签。</p>
</li>
<li>
<p><code>tip：</code>如果你要把一个引用传递给一个对象，那么你需要使用 标签的 ref 属性，而如果你要直接传递一个值，那么你应该使用 value 属性。</p>
</li>
</ul>
<h5 id="p-namespace"><code>p-namespace</code></h5>
<pre><code>&lt;bean id=&quot;test&quot; class=&quot;com.example.Person&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;swift&quot;/&gt;
      &lt;property name=&quot;method&quot; ref=&quot;speak&quot;/&gt;
&lt;/bean&gt;
//可以通过如下方式简化表示
&lt;bean id=&quot;test&quot; class=&quot;com.example.Person&quot;
      p:name=&quot;swift&quot;
      p:method=&quot;speak&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="注入内部bean">注入内部bean</h5>
<p>inner bean是在bean类中添加的内部类（java内部类）</p>
<pre><code>&lt;bean id=&quot;person&quot; class=&quot;com.sunxiaohang.Person&quot;&gt;
        &lt;property name=&quot;speak&quot;&gt;
            &lt;bean id=&quot;speak&quot; class=&quot;com.sunxiaohang.Speak&quot;&gt;&lt;/bean&gt;
        &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>tip:<code>&lt;!--property需要提供set方法才能使用--&gt;</code></p>
<h5 id="spring注入集合">Spring注入集合</h5>
<p>Spring提供了四种集合类</p>
<table>
<thead>
<tr>
<th>Spring集合类</th>
</tr>
</thead>
<tbody>
<tr>
<td>Map</td>
</tr>
<tr>
<td>Properties</td>
</tr>
<tr>
<td>Set</td>
</tr>
<tr>
<td>List</td>
</tr>
</tbody>
</table>
<p>以下是<code>Collections</code>类和<code>springbean.xml</code>的配置代码</p>
<pre><code>package com.sunxiaohang;

import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

public class Collections {
    private Set collectionSet;
    private Map collectionMap;
    private Properties collectionProperties;
    private List collectionList;

    public Collections() {
    }

    public Set getCollectionSet() {
        System.out.println(&quot;Set Element:&quot;+collectionSet);
        return collectionSet;
    }

    public void setCollectionSet(Set collectionSet) {
        this.collectionSet = collectionSet;
    }

    public Map getCollectionMap() {
        System.out.println(&quot;Map Element:&quot;+collectionMap);
        return collectionMap;
    }

    public void setCollectionMap(Map collectionMap) {
        this.collectionMap = collectionMap;
    }

    public Properties getCollectionProperties() {
        System.out.println(&quot;Properties Element:&quot;+collectionProperties);
        return collectionProperties;
    }

    public void setCollectionProperties(Properties collectionProperties) {
        this.collectionProperties = collectionProperties;
    }

    public List getCollectionList() {
        System.out.println(&quot;list Element:&quot;+collectionList);
        return collectionList;
    }

    public void setCollectionList(List collectionList) {
        this.collectionList = collectionList;
    }
}

</code></pre>
<pre><code>&lt;bean id=&quot;collections&quot; class=&quot;com.sunxiaohang.Collections&quot;&gt;
    &lt;property name=&quot;collectionList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;张三&lt;/value&gt;
            &lt;value&gt;李四&lt;/value&gt;
            &lt;value&gt;王五&lt;/value&gt;
            &lt;value&gt;马六&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;collectionSet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;北京&lt;/value&gt;
            &lt;value&gt;天津&lt;/value&gt;
            &lt;value&gt;上海&lt;/value&gt;
            &lt;value&gt;广州&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
    &lt;property name=&quot;collectionMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;1&quot; value=&quot;one&quot;/&gt;
            &lt;entry key=&quot;2&quot; value=&quot;two&quot;/&gt;
            &lt;entry key=&quot;3&quot; value=&quot;three&quot;/&gt;
            &lt;entry key=&quot;4&quot; value=&quot;four&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name=&quot;collectionProperties&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;1&quot;&gt;姓名&lt;/prop&gt;
            &lt;prop key=&quot;2&quot;&gt;性别&lt;/prop&gt;
            &lt;prop key=&quot;3&quot;&gt;年龄&lt;/prop&gt;
            &lt;prop key=&quot;4&quot;&gt;出生日期&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法]]></title>
        <id>https://sunxiaohang.github.io/post/suan-fa/</id>
        <link href="https://sunxiaohang.github.io/post/suan-fa/">
        </link>
        <updated>2018-12-20T03:37:58.000Z</updated>
        <summary type="html"><![CDATA[<p>算法包括，基础查找和排序算法，深度广度优先遍历，迷宫求解算法，优先队列，分支限界，动态规划和诸如N皇后等算法应用，重点关注基础算法，和诸如动态规划的一般算法思想，递归和非递归算法实现的优缺点，参考算法导论</p>
]]></summary>
        <content type="html"><![CDATA[<p>算法包括，基础查找和排序算法，深度广度优先遍历，迷宫求解算法，优先队列，分支限界，动态规划和诸如N皇后等算法应用，重点关注基础算法，和诸如动态规划的一般算法思想，递归和非递归算法实现的优缺点，参考算法导论</p>
<!-- more -->
<h4 id="共享数组原地逆置">共享数组原地逆置</h4>
<pre><code>public class Main {
    public static char array[]={'A','B','C','D','E','F','G','H','1','2','3','4'};
    public static void main(String[] args) {
        reverse(0,7);//逆置字母序列结果为：HGFEDCBA1234
        reverse(8,11);//逆置数字序列结果为：HGFEDCBA4321
        reverse(0,11);//整体逆置结果为：1234ABCDEFG
        print(array);
    }
    public static void reverse(int start,int end){//逆置函数
        char temp;
        while(start&lt;end) {
            temp = array[start];
            array[start++] = array[end];
            array[end--] = temp;
        }
    }
    private static void print(char[] array) {
        for (int i = 0; i &lt;array.length; i++)
            System.out.print(array[i]);
        System.out.println();
    }
}
</code></pre>
<h4 id="n-皇后问题">N 皇后问题</h4>
<pre><code>/**
 * n queens problem
 *
 * */
public class EightQueen {
    private int QUEEN_COUNT = 0;//represent the queen count
    private int[][] queenCount;//chess box matrix
    private int resultCount = 0;//solution number
    private int[] queenPlace;//mark the queen placed position
    /**
     * construct a EightQueen with a argument represent the number of queen
     * initial a empty chess box
     * 0 represent empty
     * 1 represent the area has been taken
     * recurse to call the putQueen method
     * the queenPlace array to mark the queen's taken area which uses to print
     *
     * */
    public EightQueen(int n) {
        this.QUEEN_COUNT = n;
        this.resultCount = 0;
        this.queenCount = new int[QUEEN_COUNT][QUEEN_COUNT];
        queenPlace = new int[QUEEN_COUNT];
        putQueen(0);
    }
    /**
     * implement the putQueen function to recursion
     * use column index in outer loop and row index in inner loop with step increase
     * */
    private void putQueen(int row) {
        for (int column = 0; column &lt; QUEEN_COUNT; column++) {//loop for QUEEN_COUNT times
            if (queenCount[row][column] == 0) {//judge the condition
                /**
                 * each row has one queen
                 * mark the column and diagonal back diagonal(row has been scatter)
                 *
                 * */
                for (int nextRow = row + 1; nextRow &lt; QUEEN_COUNT; nextRow++) {
                    queenCount[nextRow][column]++;
                    if (column - nextRow + row &gt;= 0) {
                        queenCount[nextRow][column - nextRow + row]++;
                    }
                    if (column + nextRow - row &lt; QUEEN_COUNT) {
                        queenCount[nextRow][column + nextRow - row]++;
                    }
                }
                queenPlace[row] = column;//place the queen with only column information
                if (row == QUEEN_COUNT - 1) printQueen(++resultCount);//recursion has completed
                else putQueen(row + 1);//recurse to call the putQueen function
                /**
                 *
                 * unmarked the column and diagonal back diagonal(row has been scatter)
                 *
                 * */
                for (int rows = row + 1; rows &lt; QUEEN_COUNT; rows++) {
                    queenCount[rows][column]--;
                    if (column - rows + row &gt;= 0) {
                        queenCount[rows][column - rows + row]--;
                    }
                    if (column + rows - row &lt; QUEEN_COUNT) {
                        queenCount[rows][column + rows - row]--;
                    }
                }
            }
        }
        if (row == 0) System.out.println(QUEEN_COUNT + &quot; queens has totally &quot; + resultCount + &quot;result.&quot;);
    }

    private void printQueen(int size)
    {
        System.out.println(&quot;********** &quot;+size+&quot; **********\n&quot;);
        for (int i = 0; i &lt; QUEEN_COUNT; i++) {
            for (int j = 0; j &lt; QUEEN_COUNT; j++) {
                System.out.print(queenPlace[i] == j ? &quot; # &quot; : &quot; - &quot;);
            }
            System.out.println();
        }
    }
}

</code></pre>
<h4 id="最大子序和问题">最大子序和问题</h4>
<pre><code>int MaxSubSeqSum(int arrays[], int left, int right) {
    int sum = 0;
    if (left == right) {
        if (arrays[left] &gt; 0)return arrays[left];
        else sum = 0;
    } else {
        int middle = (left + right) / 2;
        int leftSum = MaxSubSeqSum(arrays, left, middle);
        int rightSum = MaxSubSeqSum(arrays, middle + 1, right);
        int finalLeftSum = 0, thisLeftSum = 0;
        for (int i = left; i &lt;=middle; i++) {
            thisLeftSum += arrays[i];
            if (thisLeftSum &gt; finalLeftSum)finalLeftSum = thisLeftSum;
        }
        int finalRightSum = 0, thisRightSum = 0;
        for (int j = middle + 1; j &lt; right; j++) {
            thisRightSum += arrays[j];
            if (thisRightSum &gt; finalRightSum)finalRightSum = thisRightSum;
        }
        sum = finalLeftSum + finalRightSum;
        printf(&quot;left sum is %d,right sum is %d\n&quot;,finalLeftSum,finalRightSum);
        if (sum &lt; leftSum)sum = leftSum;
        if (sum &lt; rightSum)sum = rightSum;
    }
    return sum;
}
</code></pre>
<h4 id="优先队列">优先队列</h4>
<pre><code>/**
 * use maximum-top heap to implement priority queue
 * define a MAX_SIZE_OF_PRIORITY_QUEUE to limit the max length of priority queue
 * use a integer array to store element
 * hypothesis i is the root node and then use 2*i to mark left child and 2*i+1 to mark right child
 * use initialArray[0] to store the length of heap
 * */
public class PriorityQueue{
    private static final int MAX_SIZE_OF_PRIORITY_QUEUE=100;
    private int[] initialArray;
    /**
     * initial priority queue with a exist array which can't be null
     * */
    public PriorityQueue(int[] initialElement) {
        if(initialElement==null)return;
        if(initialElement.length==0)return;
        initialArray=new int[MAX_SIZE_OF_PRIORITY_QUEUE];
        initialArray[0]=initialElement.length;
        for(int i=0;i&lt;initialElement.length;i++)initialArray[i+1]=initialElement[i];
        System.out.println(initialArray[0]);
        for (int i = initialArray[0]; i &gt;0 ; i--)reBuildHeap(i);
    }
    /**
     * rebuild array according to the value of each node
     * maximum-top heap
     * index represents the index of a node which should be rebuild(include it's children node)
     *
     * simple:
     *         1
     *      2     3
     *   4   5  6   7
     *
     * */
    private void reBuildHeap(int index){
        System.out.println(&quot;execute rebuild function to rebuild a maximum-top heap with one loop&quot;);
        int leftChildIndex=index*2;
        int rightChildIndex=leftChildIndex+1;
        int length=initialArray[0];
        int biggerValueIndex=-1;
        if(leftChildIndex&gt;length&amp;&amp;rightChildIndex&gt;length){
            System.out.println(&quot;no left child&quot;);
            return;
        }
        if(leftChildIndex&lt;=length&amp;&amp;rightChildIndex&gt;length){
            System.out.println(&quot;only left child&quot;);
            biggerValueIndex=leftChildIndex;
        }
        if(leftChildIndex&gt;length&amp;&amp;rightChildIndex&lt;=length){
            System.out.println(&quot;only right child&quot;);
            biggerValueIndex=rightChildIndex;
        }
        if(leftChildIndex&lt;=length&amp;&amp;rightChildIndex&lt;=length){
            System.out.println(&quot;both children&quot;);
            biggerValueIndex=initialArray[leftChildIndex]&gt;initialArray[rightChildIndex]?leftChildIndex:rightChildIndex;
        }
        if(initialArray[index]&gt;initialArray[biggerValueIndex]){
            System.out.println(&quot;unnecessary to swap!&quot;);
            return;
        }else{
            int temp=initialArray[index];
            initialArray[index]=initialArray[biggerValueIndex];
            initialArray[biggerValueIndex]=temp;
            this.reBuildHeap(biggerValueIndex);
        }
    }
    public int getLength() {
        return initialArray[0];
    }
    /**
     * get top priority value of heap
     * the first element of array
     * */
    public int priority(){
        return initialArray[1];
    }
    /**
     * length++
     * add element to the tail of array
     * rebuild the heap to regular priority heap
     * */
    public void insert(int element){
        initialArray[0]++;
        initialArray[initialArray[0]]=element;
        for(int i=initialArray[0];i&gt;=1;i=i/2){
            reBuildHeap(i);
        }
    }
    /**
     * length--
     * swap the first element and last element
     * delete last value
     * rebuild the heap
     * */
    public int deletePriority(){
        if(initialArray[0]&lt;=0)return -1;
        int maxValue=initialArray[1];
        initialArray[1]=initialArray[initialArray[0]];
        initialArray[0]--;
        for(int i=initialArray[0];i&gt;=1;i=i/2){
            reBuildHeap(i);
        }
        return maxValue;
    }
    /**
     * print the structure of priority heap
     * */
    @Override
    public String toString() {
        StringBuilder builder=new StringBuilder(&quot;{&quot;);
        for (int i = 1; i &lt;= initialArray[0]; i++) {
            if(i!=1)builder.append(&quot;,&quot;);
            builder.append(initialArray[i]);
        }
        builder.append(&quot;}&quot;);
        return builder.toString();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式]]></title>
        <id>https://sunxiaohang.github.io/post/she-ji-mo-shi/</id>
        <link href="https://sunxiaohang.github.io/post/she-ji-mo-shi/">
        </link>
        <updated>2018-06-13T11:19:42.000Z</updated>
        <summary type="html"><![CDATA[<p>仅包含设计模式的一般实现和设计思想以及设计模式的使用方向，不拘泥于具体语言。以下设计模式思想仅基于Java语言实现，旨在优化软件工程结构，完善项目的鲁棒性和健壮性，便于后期迭代和维护。包含设计模式的一般原则和常用设计模式相关规范。</p>
]]></summary>
        <content type="html"><![CDATA[<p>仅包含设计模式的一般实现和设计思想以及设计模式的使用方向，不拘泥于具体语言。以下设计模式思想仅基于Java语言实现，旨在优化软件工程结构，完善项目的鲁棒性和健壮性，便于后期迭代和维护。包含设计模式的一般原则和常用设计模式相关规范。</p>
<!-- more -->
<h3 id="六大设计原则">六大设计原则</h3>
<h5 id="单一职责原则">单一职责原则</h5>
<blockquote>
<p>分离业务对象和业务逻辑</p>
</blockquote>
<h5 id="里氏替换原则">里氏替换原则</h5>
<blockquote>
<ul>
<li>子类必须完全实现父类方法</li>
<li>子类可以有自己的个性</li>
<li>覆盖或实现父类的方法是<code>输入参数可以被放大</code></li>
<li>覆盖或实现父类的方法是<code>输出结果可以被缩小</code></li>
</ul>
</blockquote>
<h5 id="依赖倒置原则">依赖倒置原则</h5>
<blockquote>
<ul>
<li>高层模块不依赖底层模块，都依赖其抽象</li>
<li>抽象不应该依赖细节</li>
<li>细节应该以来抽象</li>
</ul>
</blockquote>
<h5 id="接口隔离原则">接口隔离原则</h5>
<blockquote>
<ul>
<li>接口尽量小</li>
<li>接口高内聚</li>
<li>定制服务</li>
<li>接口的设计是有限度的</li>
</ul>
</blockquote>
<h5 id="迪米特法则最少知道原则">迪米特法则[最少知道原则]</h5>
<blockquote>
<ul>
<li>只和朋友交流</li>
<li>朋友之间也有<code>距离</code></li>
<li>是自己的就是自己的</li>
<li>谨慎使用Serializable</li>
</ul>
</blockquote>
<h5 id="开闭原则">开闭原则</h5>
<blockquote>
<p>扩展开放，修改关闭</p>
</blockquote>
<h3 id="单例模式">单例模式</h3>
<h5 id="使用场景">使用场景</h5>
<ul>
<li>要求生成唯一序列号的环境</li>
<li>共享访问或共享数据</li>
<li>对象创建资源消耗大</li>
<li>需要定义大量的静态常量和静态方</li>
</ul>
<h3 id="工厂方法模式">工厂方法模式</h3>
<p><code>Example</code></p>
<pre><code>// Human.java
public interface Human {
    void getColor();
}
// WhiteHuman.java
public class WhiteHuman implements Human{
    @Override
    public void getColor() {
        System.out.println(&quot;white Human color!&quot;);
    }
}
// AbstractHumanFactory.java
/**
 * 必需是Class类型
 * 必须是Human的实现类
 * */
public abstract class AbstractHumanFactory {
    public abstract &lt;T extends Human&gt; T createHuman(Class&lt;T&gt; c);
}
// Useage
AbstractHumanFactory factory = new HumanFactory();
Human whiteMan = factory.createHuman(WhiteHuman.class);
</code></pre>
<h5 id="简单工厂">简单工厂</h5>
<pre><code>// HumanFactory.java
/**
* 直接定义静态方法，跳过抽象工厂
*/
public class HumanFactory {
    public static &lt;T extends Human&gt; T createHuman(Class&lt;T&gt; c){
        Human human = null;
        try {
            human = (Human) Class.forName(c.getName()).newInstance();
        } catch (Exception e) {
            System.out.println(&quot;specify human class error!&quot;);
        } 
        return (T) human;
    }
}
// Usage
HumanFactory.createHuman(White.class);
</code></pre>
<h5 id="工厂单例">工厂单例</h5>
<pre><code>// SingletonFactory.java
public class SingletonFactory {
    private static Singleton sigleton;
    static {
        try {
            Class clazz = Class.forName(Singleton.class.getName());
            Constructor constructor = clazz.getDeclaredConstructor();
            constructor.setAccessible(true);
            sigleton = (Singleton) constructor.newInstance();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } 
    }
    public Singleton getSigleton(){
        return sigleton;
    }
}
</code></pre>
<h3 id="抽象工厂模式">抽象工厂模式</h3>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/2480310-9c9889a239cee88c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<pre><code>// AbstractCreator.java
public abstract class AbstractCreator {
    public abstract AbstractProductA createProductA();
    public abstract AbstractProductB createProductB();
}
// Creator1.java
public class Creator1 extends AbstractCreator{
    @Override
    public AbstractProductA createProductA() {
        return new ProductA1();
    }
    @Override
    public AbstractProductB createProductB() {
        return new ProductB1();
    }
}
// Creator2.java
public class Creator2 extends AbstractCreator{
    @Override
    public AbstractProductA createProductA() {
        return new ProductA2();
    }
    @Override
    public AbstractProductB createProductB() {
        return new ProductB2();
    }
}
</code></pre>
<pre><code>//AbstractProductA.java
public abstract class AbstractProductA {
    public void shareMethod(){}
    public abstract void doSomething();
}
//AbstractProductB.java
public abstract class AbstractProductB {
    public void shareMethod(){}
    public abstract void doSomething();
}
// ProductA1.java
public class ProductA1 extends AbstractProductA{
    @Override
    public void doSomething() {
        System.out.println(&quot;product a1&quot;);
    }
}
// ProductA2.java
public class ProductA2 extends AbstractProductA{
    @Override
    public void doSomething() {
        System.out.println(&quot;product a2&quot;);
    }
}
</code></pre>
<h3 id="模板方法模式">模板方法模式</h3>
<pre><code>public abstract class HummerModel {
     public abstract void start();
     public abstract void stop();       
     public abstract void alarm();
     public abstract void engineBoom();
     public abstract void run(){
         this.start();
         this.engineBoom();
         this.alarm();
         this.stop();   
     }
}
</code></pre>
<h5 id="使用场景-2">使用场景</h5>
<ul>
<li>多个子类有共有方法，并且逻辑过程基本相同</li>
<li>重构，吧相同的代码抽取到父类中，通过<code>钩子函数约束行为</code>(实现类约束模板类行为)</li>
</ul>
<pre><code>public abstract class HummerModel {
     public abstract void start();
     public abstract void stop();       
     public abstract void alarm();
     public abstract void engineBoom();
     final public void run() {          
             this.start();              
             this.engineBoom();         
             if(this.isAlarm()){
                      this.alarm();
             }
             this.stop();
     } 
//在抽象类中，isAlarm是一个实现方法，
//其作用是模板方法根据其返回值决定是否要鸣喇叭，
//子类可以覆写该返回值控制其行为.
     protected  boolean isAlarm(){
             return true;
     }
}
</code></pre>
<h3 id="建造者模式">建造者模式</h3>
<pre><code>/** * 总结：  
* 1.静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。 
* 2.静态内部类只能够访问外部类的静态成员,而非静态内部类则可以访问外部类的所有成员(方法，属性)。 
* 3.实例化一个非静态的内部类的方法： 
*  a.先生成一个外部类对象实例 
*  OutClassTest oc1 = new OutClassTest(); 
*  b.通过外部类的对象实例生成内部类对象 
*  OutClassTest.InnerClass no_static_inner = oc1.new InnerClass(); 
*  4.实例化一个静态内部类的方法： 
*  a.不依赖于外部类的实例,直接实例化内部类对象 
*  OutClassTest.InnerStaticClass inner = new OutClassTest.InnerStaticClass(); 
*  b.调用内部静态类的方法或静态变量,通过类名直接调用 
*  OutClassTest.InnerStaticClass.static_value 
*  OutClassTest.InnerStaticClass.getMessage() 
*/
public class Person {
    private final int id;//身份证号
    private final String name;//姓名
    private int age;//年龄
    private boolean sex;//性别
    private String desc;//个人描述
    private Person(Builder builder){
        this.id=builder.id;
        this.name=builder.name;
        this.age=builder.age;
        this.sex=builder.sex;
        this.desc=builder.desc;
    }
    public static class Builder{
        private final int id;
        private final String name;
        private int age;
        private boolean sex;
        private String desc;
        public Builder(int id, String name) {
            this.id = id;
            this.name = name;
        }
        public Builder age(int age){
            //年龄合法性检查
            if(age&lt;0)throw new IllegalArgumentException();
            else this.age=age;
            return this;
        }
        public Builder sex(boolean sex){
            this.sex=sex;
            return this;
        }
        public Builder desc(String desc){
            this.desc=desc;
            return this;
        }
        public Person build(){
            return new Person(this);
        }
    }
}
</code></pre>
<h3 id="代理模式">代理模式</h3>
<p>为其他对象提供一种代理以控制对该对象的访问</p>
<h5 id="简单静态代理">简单静态代理</h5>
<pre><code>public class GamePlayerProxy implements IGamePlayer {
     private IGamePlayer gamePlayer = null;     
     public GamePlayerProxy(IGamePlayer _gamePlayer){
             this.gamePlayer = _gamePlayer;
     }
     @Override
     public void killBoss() {
             this.gamePlayer.killBoss();
     }
     @Override
     public void login(String user, String password) {
             this.gamePlayer.login(user, password);
     }
     @Override
     public void upgrade() {
             this.gamePlayer.upgrade();
     }
}
</code></pre>
<h5 id="动态代理">动态代理</h5>
<pre><code>//IGamePlayer.java
public interface IGamePlayer {
    void login(String username,String password);
    void killBoss();
    void upgrade();
}
// GamePlayer.java
public class GamePlayer implements IGamePlayer{
    private String username;
    private String password;
    public GamePlayer(String username) {
        this.username = username;
    }
    @Override
    public void login(String username, String password) {
        this.username = username;
        this.password = password;
        System.out.println(username+&quot; login!&quot;);
    }
    @Override
    public void killBoss() {
        System.out.println(username+&quot; kill boss!&quot;);
    }
    @Override
    public void upgrade() {
        System.out.println(username+&quot; kill upgrade!&quot;);
    }
}
// GamePlayIH.java
public class GamePlayIH implements InvocationHandler {
    private Object obj;
    public GamePlayIH(Object _obj){
        this.obj = _obj;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object result = method.invoke(this.obj,args);
        if(method.getName().equalsIgnoreCase(&quot;login&quot;))
            System.out.println(&quot;some one login in with my account!&quot;);
        return result;
    }
}
// Usage
IGamePlayer player = new GamePlayer(&quot;zhangsan&quot;);
InvocationHandler handler = new GamePlayIH(player);
ClassLoader loader = player.getClass().getClassLoader();
IGamePlayer proxy = (IGamePlayer) Proxy.newProxyInstance(loader,new Class[]{IGamePlayer.class},handler);
proxy.login(&quot;zhangsan&quot;,&quot;root&quot;);
proxy.killBoss();
proxy.upgrade();
</code></pre>
<h5 id="使用动态代理实现前置后置通知">使用动态代理实现前置后置通知</h5>
<pre><code>// IAdvice.java
public interface IAdvice {
    void exec();
}
//BeforeAdvice.java
public class BeforeAdvice implements IAdvice{
    @Override
    public void exec() {
        System.out.println(&quot;this is a before advice!&quot;);
    }
}
// AfterAdvice.java
public class AfterAdvice implements IAdvice{
    @Override
    public void exec() {
        System.out.println(&quot;this is a after advice!&quot;);
    }
}
//MyInvocationHandler.java
public class MyInvocationHandler implements InvocationHandler {
    private Object obj;
    public MyInvocationHandler(Object obj) {
        this.obj = obj;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        return method.invoke(obj,args);
    }
}
//Subject.java
public interface Subject {
    void doSomething(String args);
}
//RealSubject.java
public class RealSubject implements Subject{
    @Override
    public void doSomething(String args) {
        System.out.println(&quot;do something!---&gt;&quot;+args);
    }
}
// DynamicProxy.java
public class DynamicProxy {
    public static void newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler){
        if(true){
            new BeforeAdvice().exec();
        }
        Subject subject = (Subject) Proxy.newProxyInstance(loader,interfaces,handler);
        subject.doSomething(&quot;execute!&quot;);
        if(true){
            new AfterAdvice().exec();
        }
    }
}
</code></pre>
<h3 id="观察者模式">观察者模式</h3>
<p>定义对象间一对多的依赖关系使得每当对象状态改变，则所有依赖它的对象都会得到通知并自动更新</p>
<pre><code>// Observer.java
public interface Observer {
    void update();
}
// ConcreteObserver.java
public class ConcreteObserver implements Observer{
    @Override
    public void update() {
        System.out.println(&quot;接受消息并进行处理！&quot;);
    }
}
// Subject.java
public abstract class Subject {
    private Vector&lt;Observer&gt; observers = new Vector&lt;&gt;();
    public void addObserver(Observer o){
        observers.add(o);
    }
    public void deleteObserver(Observer o){
        observers.remove(o);
    }
    public void notifyObserver(){
        for (Observer o:observers) {
            o.update();
        }
    }
}
// ConcreteSubject.java
public class ConcreteSubject extends Subject{
    public void doSomething(){
        System.out.println(&quot;logic processing!&quot;);
        super.notifyObserver();
    }
}
// Usage
ConcreteSubject subject = new ConcreteSubject();
        Observer observer = new ConcreteObserver();
        subject.addObserver(observer);
        subject.doSomething();
</code></pre>
<h3 id="门面模式">门面模式</h3>
<p>要求一个子系统的外部与其内部通信必须通过一个统一的对象进行，门面模式提供一个高层次的接口，使得子系统更容易使用。</p>
<pre><code>// LoginClassFlutter.java
public class ClassA {
     public void doSomethingA(){
             //业务逻辑
     }
}
public class ClassB {
     public void doSomethingB(){
             //业务逻辑
     }
}
public class ClassC {
     public void doSomethingC(){
             //业务逻辑
     }
}
// Facade.java
public class Facade {
     //被委托的对象
     private ClassA a = new ClassA();
     private ClassB b = new ClassB();
     private ClassC c = new ClassC();
     //提供给外部访问的方法
     public void methodA(){
             this.a.doSomethingA();
     }
     public void methodB(){
             this.b.doSomethingB();
     }
     public void methodC(){
             this.c.doSomethingC();
     }
}
</code></pre>
<h3 id="装饰者模式">装饰者模式</h3>
<p>动态的给以一个对象添加一些额外的职责，就增加功能来说，装饰着模式相比生成子类更加灵活</p>
<pre><code>//Component.java
public abstract class Component {
    public abstract void operate();
}
//ConcreteComponent.java
public class ConcreteComponent extends Component{
    @Override
    public void operate() {
        System.out.println(&quot;do something operate!&quot;);
    }
}
//Decorator.java (extent `Component`)
public abstract class Decorator extends Component{
    private Component component = null;
    public Decorator(Component component) {
        this.component = component;
    }
    @Override
    public void operate() {
        this.component.operate();
    }
}
//ConcreteDecorator1.java
public class ConcreteDecorator1 extends Decorator{
    public ConcreteDecorator1(Component component) {
        super(component);
    }
    private void method1(){
        System.out.println(&quot;method1 operate!&quot;);
    }
    @Override
    public void operate() {
        this.method1();
        super.operate();
    }
}
// Usage
Component component = new ConcreteComponent();
component = new ConcreteDecorator1(component);
component = new ConcreteDecorator2(component);
component.operate();
</code></pre>
<h5 id="应用场景">应用场景</h5>
<ul>
<li>需要扩展一个类的功能</li>
<li>需要动态地给一个对象增加功能，也可动态撤销</li>
<li>需要为一批兄弟类怎行改装或加装功能</li>
</ul>
<h3 id="责任链模式">责任链模式</h3>
<p>使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系，将这些对象连接成一条链，并沿着这条链传递该请求，直到有对象处理该请求为止。</p>
<pre><code>class Level{}
class Request{
    public Level getRequestLevel(){
        return null;
    }
}
class Response{}
// Handler.java(abstract interface)
public abstract class Handler {
    private Handler nextHandler;
    public final Response handleMessage(Request request){
        Response response = null;
        if(this.getHandlerLevel().equals(request.getRequestLevel())){
            response = this.echo(request);
        }else {
            if(this.nextHandler != null){
                response = this.nextHandler.handleMessage(request);
            }else {
                System.out.println(&quot; no handler exception&quot;);
                return null;
            }
        }
        return response;
    }
    public void setNext(Handler _handler){
        this.nextHandler = _handler;
    }
    protected abstract Level getHandlerLevel();
    protected abstract Response echo(Request request);
}
// ConcreteHandler1.java
//ConcreteHandler2.java 同
//ConcreteHandler3.java 同
public class ConcreteHandler1 extends Handler{
    @Override
    protected Level getHandlerLevel() {
        //设置自己的处理级别
        return null;
    }
    @Override
    protected Response echo(Request request) {
        //完成处理逻辑
        return null;
    }
}
// Usage
Handler handler1 = new ConcreteHandler1();
Handler handler2 = new ConcreteHandler2();
Handler handler3 = new ConcreteHandler3();
handler1.setNext(handler2);
handler2.setNext(handler3);
Response response = handler1.handleMessage(new Request());
</code></pre>
<h3 id="访问者模式">访问者模式</h3>
<p>封装一些作用与某种数据结构的中的各种元素操作，它可以在不改变数据结构的前提下定义作用于这些元素的新操作</p>
<pre><code>// Element.java
public abstract class Element {
    public abstract void doSomething();
    public abstract void accept(IVisitor visitor);
}
// ConcreteElement1.java
// ConcreteElement2.java 同
public class ConcreteElement1 extends Element{
    @Override
    public void doSomething() {
        System.out.println(&quot;processing... 1&quot;);
    }
    @Override
    public void accept(IVisitor visitor) {
        visitor.visit(this);
    }
}
// IVisitor.java
public interface IVisitor {
    public void visit(ConcreteElement1 element1);
    public void visit(ConcreteElement2 element2);
}
//Visitor.java
public class Visitor implements IVisitor{
    @Override
    public void visit(ConcreteElement1 element1) {
        element1.doSomething();
    }
    @Override
    public void visit(ConcreteElement2 element2) {
        element2.doSomething();
    }
}
// Usage
Element element = createElement();
element.accept(new Visitor());
</code></pre>
<h3 id="命令模式">命令模式</h3>
<p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能</p>
<pre><code>// Receiver.java
public abstract class Receiver {
    public abstract void doSomething();
}
// ConcreteReceiver1.java
// ConcreteReceiver2.java 同
public class ConcreteReceiver1 extends Receiver {
    @Override
    public void doSomething() {
        System.out.println(&quot;receiver 1&quot;);
    }
}
//Command.java
public abstract class Command {
    public abstract void execute();
}
// ConcreteCommand1.java
// ConcreteCommand2.java
public class ConcreteCommand1 extends Command {
    private Receiver receiver;
    public ConcreteCommand1(Receiver receiver) {
        this.receiver = receiver;
    }
    @Override
    public void execute() {
        this.receiver.doSomething();
    }
}
//Invoke.java
public class Invoke {
    private Command command;
    public void setCommand(Command command) {
        this.command = command;
    }
    public void action(){
        this.command.execute();
    }
}
//Usage
Invoke invoke = new Invoke();
Receiver receiver = new ConcreteReceiver1();
Command command = new ConcreteCommand1(receiver);
invoke.setCommand(command);
invoke.action();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[about]]></title>
        <id>https://sunxiaohang.github.io/post/about/</id>
        <link href="https://sunxiaohang.github.io/post/about/">
        </link>
        <updated>2017-06-07T12:47:48.000Z</updated>
        <content type="html"><![CDATA[<h4 id="孙航">孙航</h4>
<p>132 0880 3520 | cssunhang@outlook.com | sunxiaohang.github.io</p>
<h4 id="个人经历">个人经历</h4>
<h5 id="20199至今">2019/9—至今</h5>
<p>腾讯计算机系统有限公司 | 游戏开发</p>
<p>工作描述：负责游戏项目的开发和维护工作</p>
<h5 id="20171220189">2017/12—2018/9</h5>
<p>北京华亿创新信息科技 | 前端 /QT嵌入式</p>
<p>工作描述：全面负责开发跳水比赛后台管理系统/球类计时记分控制系统</p>
<h5 id="2016620177">2016/6—2017/7</h5>
<p>云南青才信息科技 | Android 开发</p>
<p>工作描述：负责平安社区产品监控视频流采集及解码</p>
<h5 id="20189至今">2018/9—至今</h5>
<p>西安电子科技大学 | 软件工程 | 硕士</p>
<h5 id="2013920176">2013/9—2017/6</h5>
<p>西南林业大学 | 电子信息工程 | 本科</p>
<h3 id="在校经历">在校经历</h3>
<blockquote>
<p>计算机设计大赛 | 省级 | 一等奖</p>
<p>计算机设计大赛 | 国家级 | 二等奖</p>
<p>西电腾讯俱乐部|学业奖学金|创新创业奖</p>
</blockquote>
<h4 id="专业技能">专业技能</h4>
<h5 id="java">Java</h5>
<ul>
<li>Java 基础 <strong>|</strong> Java多线程 <strong>|</strong> Java并发 <strong>|</strong> Java锁</li>
<li>Java设计模式 <strong>|</strong> Java虚拟机</li>
<li>Spring <strong>|</strong> Spring MVC</li>
<li>Spring boot <strong>|</strong> thymeleaf <strong>|</strong> dubbo RPC</li>
</ul>
<h5 id="android">Android</h5>
<ul>
<li>Android 应用框架 <strong>|</strong> Android设计模式</li>
<li>View绘制 <strong>|</strong> 自定义ViewGroup</li>
<li>Android 网络编程</li>
<li>Android IPC</li>
</ul>
<h5 id="unity3d">Unity3D</h5>
<ul>
<li>UGUI <strong>|</strong> FairyGUI</li>
<li>Unity3D基础 <strong>|</strong> 动画系统 <strong>|</strong> 对话口型</li>
<li>Shader</li>
</ul>
<h4 id="博客主要分享">博客主要分享</h4>
<ul>
<li>Java <strong>|</strong> Android <strong>|</strong> Unity3D</li>
<li>数据结构 <strong>|</strong> 算法 <strong>|</strong> 设计模式</li>
</ul>
<h4 id="项目经验">项目经验</h4>
<h5 id="20199至今-腾讯计算机系统有限公司-游戏开发">2019/9—至今 | 腾讯计算机系统有限公司 |游戏开发</h5>
<blockquote>
<p>项目简介：MMO游戏项目的开发与维护</p>
<p>功能：MMO游戏UI|事件系统|Unity3D引擎|动画表现组</p>
<p>职责：项目开发 | 代码维护 | 文档的撰写</p>
</blockquote>
<h5 id="2019420195-个人项目-ctimes">2019/4—2019/5 | 个人项目 | CTimes</h5>
<blockquote>
<p>项目简:新闻影音图书客户端</p>
<p>功能:  最新新闻|豆瓣图书|豆瓣电影|音视频</p>
<p>职责:  项目UI设计 | 架构设计 | 代码实现 | 数据调试|文档撰写</p>
</blockquote>
<h5 id="2019120192-个人项目-停车场仿真系统">2019/1—2019/2 | 个人项目 | 停车场仿真系统</h5>
<blockquote>
<p>项目简介:停车场管理仿真系统</p>
<p>功能:  停车场模拟|用户管理|数据持久化</p>
<p>职责:  项目UI设计 | 架构设计 | 代码实现 | 数据库调试 | 文档撰写</p>
</blockquote>
<h5 id="20171220189-北京华亿创新-跳水比赛后台管理系统">2017/12—2018/9 | 北京华亿创新 | 跳水比赛后台管理系统</h5>
<blockquote>
<p>项目简介：管理跳水比赛项目的人员编排，赛程安排，打分系统等</p>
<p>职责：系统的设计与实现 | 代码编写、调试 | 帮助文档的撰写</p>
</blockquote>
<h5 id="2018320184-北京华亿创新-球类计时记分系统">2018/3—2018/4 | 北京华亿创新 | 球类计时记分系统</h5>
<blockquote>
<p>项目简介：球类计时、记分，球权控制，离场，犯规等</p>
<p>职责：系统设计与实现 | 代码的编写、调试 | 文档的撰写</p>
</blockquote>
<h5 id="20161020175-云南青才信息-平安社区">2016/10—2017/5 | 云南青才信息 | 平安社区</h5>
<blockquote>
<p>项目简介：社区维护，管理，报备系统</p>
<p>职责：沟通对接 | 视频流解码</p>
</blockquote>
<h5 id="20168201610-比赛项目-intelligent-car">2016/8—2016/10 | 比赛项目 | Intelligent Car</h5>
<blockquote>
<p>项目简介:  语音控制的智能小车</p>
<p>功能:  语音识别 | 人脸识别 | 视频流传输 | 语音助手</p>
<p>职责:  项目UI设计 | 机械控制程序编写 | Android控制程序编写 | 通信服务器实现 | 文档撰写</p>
</blockquote>
]]></content>
    </entry>
</feed>