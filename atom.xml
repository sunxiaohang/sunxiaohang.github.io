<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sunxiaohang.github.io</id>
    <title>KnowledgeBase</title>
    <updated>2020-04-09T03:39:21.392Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sunxiaohang.github.io"/>
    <link rel="self" href="https://sunxiaohang.github.io/atom.xml"/>
    <subtitle>KnowledgeBase</subtitle>
    <logo>https://sunxiaohang.github.io/images/avatar.png</logo>
    <icon>https://sunxiaohang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, KnowledgeBase</rights>
    <entry>
        <title type="html"><![CDATA[算法]]></title>
        <id>https://sunxiaohang.github.io/post/suan-fa/</id>
        <link href="https://sunxiaohang.github.io/post/suan-fa/">
        </link>
        <updated>2020-04-09T03:37:58.000Z</updated>
        <summary type="html"><![CDATA[<p>算法包括，基础查找和排序算法，深度广度优先遍历，迷宫求解算法，优先队列，分支限界，动态规划和诸如N皇后等算法应用</p>
]]></summary>
        <content type="html"><![CDATA[<p>算法包括，基础查找和排序算法，深度广度优先遍历，迷宫求解算法，优先队列，分支限界，动态规划和诸如N皇后等算法应用</p>
<!-- more -->
<h4 id="广度优先的迷宫求解算法">广度优先的迷宫求解算法</h4>
<pre><code>class Position {
    private int px;
    private int py;
    public Position(int px, int py) {
        this.px = px;
        this.py = py;
    }
    public int getPx() {
        return px;
    }
    public void setPx(int px) {
        this.px = px;
    }
    public int getPy() {
        return py;
    }
    public void setPy(int py) {
        this.py = py;
    }
}
public class Maze {
    private final Position start;//迷宫的起点final
    private final Position end;//迷宫的终点final
    private ArrayList&lt;String&gt; footPrint;//足迹
    private ArrayList&lt;Position&gt; test;
    private MyStack&lt;Position&gt; stacks;//自定义栈（也可以用java.util中的Stack栈）若想了解MyStack的实现，可以参考我的另一篇博客
    private Position currentPosition;//定义当前位置
    public Maze() {//集合，栈的初始化工作
        start = new Position(1, 1);
        end = new Position(8, 8);
        currentPosition = start;
        stacks = new MyStack&lt;&gt;();
        test = new ArrayList&lt;&gt;();
    }
    public static final int map[][] = //定义地图10*10的方格
            {{1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {1, 0, 0, 1, 0, 0, 0, 1, 0, 1},
            {1, 0, 0, 1, 0, 0, 0, 1, 0, 1},
            {1, 0, 0, 0, 0, 1, 1, 0, 0, 1},
            {1, 0, 1, 1, 1, 0, 0, 0, 0, 1},
            {1, 0, 0, 0, 1, 0, 0, 0, 0, 1},
            {1, 0, 1, 0, 0, 0, 1, 0, 0, 1},
            {1, 0, 1, 1, 1, 0, 1, 1, 0, 1},
            {1, 1, 0, 0, 0, 0, 0, 0, 0, 1},
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}};
    public static void printMap() {//打印地图
        for (int i = 0; i &lt; 10; i++) {
            for (int j = 0; j &lt; 10; j++) {
                if (map[i][j] == 1) System.out.print(&quot; ■&quot;);
                else System.out.print(&quot;  &quot;);
            }
            System.out.println();
        }
    }
    public boolean moveTop() {//上移
        String s = currentPosition.getPx() + &quot;&quot; + (currentPosition.getPy() - 1);
        if ((map[currentPosition.getPx()][currentPosition.getPy() - 1] != 1) &amp; !isArrived(s)) {
            footPrint.add(s);
            return true;
        }
        return false;
    }
    public boolean moveRight() {//右移
        String s = (currentPosition.getPx() + 1) + &quot;&quot; + currentPosition.getPy();
        if (map[currentPosition.getPx() + 1][currentPosition.getPy()] != 1 &amp; !isArrived(s)) {
            footPrint.add(s);
            return true;
        }
        return false;
    }
    public boolean moveBottom() {//下移
        String s = currentPosition.getPx() + &quot;&quot; + (currentPosition.getPy() + 1);
        if ((map[currentPosition.getPx()][currentPosition.getPy() + 1] != 1) &amp; !isArrived(s)) {
            footPrint.add(s);
            return true;
        }
        return false;
    }
    public boolean moveLeft() {//左移
        String s = (currentPosition.getPx() - 1) + &quot;&quot; + currentPosition.getPy();
        if ((map[currentPosition.getPx() - 1][currentPosition.getPy()] != 1) &amp; !isArrived(s)) {
            footPrint.add(s);
            return true;
        }
        return false;
    }
    public boolean isArrived(String position) {//判断当前位置是否已经到打过
        return footPrint.contains(position);
    }
    public void move() {//move函数分别向四个方向移动，然后将可行的path入栈
        if (moveRight()) {
            Position temp = new Position(currentPosition.getPx() + 1, currentPosition.getPy());
            test.add(temp);
            stacks.push(temp);
        } else if (moveBottom()) {
            Position temp = new Position(currentPosition.getPx(), currentPosition.getPy() + 1);
            test.add(temp);
            stacks.push(temp);
        } else if (moveTop()) {
            Position temp = new Position(currentPosition.getPx(), currentPosition.getPy() - 1);
            test.add(temp);
            stacks.push(temp);
        } else if (moveLeft()) {
            Position temp = new Position(currentPosition.getPx() - 1, currentPosition.getPy());
            test.add(temp);
            stacks.push(temp);
        } else {
            currentPosition = stacks.pop();//若当前位置四个方向都走不通，则将当前位置出栈，继续遍历上一节点
        }
    }
    public static void main(String[] args) {
        Maze m = new Maze();
        m.footPrint = new ArrayList&lt;&gt;();
        m.footPrint.add(&quot;11&quot;);
        m.stacks.push(m.start);
        while (m.currentPosition.getPx() != 8 || m.currentPosition.getPy() != 8) {
            m.move();
        }
        printMap();
        System.out.println(&quot;下面是足迹,长度是：&quot; + m.footPrint.size());
        m.printFootPrint();
    }
    public void printFootPrint() {
        for (int i = 0; i &lt; footPrint.size(); i++) {
            System.out.print(footPrint.get(i) + &quot;,&quot;);
        }
        System.out.println();
    }
}
</code></pre>
<h4 id="二叉树">二叉树</h4>
<pre><code>public class BinaryTree {
    private Node parent;
    private Node currentPoint;
    private StringBuffer sb;
    private int length=0;

    class Node {
        private int value;
        private Node leftChild;
        private Node rightChild;

        public Node(int value, Node leftChild, Node rightChild) {
            this.value = value;
            this.leftChild = leftChild;
            this.rightChild = rightChild;
        }
    }
    public Node getParent(){
        return parent;
    }

    public BinaryTree() {
        sb=new StringBuffer();
    }

    public void insert(int value) {
        if (parent == null) {
            Node node = new Node(value, null, null);
            parent = node;
            length++;
        } else {
            currentPoint = parent;
            while(true){
                if(currentPoint.value&gt;value){
                    if(currentPoint.leftChild!=null){
                        currentPoint=currentPoint.leftChild;
                    }else{
                        currentPoint.leftChild=new Node(value,null,null);
                        length++;
                        break;
                    }
                }else{
                    if(currentPoint.rightChild!=null){
                        currentPoint=currentPoint.rightChild;
                    }else{
                        currentPoint.rightChild=new Node(value,null,null);
                        length++;
                        break;
                    }
                }
            }
        }
    }

    public String visit(Node node) {
        sb.append(node.value+&quot;(&quot;);
        if (node.leftChild != null) visit(node.leftChild);
        if (node.rightChild != null) visit(node.rightChild);
        sb.append(&quot;)&quot;);
        return sb.toString();
    }
    public int getLength(){
        return length;
    }

    @Override
    public String toString() {
        return visit(parent);
    }
}
</code></pre>
<h4 id="二分查找">二分查找</h4>
<pre><code>int binary_search(int arrays[],int result,int length){
    int begin=0,end=length-1;
    int mid=0;
    while(begin&lt;=end){
        mid=(begin+end)/2;
        if(arrays[mid]==result)break;
        else if(arrays[mid]&lt;result)begin=mid+1;
        else if(arrays[mid]&gt;result)end=mid-1;
    }
    return mid;
}
</code></pre>
<h4 id="共享数组原地逆置">共享数组原地逆置</h4>
<pre><code>public class Main {
    public static char array[]={'A','B','C','D','E','F','G','H','1','2','3','4'};
    public static void main(String[] args) {
        reverse(0,7);//逆置字母序列结果为：HGFEDCBA1234
        reverse(8,11);//逆置数字序列结果为：HGFEDCBA4321
        reverse(0,11);//整体逆置结果为：1234ABCDEFG
        print(array);
    }
    public static void reverse(int start,int end){//逆置函数
        char temp;
        while(start&lt;end) {
            temp = array[start];
            array[start++] = array[end];
            array[end--] = temp;
        }
    }
    private static void print(char[] array) {
        for (int i = 0; i &lt;array.length; i++)
            System.out.print(array[i]);
        System.out.println();
    }
}
</code></pre>
<h4 id="n-皇后问题">N 皇后问题</h4>
<pre><code>/**
 * n queens problem
 *
 * */
public class EightQueen {
    private int QUEEN_COUNT = 0;//represent the queen count
    private int[][] queenCount;//chess box matrix
    private int resultCount = 0;//solution number
    private int[] queenPlace;//mark the queen placed position
    /**
     * construct a EightQueen with a argument represent the number of queen
     * initial a empty chess box
     * 0 represent empty
     * 1 represent the area has been taken
     * recurse to call the putQueen method
     * the queenPlace array to mark the queen's taken area which uses to print
     *
     * */
    public EightQueen(int n) {
        this.QUEEN_COUNT = n;
        this.resultCount = 0;
        this.queenCount = new int[QUEEN_COUNT][QUEEN_COUNT];
        queenPlace = new int[QUEEN_COUNT];
        putQueen(0);
    }
    /**
     * implement the putQueen function to recursion
     * use column index in outer loop and row index in inner loop with step increase
     * */
    private void putQueen(int row) {
        for (int column = 0; column &lt; QUEEN_COUNT; column++) {//loop for QUEEN_COUNT times
            if (queenCount[row][column] == 0) {//judge the condition
                /**
                 * each row has one queen
                 * mark the column and diagonal back diagonal(row has been scatter)
                 *
                 * */
                for (int nextRow = row + 1; nextRow &lt; QUEEN_COUNT; nextRow++) {
                    queenCount[nextRow][column]++;
                    if (column - nextRow + row &gt;= 0) {
                        queenCount[nextRow][column - nextRow + row]++;
                    }
                    if (column + nextRow - row &lt; QUEEN_COUNT) {
                        queenCount[nextRow][column + nextRow - row]++;
                    }
                }
                queenPlace[row] = column;//place the queen with only column information
                if (row == QUEEN_COUNT - 1) printQueen(++resultCount);//recursion has completed
                else putQueen(row + 1);//recurse to call the putQueen function
                /**
                 *
                 * unmarked the column and diagonal back diagonal(row has been scatter)
                 *
                 * */
                for (int rows = row + 1; rows &lt; QUEEN_COUNT; rows++) {
                    queenCount[rows][column]--;
                    if (column - rows + row &gt;= 0) {
                        queenCount[rows][column - rows + row]--;
                    }
                    if (column + rows - row &lt; QUEEN_COUNT) {
                        queenCount[rows][column + rows - row]--;
                    }
                }
            }
        }
        if (row == 0) System.out.println(QUEEN_COUNT + &quot; queens has totally &quot; + resultCount + &quot;result.&quot;);
    }

    private void printQueen(int size)
    {
        System.out.println(&quot;********** &quot;+size+&quot; **********\n&quot;);
        for (int i = 0; i &lt; QUEEN_COUNT; i++) {
            for (int j = 0; j &lt; QUEEN_COUNT; j++) {
                System.out.print(queenPlace[i] == j ? &quot; # &quot; : &quot; - &quot;);
            }
            System.out.println();
        }
    }
}

</code></pre>
<h4 id="最大子序和问题">最大子序和问题</h4>
<pre><code>int MaxSubSeqSum(int arrays[], int left, int right) {
    int sum = 0;
    if (left == right) {
        if (arrays[left] &gt; 0)return arrays[left];
        else sum = 0;
    } else {
        int middle = (left + right) / 2;
        int leftSum = MaxSubSeqSum(arrays, left, middle);
        int rightSum = MaxSubSeqSum(arrays, middle + 1, right);
        int finalLeftSum = 0, thisLeftSum = 0;
        for (int i = left; i &lt;=middle; i++) {
            thisLeftSum += arrays[i];
            if (thisLeftSum &gt; finalLeftSum)finalLeftSum = thisLeftSum;
        }
        int finalRightSum = 0, thisRightSum = 0;
        for (int j = middle + 1; j &lt; right; j++) {
            thisRightSum += arrays[j];
            if (thisRightSum &gt; finalRightSum)finalRightSum = thisRightSum;
        }
        sum = finalLeftSum + finalRightSum;
        printf(&quot;left sum is %d,right sum is %d\n&quot;,finalLeftSum,finalRightSum);
        if (sum &lt; leftSum)sum = leftSum;
        if (sum &lt; rightSum)sum = rightSum;
    }
    return sum;
}
</code></pre>
<h4 id="优先队列">优先队列</h4>
<pre><code>/**
 * use maximum-top heap to implement priority queue
 * define a MAX_SIZE_OF_PRIORITY_QUEUE to limit the max length of priority queue
 * use a integer array to store element
 * hypothesis i is the root node and then use 2*i to mark left child and 2*i+1 to mark right child
 * use initialArray[0] to store the length of heap
 * */
public class PriorityQueue{
    private static final int MAX_SIZE_OF_PRIORITY_QUEUE=100;
    private int[] initialArray;
    /**
     * initial priority queue with a exist array which can't be null
     * */
    public PriorityQueue(int[] initialElement) {
        if(initialElement==null)return;
        if(initialElement.length==0)return;
        initialArray=new int[MAX_SIZE_OF_PRIORITY_QUEUE];
        initialArray[0]=initialElement.length;
        for(int i=0;i&lt;initialElement.length;i++)initialArray[i+1]=initialElement[i];
        System.out.println(initialArray[0]);
        for (int i = initialArray[0]; i &gt;0 ; i--)reBuildHeap(i);
    }
    /**
     * rebuild array according to the value of each node
     * maximum-top heap
     * index represents the index of a node which should be rebuild(include it's children node)
     *
     * simple:
     *         1
     *      2     3
     *   4   5  6   7
     *
     * */
    private void reBuildHeap(int index){
        System.out.println(&quot;execute rebuild function to rebuild a maximum-top heap with one loop&quot;);
        int leftChildIndex=index*2;
        int rightChildIndex=leftChildIndex+1;
        int length=initialArray[0];
        int biggerValueIndex=-1;
        if(leftChildIndex&gt;length&amp;&amp;rightChildIndex&gt;length){
            System.out.println(&quot;no left child&quot;);
            return;
        }
        if(leftChildIndex&lt;=length&amp;&amp;rightChildIndex&gt;length){
            System.out.println(&quot;only left child&quot;);
            biggerValueIndex=leftChildIndex;
        }
        if(leftChildIndex&gt;length&amp;&amp;rightChildIndex&lt;=length){
            System.out.println(&quot;only right child&quot;);
            biggerValueIndex=rightChildIndex;
        }
        if(leftChildIndex&lt;=length&amp;&amp;rightChildIndex&lt;=length){
            System.out.println(&quot;both children&quot;);
            biggerValueIndex=initialArray[leftChildIndex]&gt;initialArray[rightChildIndex]?leftChildIndex:rightChildIndex;
        }
        if(initialArray[index]&gt;initialArray[biggerValueIndex]){
            System.out.println(&quot;unnecessary to swap!&quot;);
            return;
        }else{
            int temp=initialArray[index];
            initialArray[index]=initialArray[biggerValueIndex];
            initialArray[biggerValueIndex]=temp;
            this.reBuildHeap(biggerValueIndex);
        }
    }
    public int getLength() {
        return initialArray[0];
    }
    /**
     * get top priority value of heap
     * the first element of array
     * */
    public int priority(){
        return initialArray[1];
    }
    /**
     * length++
     * add element to the tail of array
     * rebuild the heap to regular priority heap
     * */
    public void insert(int element){
        initialArray[0]++;
        initialArray[initialArray[0]]=element;
        for(int i=initialArray[0];i&gt;=1;i=i/2){
            reBuildHeap(i);
        }
    }
    /**
     * length--
     * swap the first element and last element
     * delete last value
     * rebuild the heap
     * */
    public int deletePriority(){
        if(initialArray[0]&lt;=0)return -1;
        int maxValue=initialArray[1];
        initialArray[1]=initialArray[initialArray[0]];
        initialArray[0]--;
        for(int i=initialArray[0];i&gt;=1;i=i/2){
            reBuildHeap(i);
        }
        return maxValue;
    }
    /**
     * print the structure of priority heap
     * */
    @Override
    public String toString() {
        StringBuilder builder=new StringBuilder(&quot;{&quot;);
        for (int i = 1; i &lt;= initialArray[0]; i++) {
            if(i!=1)builder.append(&quot;,&quot;);
            builder.append(initialArray[i]);
        }
        builder.append(&quot;}&quot;);
        return builder.toString();
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[about]]></title>
        <id>https://sunxiaohang.github.io/post/about/</id>
        <link href="https://sunxiaohang.github.io/post/about/">
        </link>
        <updated>2020-04-06T12:47:48.000Z</updated>
        <content type="html"><![CDATA[<h4 id="孙航">孙航</h4>
<p>132 0880 3520 | cssunhang@outlook.com | sunxiaohang.github.io</p>
<h4 id="个人经历">个人经历</h4>
<h5 id="20199至今">2019/9—至今</h5>
<p>腾讯计算机系统有限公司 <strong>|</strong> 游戏开发</p>
<p>工作描述：负责游戏项目的开发和维护工作</p>
<h5 id="20171220189">2017/12—2018/9</h5>
<p>北京华亿创新信息科技 | 前端 /QT嵌入式</p>
<p>工作描述：全面负责开发跳水比赛后台管理系统/球类计时记分控制系统</p>
<h5 id="2016620177">2016/6—2017/7</h5>
<p>云南青才信息科技 | Android 开发</p>
<p>工作描述：负责平安社区产品监控视频流采集及解码</p>
<h5 id="20189至今">2018/9—至今</h5>
<p>西安电子科技大学 | 软件工程 | 硕士</p>
<h5 id="2013920176">2013/9—2017/6</h5>
<p>西南林业大学 | 电子信息工程 | 本科</p>
<h3 id="在校经历">在校经历</h3>
<blockquote>
<p>计算机设计大赛 | 省级 | 一等奖</p>
<p>计算机设计大赛 | 国家级 | 二等奖</p>
<p>西电腾讯俱乐部|学业奖学金|创新创业奖</p>
</blockquote>
<h4 id="专业技能">专业技能</h4>
<h5 id="java">Java</h5>
<ul>
<li>Java 基础 <strong>|</strong> Java多线程 <strong>|</strong> Java并发 <strong>|</strong> Java锁</li>
<li>Java设计模式 <strong>|</strong> Java虚拟机</li>
<li>Spring <strong>|</strong> Spring MVC</li>
<li>Spring boot <strong>|</strong> thymeleaf <strong>|</strong> dubbo RPC</li>
</ul>
<h5 id="android">Android</h5>
<ul>
<li>Android 应用框架 <strong>|</strong> Android设计模式</li>
<li>View绘制 <strong>|</strong> 自定义ViewGroup</li>
<li>Android 网络编程</li>
<li>Android IPC</li>
</ul>
<h5 id="unity3d">Unity3D</h5>
<ul>
<li>UGUI <strong>|</strong> FairyGUI</li>
<li>Unity3D基础 <strong>|</strong> 动画系统 <strong>|</strong> 对话口型</li>
<li>Shader</li>
</ul>
<h4 id="博客主要分享">博客主要分享</h4>
<ul>
<li>Java <strong>|</strong> Android <strong>|</strong> Unity3D</li>
<li>数据结构 <strong>|</strong> 算法 <strong>|</strong> 设计模式</li>
</ul>
<h4 id="项目经验">项目经验</h4>
<h5 id="20199至今-腾讯计算机系统有限公司-游戏开发">2019/9—至今 | 腾讯计算机系统有限公司 |游戏开发</h5>
<blockquote>
<p>项目简介：MMO游戏项目的开发与维护</p>
<p>功能：MMO游戏UI|事件系统|Unity3D引擎|动画表现组</p>
<p>职责：项目开发 | 代码维护 | 文档的撰写</p>
</blockquote>
<h5 id="2019420195-个人项目-ctimes">2019/4—2019/5 | 个人项目 | CTimes</h5>
<blockquote>
<p>项目简:新闻影音图书客户端</p>
<p>功能:  最新新闻|豆瓣图书|豆瓣电影|音视频</p>
<p>职责:  项目UI设计 | 架构设计 | 代码实现 | 数据调试|文档撰写</p>
</blockquote>
<h5 id="2019120192-个人项目-停车场仿真系统">2019/1—2019/2 | 个人项目 | 停车场仿真系统</h5>
<blockquote>
<p>项目简介:停车场管理仿真系统</p>
<p>功能:  停车场模拟|用户管理|数据持久化</p>
<p>职责:  项目UI设计 | 架构设计 | 代码实现 | 数据库调试 | 文档撰写</p>
</blockquote>
<h5 id="20171220189-北京华亿创新-跳水比赛后台管理系统">2017/12—2018/9 | 北京华亿创新 | 跳水比赛后台管理系统</h5>
<blockquote>
<p>项目简介：管理跳水比赛项目的人员编排，赛程安排，打分系统等</p>
<p>职责：系统的设计与实现 | 代码编写、调试 | 帮助文档的撰写</p>
</blockquote>
<h5 id="2018320184-北京华亿创新-球类计时记分系统">2018/3—2018/4 | 北京华亿创新 | 球类计时记分系统</h5>
<blockquote>
<p>项目简介：球类计时、记分，球权控制，离场，犯规等</p>
<p>职责：系统设计与实现 | 代码的编写、调试 | 文档的撰写</p>
</blockquote>
<h5 id="20161020175-云南青才信息-平安社区">2016/10—2017/5 | 云南青才信息 | 平安社区</h5>
<blockquote>
<p>项目简介：社区维护，管理，报备系统</p>
<p>职责：沟通对接 | 视频流解码</p>
</blockquote>
<h5 id="20168201610-比赛项目-intelligent-car">2016/8—2016/10 | 比赛项目 | Intelligent Car</h5>
<blockquote>
<p>项目简介:  语音控制的智能小车</p>
<p>功能:  语音识别 | 人脸识别 | 视频流传输 | 语音助手</p>
<p>职责:  项目UI设计 | 机械控制程序编写 | Android控制程序编写 | 通信服务器实现 | 文档撰写</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity InAction]]></title>
        <id>https://sunxiaohang.github.io/post/unity-inaction/</id>
        <link href="https://sunxiaohang.github.io/post/unity-inaction/">
        </link>
        <updated>2020-04-06T12:09:00.000Z</updated>
        <summary type="html"><![CDATA[<p>Untiy常用逻辑代码的实现方式，归纳总结，用于标准化代码结构，巩固加强</p>
]]></summary>
        <content type="html"><![CDATA[<p>Untiy常用逻辑代码的实现方式，归纳总结，用于标准化代码结构，巩固加强</p>
<!-- more -->
<h4 id="movement">Movement</h4>
<pre><code>public class FPSInput : MonoBehaviour
{
    public float m_speed = 6.0f;
    private CharacterController m_CharacterController;
    public float gravity = -9.8f;

    private void Start()
    {
        m_CharacterController = GetComponent&lt;CharacterController&gt;();
    }

    private void Update()
    {
        //移动的代码依赖于游戏的帧率，frame rate dependence
        float deltaX = Input.GetAxis(&quot;Horizontal&quot;) * m_speed;
        float deltaZ = Input.GetAxis(&quot;Vertical&quot;) * m_speed;
        Vector3 movement = new Vector3(deltaX,0,deltaZ);
        movement = Vector3.ClampMagnitude(movement, m_speed) * Time.deltaTime;//使对角移动的速度和沿轴移动的速度一样
        movement = transform.TransformDirection(movement);//把movement向量丛本地坐标变换为全局坐标
        movement.y = gravity;
        m_CharacterController.Move(movement);
    }
}
</code></pre>
<h4 id="rotation">Rotation</h4>
<pre><code>public class MouseLook : MonoBehaviour
{
    public enum RotationAxes
    {
        MouseXAndY,
        MouseX,
        MouseY
    }

    public RotationAxes axes = RotationAxes.MouseXAndY;
    public float sensitivityHor = 9.0f;
    public float sensitivityVert = 9.0f;
    public float miniMumVert = -45.0f;
    public float maxiMumVert = 45.0f;
    private float _rotationX = 0;
    private Rigidbody m_Rigidbody;

    private void Start()
    {
        m_Rigidbody = GetComponent&lt;Rigidbody&gt;();
        if(m_Rigidbody!=null)m_Rigidbody.freezeRotation = true;
    }

    private void Update()
    {
        if (axes == RotationAxes.MouseX)
        {
            transform.Rotate(0,Input.GetAxisRaw(&quot;Mouse X&quot;)*sensitivityHor,0);
        }
        else if (axes == RotationAxes.MouseY)
        {
            _rotationX -= Input.GetAxis(&quot;Mouse Y&quot;) * sensitivityVert;
            _rotationX = Mathf.Clamp(_rotationX,miniMumVert,maxiMumVert);
            float rotationY = transform.localEulerAngles.y;//获取当前y轴的欧拉角
            transform.localEulerAngles = new Vector3(_rotationX,rotationY,0);
        }
        else if (axes == RotationAxes.MouseXAndY)
        {
            _rotationX -= Input.GetAxis(&quot;Mouse Y&quot;) * sensitivityHor;
            _rotationX = Mathf.Clamp(_rotationX, miniMumVert, maxiMumVert);
            float rotationY = Input.GetAxis(&quot;Mouse X&quot;) * sensitivityVert+transform.localEulerAngles.y;
            transform.localEulerAngles = new Vector3(_rotationX,rotationY,0);
        }
    }
}
</code></pre>
<h4 id="messenger">Messenger</h4>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
 
public enum MessengerMode {
    DONT_REQUIRE_LISTENER,
    REQUIRE_LISTENER,
}
 
static internal class MessengerInternal {
    readonly public static Dictionary&lt;string, Delegate&gt; eventTable = new Dictionary&lt;string, Delegate&gt;();
    static public MessengerMode DEFAULT_MODE = MessengerMode.REQUIRE_LISTENER;
 
    static public void AddListener(string eventType, Delegate callback) {
        MessengerInternal.OnListenerAdding(eventType, callback);
        eventTable[eventType] = Delegate.Combine(eventTable[eventType], callback);
    }
 
    static public void RemoveListener(string eventType, Delegate handler) {
        MessengerInternal.OnListenerRemoving(eventType, handler);   
        eventTable[eventType] = Delegate.Remove(eventTable[eventType], handler);
        MessengerInternal.OnListenerRemoved(eventType);
    }
 
    static public T[] GetInvocationList&lt;T&gt;(string eventType) {
        Delegate d;
        if(eventTable.TryGetValue(eventType, out d)) {
            try {
                return d.GetInvocationList().Cast&lt;T&gt;().ToArray();
            } catch {
                throw MessengerInternal.CreateBroadcastSignatureException(eventType);
            }
        }
        return new T[0];
    }
 
    static public void OnListenerAdding(string eventType, Delegate listenerBeingAdded) {
        if (!eventTable.ContainsKey(eventType)) {
            eventTable.Add(eventType, null);
        }
 
        var d = eventTable[eventType];
        if (d != null &amp;&amp; d.GetType() != listenerBeingAdded.GetType()) {
            throw new ListenerException(string.Format(&quot;Attempting to add listener with inconsistent signature for event type {0}. Current listeners have type {1} and listener being added has type {2}&quot;, eventType, d.GetType().Name, listenerBeingAdded.GetType().Name));
        }
    }
 
    static public void OnListenerRemoving(string eventType, Delegate listenerBeingRemoved) {
        if (eventTable.ContainsKey(eventType)) {
            var d = eventTable[eventType];
 
            if (d == null) {
                throw new ListenerException(string.Format(&quot;Attempting to remove listener with for event type {0} but current listener is null.&quot;, eventType));
            } else if (d.GetType() != listenerBeingRemoved.GetType()) {
                throw new ListenerException(string.Format(&quot;Attempting to remove listener with inconsistent signature for event type {0}. Current listeners have type {1} and listener being removed has type {2}&quot;, eventType, d.GetType().Name, listenerBeingRemoved.GetType().Name));
            }
        } else {
            throw new ListenerException(string.Format(&quot;Attempting to remove listener for type {0} but Messenger doesn't know about this event type.&quot;, eventType));
        }
    }
 
    static public void OnListenerRemoved(string eventType) {
        if (eventTable[eventType] == null) {
            eventTable.Remove(eventType);
        }
    }
 
    static public void OnBroadcasting(string eventType, MessengerMode mode) {
        if (mode == MessengerMode.REQUIRE_LISTENER &amp;&amp; !eventTable.ContainsKey(eventType)) {
            throw new MessengerInternal.BroadcastException(string.Format(&quot;Broadcasting message {0} but no listener found.&quot;, eventType));
        }
    }
 
    static public BroadcastException CreateBroadcastSignatureException(string eventType) {
        return new BroadcastException(string.Format(&quot;Broadcasting message {0} but listeners have a different signature than the broadcaster.&quot;, eventType));
    }
 
    public class BroadcastException : Exception {
        public BroadcastException(string msg)
            : base(msg) {
        }
    }
 
    public class ListenerException : Exception {
        public ListenerException(string msg)
            : base(msg) {
        }
    }
}
 
// No parameters
static public class Messenger { 
    static public void AddListener(string eventType, Action handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void AddListener&lt;TReturn&gt;(string eventType, Func&lt;TReturn&gt; handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void RemoveListener(string eventType, Action handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void RemoveListener&lt;TReturn&gt;(string eventType, Func&lt;TReturn&gt; handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void Broadcast(string eventType) {
        Broadcast(eventType, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, Action&lt;TReturn&gt; returnCall) {
        Broadcast(eventType, returnCall, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast(string eventType, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Action&gt;(eventType);
 
        foreach(var callback in invocationList)
            callback.Invoke();
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, Action&lt;TReturn&gt; returnCall, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Func&lt;TReturn&gt;&gt;(eventType);
 
        foreach(var result in invocationList.Select(del =&gt; del.Invoke()).Cast&lt;TReturn&gt;()) {
            returnCall.Invoke(result);
        }
    }
}
 
// One parameter
static public class Messenger&lt;T&gt; {
    static public void AddListener(string eventType, Action&lt;T&gt; handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void AddListener&lt;TReturn&gt;(string eventType, Func&lt;T, TReturn&gt; handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void RemoveListener(string eventType, Action&lt;T&gt; handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void RemoveListener&lt;TReturn&gt;(string eventType, Func&lt;T, TReturn&gt; handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void Broadcast(string eventType, T arg1) {
        Broadcast(eventType, arg1, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, T arg1, Action&lt;TReturn&gt; returnCall) {
        Broadcast(eventType, arg1, returnCall, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast(string eventType, T arg1, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Action&lt;T&gt;&gt;(eventType);
 
        foreach(var callback in invocationList)
            callback.Invoke(arg1);
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, T arg1, Action&lt;TReturn&gt; returnCall, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Func&lt;T, TReturn&gt;&gt;(eventType);
 
        foreach(var result in invocationList.Select(del =&gt; del.Invoke(arg1)).Cast&lt;TReturn&gt;()) {
            returnCall.Invoke(result);
        }
    }
}
 
 
// Two parameters
static public class Messenger&lt;T, U&gt; { 
    static public void AddListener(string eventType, Action&lt;T, U&gt; handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void AddListener&lt;TReturn&gt;(string eventType, Func&lt;T, U, TReturn&gt; handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void RemoveListener(string eventType, Action&lt;T, U&gt; handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void RemoveListener&lt;TReturn&gt;(string eventType, Func&lt;T, U, TReturn&gt; handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void Broadcast(string eventType, T arg1, U arg2) {
        Broadcast(eventType, arg1, arg2, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, T arg1, U arg2, Action&lt;TReturn&gt; returnCall) {
        Broadcast(eventType, arg1, arg2, returnCall, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast(string eventType, T arg1, U arg2, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Action&lt;T, U&gt;&gt;(eventType);
 
        foreach(var callback in invocationList)
            callback.Invoke(arg1, arg2);
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, T arg1, U arg2, Action&lt;TReturn&gt; returnCall, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Func&lt;T, U, TReturn&gt;&gt;(eventType);
 
        foreach(var result in invocationList.Select(del =&gt; del.Invoke(arg1, arg2)).Cast&lt;TReturn&gt;()) {
            returnCall.Invoke(result);
        }
    }
}
 
 
// Three parameters
static public class Messenger&lt;T, U, V&gt; { 
    static public void AddListener(string eventType, Action&lt;T, U, V&gt; handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void AddListener&lt;TReturn&gt;(string eventType, Func&lt;T, U, V, TReturn&gt; handler) {
        MessengerInternal.AddListener(eventType, handler);
    }
 
    static public void RemoveListener(string eventType, Action&lt;T, U, V&gt; handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void RemoveListener&lt;TReturn&gt;(string eventType, Func&lt;T, U, V, TReturn&gt; handler) {
        MessengerInternal.RemoveListener(eventType, handler);
    }
 
    static public void Broadcast(string eventType, T arg1, U arg2, V arg3) {
        Broadcast(eventType, arg1, arg2, arg3, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, T arg1, U arg2, V arg3, Action&lt;TReturn&gt; returnCall) {
        Broadcast(eventType, arg1, arg2, arg3, returnCall, MessengerInternal.DEFAULT_MODE);
    }
 
    static public void Broadcast(string eventType, T arg1, U arg2, V arg3, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Action&lt;T, U, V&gt;&gt;(eventType);
 
        foreach(var callback in invocationList)
            callback.Invoke(arg1, arg2, arg3);
    }
 
    static public void Broadcast&lt;TReturn&gt;(string eventType, T arg1, U arg2, V arg3, Action&lt;TReturn&gt; returnCall, MessengerMode mode) {
        MessengerInternal.OnBroadcasting(eventType, mode);
        var invocationList = MessengerInternal.GetInvocationList&lt;Func&lt;T, U, V, TReturn&gt;&gt;(eventType);
 
        foreach(var result in invocationList.Select(del =&gt; del.Invoke(arg1, arg2, arg3)).Cast&lt;TReturn&gt;()) {
            returnCall.Invoke(result);
        }
    }
}
</code></pre>
<h4 id="playable">Playable</h4>
<pre><code>//---------------------------------------------------
//-----------------------播放动画-------------------
public class PlayAnimation : MonoBehaviour
{
    public AnimationClip AnimationClip1;
    public AnimationClip AnimationClip2;

    private PlayableGraph m_PlayableGraph;
    private void OnGUI()
    {
        if (GUILayout.Button(&quot;&lt;size=80&gt;play clips1&lt;/size&gt;&quot;))
        {
            AnimationPlayableUtilities.PlayClip(GetComponent&lt;Animator&gt;(),AnimationClip1,out m_PlayableGraph);
        }
        if (GUILayout.Button(&quot;&lt;size=80&gt;play clips2&lt;/size&gt;&quot;))
        {
            AnimationPlayableUtilities.PlayClip(GetComponent&lt;Animator&gt;(),AnimationClip2,out m_PlayableGraph);
        }
    }

    private void OnDisable()
    {
        m_PlayableGraph.Destroy();
    }
}
//---------------------------------------------------
//---------------------PlayableAssets--------------
//自定义timeline assets
[Serializable]
public class CustomPlayableAssets : PlayableAsset
{
    public ExposedReference&lt;GameObject&gt; ExposedReference;
    public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
    {
        CustomPlayableBehaviour behaviour = new CustomPlayableBehaviour();
        behaviour.eposedObjectValue = ExposedReference.Resolve(graph.GetResolver());
        return ScriptPlayable&lt;CustomPlayableBehaviour&gt;.Create(graph, behaviour);
    }
}

//自定义timeline behaviour
public class CustomPlayableBehaviour : PlayableBehaviour
{
    //graphStart&gt;&gt;BehaviourPause&gt;&gt;BehaviourStart&gt;&gt;BehaviourPause&gt;&gt;graphStop
    //接收序列化对象
    public GameObject eposedObjectValue;

    //graph开始运行时调用
    public override void OnGraphStart(Playable playable)
    {
        base.OnGraphStart(playable);
    }
    //graph结束时调用
    public override void OnGraphStop(Playable playable)
    {
        base.OnGraphStop(playable);
    }
    //playable播放时调用
    public override void OnBehaviourPlay(Playable playable, FrameData info)
    {
        base.OnBehaviourPlay(playable, info);
    }
    //playable暂停时调用
    public override void OnBehaviourPause(Playable playable, FrameData info)
    {
        base.OnBehaviourPause(playable, info);
    }
    //每帧调用
    public override void PrepareFrame(Playable playable, FrameData info)
    {
        //可能此时还没绑定对象，所以需要判空
        if (eposedObjectValue != null)
        {
            PlayableDirector director = playable.GetGraph&lt;Playable&gt;().GetResolver() as PlayableDirector;
            Debug.LogFormat(&quot;PlayableDirector:{0},eposedObjectValue:{1}&quot;,director.gameObject.name,eposedObjectValue.name);
        }
    }
}
//---------------------------------------------------
//-----------------------自定义track----------------
[TrackColor(1f,0f,0f)]
[TrackClipType(typeof(CustomPlayableAssets))]
[TrackBindingType(typeof(CustomTrack))]
public class CustomTrack : TrackAsset
{
    protected override Playable CreatePlayable(PlayableGraph graph, GameObject gameObject, TimelineClip clip)
    {
        return base.CreatePlayable(graph, gameObject, clip);
    }

    public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
    {
        return base.CreateTrackMixer(graph, go, inputCount);
    }
}

//---------------------------------------------------
//-----------------------动画融合-------------------
public class CustomPlayMixer : MonoBehaviour
{
    public AnimationClip AnimationClip1;
    public AnimationClip AnimationClip2;
    public float weight;
    private PlayableGraph m_PlayableGraph;
    private AnimationMixerPlayable m_AnimationMixerPlayable;
    private void Start()
    {
        m_AnimationMixerPlayable =
            AnimationPlayableUtilities.PlayMixer(GetComponent&lt;Animator&gt;(), 2, out m_PlayableGraph);
        AnimationClipPlayable clipPlayable1 = AnimationClipPlayable.Create(m_PlayableGraph,AnimationClip1);
        AnimationClipPlayable clipPlayable2 = AnimationClipPlayable.Create(m_PlayableGraph,AnimationClip2);
        m_PlayableGraph.Connect(clipPlayable1, 0, m_AnimationMixerPlayable, 0);
        m_PlayableGraph.Connect(clipPlayable2, 0, m_AnimationMixerPlayable, 1);
        AnimationPlayableOutput output = AnimationPlayableOutput.Create(m_PlayableGraph,&quot;AnimationOutput&quot;,GetComponent&lt;Animator&gt;());
        output.SetSourcePlayable(m_AnimationMixerPlayable);
        m_AnimationMixerPlayable.Play();
    }
    private void Update()
    {
        weight = Mathf.Clamp01(weight);
        m_AnimationMixerPlayable.SetInputWeight(0,1-weight);
        m_AnimationMixerPlayable.SetInputWeight(1,weight);
    }
    private void OnDestroy()
    {
        m_PlayableGraph.Destroy();
    }
}
//---------------------------------------------------
//-------------------------音频融合-----------------
public class AudioMixer : MonoBehaviour
{
    public AudioClip m_AudioClip1;
    public AudioClip m_AudioClip2;
    public float weight;
    private PlayableGraph m_PlayableGraph;
    public AudioMixerPlayable m_AudioMixerPlayable;
    private void Start()
    {
        m_PlayableGraph = PlayableGraph.Create();
        m_AudioMixerPlayable = AudioMixerPlayable.Create(m_PlayableGraph,2);
        var audioClipPlayable1 = AudioClipPlayable.Create(m_PlayableGraph, m_AudioClip1, true);
        var audioClipPlayable2 = AudioClipPlayable.Create(m_PlayableGraph, m_AudioClip2, true);
        m_PlayableGraph.Connect(audioClipPlayable1,0,m_AudioMixerPlayable,0);
        m_PlayableGraph.Connect(audioClipPlayable2,0,m_AudioMixerPlayable,1);
        var audioPlayableOutput = AudioPlayableOutput.Create(m_PlayableGraph, &quot;Audio&quot;, GetComponent&lt;AudioSource&gt;());
        audioPlayableOutput.SetSourcePlayable(m_AudioMixerPlayable);
        m_AudioMixerPlayable.Play();
    }
    private void Update()
    {
        weight = Mathf.Clamp01(weight);
        m_AudioMixerPlayable.SetInputWeight(0,1-weight);
        m_AudioMixerPlayable.SetInputWeight(1,weight);
    }

    private void OnDisable()
    {
        m_PlayableGraph.Destroy();
    }
}
//---------------------------------------------------
//-------------------------速度控制-----------------
public class MovingSphere : MonoBehaviour
{
    // Update is called once per frame
    [SerializeField, Range(0f, 100f)] private float max_Speed = 10f;
    [SerializeField, Range(0f, 100f)] private float max_Acceleration = 10f;
    [SerializeField]Rect allowedArea = new Rect(-5,-5,10,10);
    private float boundFactor = 0.7f;
    private Vector3 velocity;
    void Update()
    {
        Vector2 playerInput;
        playerInput.x = Input.GetAxis(&quot;Horizontal&quot;);
        playerInput.y = Input.GetAxis(&quot;Vertical&quot;);
        playerInput = Vector2.ClampMagnitude(playerInput, 1f);
        
        Vector3 desiredVelocity = new Vector3(playerInput.x,0f,playerInput.y)*max_Speed;
        float maxSpeedChange = max_Acceleration * Time.deltaTime;
        
        velocity.x = Mathf.MoveTowards(velocity.x, desiredVelocity.x, maxSpeedChange);
        velocity.z = Mathf.MoveTowards(velocity.z, desiredVelocity.z, maxSpeedChange);
        
        Vector3 displacement = velocity * Time.deltaTime;
        Vector3 targetPosition = transform.localPosition + displacement;
        if (targetPosition.x &lt; allowedArea.xMin)
        {
            targetPosition.x = allowedArea.xMin;
            velocity.x = -velocity.x*boundFactor;
        }else if (targetPosition.x &gt; allowedArea.xMax)
        {
            targetPosition.x = allowedArea.xMax;
            velocity.x = -velocity.x*boundFactor;
        }        
        if (targetPosition.z &lt; allowedArea.yMin)
        {
            targetPosition.z = allowedArea.yMin;
            velocity.z = -velocity.z*boundFactor;
        }else if (targetPosition.z &gt; allowedArea.yMax)
        {
            targetPosition.z = allowedArea.yMax;
            velocity.z = -velocity.z*boundFactor;
        }

        transform.localPosition = targetPosition;
    }
}
//---------------------------------------------------
//--------------------------TPS---------------------
//ThirdPersonCharacterControl
public class ThirdPersonCharacterControl : MonoBehaviour
{
    public float Speed;
    void Update (){
        PlayerMovement();
    }
    void PlayerMovement(){
        float hor = Input.GetAxis(&quot;Horizontal&quot;);
        float ver = Input.GetAxis(&quot;Vertical&quot;);
        Vector3 playerMovement = new Vector3(hor, 0f, ver) * Speed * Time.deltaTime;
        transform.Translate(playerMovement, Space.Self);
    }
}
//ThirdPersonCameraControl
public class ThirdPersonCameraControl : MonoBehaviour{
    float rotationSpeed = 1;
    public Transform Target, Player;
    float mouseX, mouseY;
    public Transform Obstruction;
    float zoomSpeed = 2f;
    void Start(){
        Obstruction = Target;
        Cursor.visible = false;
        Cursor.lockState = CursorLockMode.Locked;
    }
    private void LateUpdate(){
        CamControl();
        ViewObstructed();
    }
    void CamControl(){
        mouseX += Input.GetAxis(&quot;Mouse X&quot;) * rotationSpeed;
        mouseY -= Input.GetAxis(&quot;Mouse Y&quot;) * rotationSpeed;
        mouseY = Mathf.Clamp(mouseY, -35, 60);
        transform.LookAt(Target);
        if (Input.GetKey(KeyCode.LeftShift)){
            Target.rotation = Quaternion.Euler(mouseY, mouseX, 0);
        }
        else{
            Target.rotation = Quaternion.Euler(mouseY, mouseX, 0);
            Player.rotation = Quaternion.Euler(0, mouseX, 0);
        }
    }
    void ViewObstructed(){
        RaycastHit hit;
        if (Physics.Raycast(transform.position, Target.position - transform.position, out hit, 4.5f)){
            if (hit.collider.gameObject.tag != &quot;Player&quot;){
                Obstruction = hit.transform;
                Obstruction.gameObject.GetComponent&lt;MeshRenderer&gt;().shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.ShadowsOnly;
                if(Vector3.Distance(Obstruction.position, transform.position) &gt;= 3f &amp;&amp; Vector3.Distance(transform.position, Target.position) &gt;= 1.5f)
                    transform.Translate(Vector3.forward * zoomSpeed * Time.deltaTime);
            }
            else{
                Obstruction.gameObject.GetComponent&lt;MeshRenderer&gt;().shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.On;
                if (Vector3.Distance(transform.position, Target.position) &lt; 4.5f)
                    transform.Translate(Vector3.back * zoomSpeed * Time.deltaTime);
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#]]></title>
        <id>https://sunxiaohang.github.io/post/c/</id>
        <link href="https://sunxiaohang.github.io/post/c/">
        </link>
        <updated>2020-04-06T11:52:42.000Z</updated>
        <summary type="html"><![CDATA[<p>C#关键知识点总结，主要针对一些新特性和泛型，和C#事件系统，主要针对Unity3d，非标准C#</p>
]]></summary>
        <content type="html"><![CDATA[<p>C#关键知识点总结，主要针对一些新特性和泛型，和C#事件系统，主要针对Unity3d，非标准C#</p>
<!-- more -->
<h4 id="泛型委托">泛型委托</h4>
<pre><code>delegate void Del&lt;T&gt;(T item);
public static void Notify(int i) { }
...
Del&lt;int&gt; m1 = new Del&lt;int&gt;(Notify);
//Del&lt;int&gt; m2 = Notify;

//在泛型类中定义的委托可以用类方法使用的相同方式来使用泛型类类型参数
class Stack&lt;T&gt;
{
	T[] items;
	int index;
	public delegate void StackDelegate(T[] items);
}//引用委托的代码必须指定包含类的类型参数
class Instance
{
	private static void DoWork(float[] items){}
public static void TestStatck()
{
Stack&lt;float&gt; s = new Stack&lt;float&gt;();
Stack&lt;float&gt;.StackDelegate d = DoWork;
}
}

//常用事件发布订阅系统
public class PublicSubscribeManager
{
 //定义发布消息体extends EventArgs
 public class MessageBox : System.EventArgs{ public MessageBox(string subject, string content){}}
 //定义代理 parameter(object sender,SubEventArgs message)
 public delegate void PublishEventHandler(object sender, MessageBox message);
 //定义event DelegateType eventVariable;
 public event PublishEventHandler Publish;
 //定义执行函数
 protected virtual void OnPublished(MessageBox message){if (Publish != null)Publish(this,message);}
	public void Trigger(string subject,string content){OnPublished(new MessageBox(subject,content));}
}
class MainClass
{
 static void Main()
 {
  	PublicSubscribeManager manager = new PublicSubscribeManager();
  	manager.Publish += new PublicSubscribeManager.PublishEventHandler((sender,message)=&gt; { Console.WriteLine(&quot;{sender},{message}&quot;);});
  	manager.Trigger(&quot;_subject&quot;, &quot;_content&quot;);
 }
}
</code></pre>
<h4 id="特性解析">特性解析</h4>
<pre><code>Type type = typeof(class);
object[] XXX = type.GetXXX();
for(XX x int XXX)x.reduce();
---------------------------
System.Reflection.MemberInfo info = type.getMember(Type.MemberName);
System.Reflection.MethodInfo info = type.GetMethod(Type.MethodName);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity3D]]></title>
        <id>https://sunxiaohang.github.io/post/unity3d/</id>
        <link href="https://sunxiaohang.github.io/post/unity3d/">
        </link>
        <updated>2020-04-06T11:49:39.000Z</updated>
        <summary type="html"><![CDATA[<p>Unity3D项目关键知识点汇总，方便后期复习巩固，包括关键的monobehaviour生命周期，协程，工作线程，相机相关，涉嫌投射，对象池化技术等线管笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>Unity3D项目关键知识点汇总，方便后期复习巩固，包括关键的monobehaviour生命周期，协程，工作线程，相机相关，涉嫌投射，对象池化技术等线管笔记</p>
<!-- more -->
<h4 id="unity-基础类图">Unity 基础类图</h4>
<figure data-type="image" tabindex="1"><img src="https://sunxiaohang.github.io/post-images/1586173848463.png" alt="" loading="lazy"></figure>
<h4 id="unity生命周期">Unity生命周期</h4>
<figure data-type="image" tabindex="2"><img src="https://sunxiaohang.github.io/post-images/1586173894549.png" alt="" loading="lazy"></figure>
<h4 id="camera">Camera</h4>
<pre><code>//-----------------------------------------------------
//-------------------通过相机的切换来实现场景的切换
/////渲染画中画(多相机){如：赛车游戏的后视镜，小地图}
/////高depth相机的画面会覆盖低depth相机画面
/////推拉变焦是摄像机同时向目标对象移动并将其缩小的视觉效果(对象大小看起来大致相同，从而达到改变其他对象视角的目的)
void Start(){
    distance = Vector3.Distance(transform.position,target.position);
    heightAtDistance = FrustumHeightAtDistance(distance);
    EnabledE();
}
void Update(){
    var distance = Vector3.Distance(transform.position,target.position);
    Camera.fieldOfView = FovForHeightAtDistance(initialDistance,CurrentDistance);
}
//----------------------------------------------------------
//------------------------射线投射-------------------------
void Start(){
    RayCastHit hit;
    //Camera.ViewPortPointToRay(0..1)坐标[0表示左下，1表示右上]
    Ray ray = Camera.ScreenPointToRay(Input.mousePosition);
    if(Physics.RayCast(ray,out hit)){
        Transform objectHit =hit.transform;
        //命中 to do
    }
}
//----------------------------------------------------------
//--------------------沿射线移动相机(缩放)----------------
void Update(){
    Ray ray = camera.ScreenPointToRay(Input.mousePOsition);
    float zoomDistance = zoomSpeed*Input.GetAxis(&quot;Vertical&quot;)*Time.deltaTime;
    Camera.tranform.Translate(ray.direction*zoomDistance,Space.world);
}
//----------------------------------------------------------
//---------------------修改斜视锥体pivot------------------
Matrix4*4 mat = Camera.main.projectionMatrix;
mat[0,2] = horizontalObl;//float(horizontal) 水平倾斜量 &lt;&quot;+&quot;&gt;向上
mat[1,2] = VerticalObl;//float(vertical) 垂直倾斜量 &lt;&quot;-&quot;&gt;向下
Camera.main.projectionMatrix = mat;
</code></pre>
<h4 id="pool">Pool</h4>
<pre><code>//----------------------------------------------------------
//---------------------game object pool------------------
public class ObjectPool : MonoBehaviour
{
   public static ObjectPool instance;
   public GameObject[] objectPrefabs;
   public List&lt;GameObject&gt;[] pooledObjects;
   public int[] amountToBuffer;
   public int defaultBufferAmount = 3;
   protected GameObject containerObject;
   void Awake (){instance = this;}
   void Start (){
       containerObject = new GameObject(&quot;ObjectPool&quot;);
       pooledObjects = new List&lt;GameObject&gt;[objectPrefabs.Length];
       int i = 0;
       foreach ( GameObject objectPrefab in objectPrefabs ){
           pooledObjects[i] = new List&lt;GameObject&gt;();  
           int bufferAmount;
           if(i &lt; amountToBuffer.Length) bufferAmount = amountToBuffer[i];
           else bufferAmount = defaultBufferAmount;
           for ( int n=0; n&lt;bufferAmount; n++){
               GameObject newObj = Instantiate(objectPrefab) as GameObject;
               newObj.name = objectPrefab.name;
               PoolObject(newObj);
           }
           i++;
       }
   }
   public GameObject GetObjectForType ( string objectType , bool onlyPooled ){
       for(int i=0; i&lt;objectPrefabs.Length; i++){
           GameObject prefab = objectPrefabs[i];
           if(prefab.name == objectType){
               if(pooledObjects[i].Count &gt; 0){
                   GameObject pooledObject = pooledObjects[i][0];
                   pooledObjects[i].RemoveAt(0);
                   pooledObject.transform.parent = null;
                   pooledObject.SetActiveRecursively(true);
                   return pooledObject;
               } else if(!onlyPooled) {
                   return Instantiate(objectPrefabs[i]) as GameObject;
               }
               break;
           }
       }
       return null;
   }
   public void PoolObject ( GameObject obj ){
       for ( int i=0; i&lt;objectPrefabs.Length; i++){
           if(objectPrefabs[i].name == obj.name){
               obj.SetActiveRecursively(false);
               obj.transform.parent = containerObject.transform;
               pooledObjects[i].Add(obj);
               return;
           }
       }
   }
}
//----------------------------------------------------------
//--------------------------effect pool--------------------
public class Effect : MonoBehaviour{
   public ParticleEmitter[] emitters;
   public float effectLength = 1f;
   public bool poolAfterComplete = true;
   public virtual void ResetEffect (){
       if(poolAfterComplete){
           ObjectPool.instance.PoolObject(gameObject);
       } else {
           Destroy(gameObject);
       }
   }
   public virtual void StartEffect (){
       foreach ( ParticleEmitter emitter in emitters ){
           emitter.Emit();
       }
       StartCoroutine(WaitForCompletion());
   }
   public IEnumerator WaitForCompletion (){
       yield return new WaitForSeconds(effectLength);
       ResetEffect();  
   }
}
//----------------------------------------------------------
//--------------------------sound pool--------------------
public class SoundEffect : MonoBehaviour{
   public AudioSource soundSource;
   public AudioClip[] soundClips;
   public float effectLength = 1f;
   public bool poolAfterComplete = true;
   public virtual void ResetEffect (){
       if(poolAfterComplete){
           ObjectPool.instance.PoolObject(gameObject);
       } else {
           Destroy(gameObject);
       }
   }
   public virtual void StartEffect (){
       soundSource.PlayOneShot(soundClips[Random.Range(0,soundClips.Length)]);
       StartCoroutine(WaitForCompletion());
   }
   public IEnumerator WaitForCompletion (){
       yield return new WaitForSeconds(effectLength);
       ResetEffect();
   }
}
</code></pre>
<h4 id="点积magnitude">点积（Magnitude）</h4>
<p>Dot Product = Ax<em>Bx+Ay</em>By+Az*Bz<br>
点积可以用于判断一个多边形是面向摄像机还是背向摄像机,(或模拟飞机飞行，通过判断飞机飞行方向与垂直地面方向的夹角判断飞机是上升还是下降)在U，V非零前提下<br>
• 点积为负=&gt;(U,V&gt;90)<br>
• 点积为正=&gt;(U,V&lt;90)<br>
• 点积为零=&gt;(U,V=90)</p>
<h4 id="差积左手定则中指为result方向结果矢量垂直与ab矢量">差积[左手定则]{中指为result方向}(结果矢量垂直与ab矢量)</h4>
<p>Vector2：A<em>B=X1</em>Y2+X2*Y1<br>
Vector3:(yz,zx,xy)<br>
Cx = AyBz-AzBy<br>
Cy = AzBx-AxBz<br>
Cz = AxBy-AyBx<br>
result = (Cx,Cy,Cz)<br>
角动量（当前指向的方向向量a，目标方向的方向向量b）求[叉积]=旋转轴</p>
<h4 id="enable-and-disable-component">Enable and Disable Component</h4>
<p>Component.enable = true|false<br>
控制一个物体是否在屏幕上渲染或显示</p>
<h4 id="active-and-deactivate-component">Active and Deactivate Component</h4>
<p>component.SetActive(false);<br>
控制是否在场景中使用该物体，findObject是否能找到<br>
SetActiveRecursively()控制递归子物体</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[软件工程架构]]></title>
        <id>https://sunxiaohang.github.io/post/ruan-jian-gong-cheng-jia-gou/</id>
        <link href="https://sunxiaohang.github.io/post/ruan-jian-gong-cheng-jia-gou/">
        </link>
        <updated>2020-04-06T11:46:39.000Z</updated>
        <summary type="html"><![CDATA[<p>软件工程架构的一些想法和思路汇总，旨在从模型阶段建立一个相对完善的软件框架</p>
]]></summary>
        <content type="html"><![CDATA[<p>软件工程架构的一些想法和思路汇总，旨在从模型阶段建立一个相对完善的软件框架</p>
<!-- more -->
<h4 id="系统架构">系统架构</h4>
<p>系统架构衡量标准<br>
• 承载力<br>
• 可扩展度<br>
• 易用性<br>
• 可伸缩性<br>
• 容灾力</p>
<h4 id="分层思维">分层思维</h4>
<p>面对复杂的系统，往往需要把各个模块按照一定的规则进行分类分层，模块间各司其职协同工作,把复杂的问题简单化，<img src="https://sunxiaohang.github.io/post-images/1586173649489.png" alt="" loading="lazy"></p>
<h4 id="分治思维divide-and-conquer">分治思维(Divide and conquer)</h4>
<figure data-type="image" tabindex="1"><img src="https://sunxiaohang.github.io/post-images/1586173679513.png" alt="" loading="lazy"></figure>
<h4 id="演化思维">演化思维</h4>
<figure data-type="image" tabindex="2"><img src="https://sunxiaohang.github.io/post-images/1586173718360.png" alt="" loading="lazy"></figure>
<h4 id="数据表">数据表</h4>
<p>• Excel<br>
• 代码数据<br>
• txt<br>
• 比特流数据</p>
<h4 id="性能规范">性能规范</h4>
<h4 id="美术资源规范">美术资源规范</h4>
<p>• 根据运用场景<br>
• 反推计算<br>
• 实际测试</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity3d扩展编辑器]]></title>
        <id>https://sunxiaohang.github.io/post/unity3d-kuo-zhan-bian-ji-qi/</id>
        <link href="https://sunxiaohang.github.io/post/unity3d-kuo-zhan-bian-ji-qi/">
        </link>
        <updated>2020-04-06T11:44:11.000Z</updated>
        <summary type="html"><![CDATA[<p>Unity3D扩展编辑器的一些常规操作，深入浅出，属于读书笔记，参考Unity3D游戏开发</p>
]]></summary>
        <content type="html"><![CDATA[<p>Unity3D扩展编辑器的一些常规操作，深入浅出，属于读书笔记，参考Unity3D游戏开发</p>
<!-- more -->
<h5 id="扩展右键菜单">扩展右键菜单</h5>
<pre><code class="language-c#">//[MenuItem(&quot;Assets/Tools/Debug&quot;,isValidateFunction,priority)]
public class Extension
{
    [MenuItem(&quot;Assets/CustomTools/Debug&quot;,false,2)]
    static void DebugFunction()
    {
        Debug.Log(Selection.activeObject.name);
    }
}
</code></pre>
<h5 id="创建菜单">创建菜单</h5>
<pre><code class="language-c#">//[MenuItem(&quot;Assets/Create/ObjectName&quot;,isValidateFunction,priority)]
public class Extension
{
    [MenuItem(&quot;Assets/Create/Debug&quot;,false,2)]
    static void CreateObjectName()
    {
        GameObject.CreatePrimitive(PrimitiveType.Sphere);
    }
}
</code></pre>
<h5 id="扩展布局">扩展布局</h5>
<pre><code class="language-c#">public class Extension
{
    //表示此方法会在C#代码每次编译完成后首先调用
    [InitializeOnLoadMethod]
    static void Function()
    {
        //监听EditorApplication.projectWindowItemOnGUI委托，即可使用GUI方法来绘制自定义UI元素
        EditorApplication.projectWindowItemOnGUI = delegate(string guid, Rect rect) { 
            //在project视图中选择一个资源
            if (Selection.activeObject &amp;&amp;guid == AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(Selection.activeObject)))
            {
                //设置拓展按钮区域
                float width = 50f;
                rect.x += rect.width - width;
                rect.y += 2f;
                rect.width = width;
                GUI.color = Color.red;
                //点击事件处理的简单写法
                if(GUI.Button(rect,&quot;click&quot;)){
                    Debug.LogFormat(&quot;click:{0}&quot;,Selection.activeObject.name); 
                };
                GUI.color= Color.white;
            }
        };
    }
}
</code></pre>
<h5 id="监听事件">监听事件</h5>
<pre><code class="language-C#">//事件监听需要继承父类UnityEditor.AssetModificationProcessor
public class Extension:UnityEditor.AssetModificationProcessor{
    //全局监听Project视图下的资源是否发生变化
    [InitializeOnLoadMethod]
    static void Function(){
    	EditorApplication.projectChanged += delegate(){Debug.Log(&quot;change&quot;);};
    }
    //监听双击鼠标左键，打开资源事件
    public static bool IsOpenForEdit(string assetPath, out string message){
        return true;//true 表示该资源可以打开，false表示不允许在unity中打开该资源
    }
    //监听资源即将被创建
    private static void OnWillCreateAsset(string assetName){ 
    	Debug.LogFormat(&quot;path:{0}&quot;,assetName);
    }
    //监听资源即将被保存
    private static string[] OnWillSaveAssets(string[] paths){
        if (paths != null)Debug.LogFormat(&quot;path:{0}&quot;,string.Join(&quot;,&quot;,paths));
        return paths;
    }
    //监听资源即将被移动
    private static AssetMoveResult OnWillMoveAsset(string sourcePath, string destinationPath){
        Debug.LogFormat(&quot;from:{0} to {1}&quot;,sourcePath,destinationPath);
        return AssetMoveResult.DidMove;//AssetMoveResult.DidMove表示资源可以移动
    }
    //监听资源即将被删除
    private static AssetDeleteResult OnWillDeleteAsset(string assetPath, RemoveAssetOptions options){
        Debug.LogFormat(&quot;delete:{0}&quot;,assetPath);
        return AssetDeleteResult.DidNotDelete;//表示该资源可以被删除
    }
}
</code></pre>
<h4 id="拓展hierarchy视图">拓展Hierarchy视图</h4>
<h5 id="拓展菜单">拓展菜单</h5>
<pre><code class="language-c#">public class Extension{
    [MenuItem(&quot;GameObject/CustomCreate/Cube&quot;, false, 1)]
    static void CreateCube()
    {
        GameObject.CreatePrimitive(PrimitiveType.Cube);
    }
}
</code></pre>
<h5 id="拓展布局">拓展布局</h5>
<pre><code class="language-C#">public class Extension
{
    [InitializeOnLoadMethod]
    static void InitializeOnLoad()
    {
        EditorApplication.hierarchyWindowItemOnGUI = delegate(int id, Rect rect) {  
            //在hierarchy视图中选择一个资源
            if (Selection.activeObject &amp;&amp; id == Selection.activeObject.GetInstanceID())
            {
                float width = 50f;
                float height = 20f;
                rect.x = rect.width - width;
                rect.width = width;
                rect.height = height;
                if (GUI.Button(rect, AssetDatabase.LoadAssetAtPath&lt;Texture&gt;(&quot;Assets/Unity.png&quot;)))
                {
                    Debug.LogFormat(&quot;click:{0}&quot;,Selection.activeObject.name);
                }
            }
        };
    }
}
</code></pre>
<h5 id="重写菜单">重写菜单</h5>
<pre><code class="language-c#">public class Extension
{
    [InitializeOnLoadMethod]
    static void StartInitializeOnLoadMethod() {
        EditorApplication.hierarchyWindowItemOnGUI += OnHierarchyGUI;
    }
    static void OnHierarchyGUI(int instanceId, Rect selectionRect) {
        if (Event.current != null 
            &amp;&amp; selectionRect.Contains(Event.current.mousePosition)
            &amp;&amp;Event.current.button==1&amp;&amp;Event.current.type&lt;=EventType.MouseUp) {
            GameObject selectedGameObject = EditorUtility.InstanceIDToObject(instanceId) as GameObject;
            if (selectedGameObject) {
                Vector2 mousePosition = Event.current.mousePosition;
                EditorUtility.DisplayPopupMenu(new Rect(mousePosition.x,mousePosition.y,0,0),&quot;Window/Test&quot;,null );
                Event.current.Use();
            }
        }
    }
    [MenuItem(&quot;Window/Test/tools1&quot;)]
    static void Test() {}
    [MenuItem(&quot;Window/Test/tools2&quot;)]
    static void Test1() { }
    [MenuItem(&quot;Window/Test/tools3&quot;)]
    static void Test2() { }
}
</code></pre>
<h4 id="拓展inspector视图">拓展Inspector视图</h4>
<h5 id="拓展原生组件">拓展原生组件</h5>
<pre><code class="language-c#">[CustomEditor(typeof(Camera))]
public class Extension:Editor{
    public override void OnInspectorGUI(){
        if (GUILayout.Button(&quot;extensionButton&quot;)) {/*function*/ }
        base.OnInspectorGUI();
    }
}
</code></pre>
<h5 id="拓展继承组件">拓展继承组件</h5>
<p>Unity将大量的Editor绘制方法封装在内部DLL文件里，开发者无法调用它的方法，只能通过反射的方式调用内部未公开的方法。</p>
<pre><code class="language-C#">[CustomEditor(typeof(Transform))]
public class Extension:Editor{
    private Editor m_Editor;
    private void OnEnable(){
        m_Editor = Editor.CreateEditor(target,     Assembly.GetAssembly(typeof(Editor)).GetType(&quot;UnityEditor.TransformInspector&quot;, true));
    }
    public override void OnInspectorGUI(){
        if (GUILayout.Button(&quot;extensionButton&quot;)) { }
        GUI.enabled = false;//------------开始禁止
        m_Editor.OnInspectorGUI();//调用系统绘制方法
        GUI.enabled = true;//------------结束禁止
        if (GUILayout.Button(&quot;extensionButton2&quot;)) { }
    }
}
</code></pre>
<h5 id="组件不可编辑">组件不可编辑</h5>
<p>HideFlag可以使用按位或(|)同时保持多个属性</p>
<pre><code class="language-c#">GUI.enabled = false;//------------开始禁止
////m_Editor.OnInspectorGUI();//调用系统绘制方法
GUI.enabled = true;//------------结束禁止

//全局锁定与解锁修改
public class Extension{
    [MenuItem(&quot;GameObject/3D Object/Lock/Lock&quot;)]
    static void Lock(){
        if (Selection.gameObjects != null){
            foreach (var gameObject in Selection.gameObjects)       			                       gameObject.hideFlags = HideFlags.NotEditable;
        }
    }
    [MenuItem(&quot;GameObject/3D Object/Lock/Unlock&quot;)]
    static void Unlock(){
        if (Selection.gameObjects != null){
            foreach (var gameObject in Selection.gameObjects) {
                gameObject.hideFlags = HideFlags.None;
            }
        }
    }
}
</code></pre>
<h5 id="context菜单">Context菜单</h5>
<p>Inspector中的组件右键菜单，如果想给所有组件都添加上该菜单<code>Transform</code>&gt;&gt;&gt;<code>Component</code></p>
<pre><code class="language-c#">public class Extension {
    [MenuItem(&quot;CONTEXT/Transform/NewContext1&quot;)]
    static void NewContext1(MenuCommand command) {
        Debug.Log(command.context.name);
    }
}
</code></pre>
<p>该设置也可以用在自己写的脚本中,用于读取和写入组件属性</p>
<pre><code class="language-c#">using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
public class Extension:MonoBehaviour{
    public string contextName;
    #if UNITY_EDITOR
    [MenuItem(&quot;CONTEXT/Extension/NewContext1&quot;)]
    static void NewContext1(MenuCommand command) {
        Extension extension = command.context as Extension;
        if(extension!=null)extension.contextName = &quot;HelloWorld&quot;;
    }
    #endif
}
//#if UNITY_EDITOR     #endif只会在Editor模式下执行，发布后会被剔除
</code></pre>
<p>如果自定义菜单和系统菜单项目重名，还可以覆盖</p>
<pre><code class="language-c#">[ContextMenu(&quot;Remove Component&quot;)]
void RemoveComponent(){
    Debug.Log(&quot;RemoveComponent&quot;);
    //等一会在删除自己
    UnityEditor.EditorApplication.delayCall = delegate(){DestoryImmediate(this);};
}
</code></pre>
<h4 id="拓展scene视图">拓展Scene视图</h4>
<h5 id="辅助元素该类不在editor目录下">辅助元素（该类不在Editor目录下）</h5>
<pre><code class="language-c#">public class Extension:MonoBehaviour{
    private void OnDrawGizmosSelected(){
        Gizmos.color = Color.red;
        Gizmos.DrawLine(transform.position,Vector3.zero);
        Gizmos.DrawCube(Vector3.zero, Vector3.one);
        //其他Gizmos.function()
    }
    //辅助元素不依赖选择对象出现(始终显示zaiScene视图中)
    private void OnDrawGizmos(){
        Gizmos.DrawSphere(transform.position,1);
    }
}
</code></pre>
<h5 id="辅助ui">辅助UI</h5>
<p>在Scene中我们可以添加EditorGUI，方便在视图中处理一些操作。EditorGUI的代码需要在**Handles.BeginGUI()<strong>和</strong>Handles.EndGUI()**中间绘制完成。</p>
<pre><code class="language-c#">[CustomEditor(typeof(Camera))]
public class Extension:Editor{
    private void OnSceneGUI(){
        Camera camera = target as Camera;
        if (camera != null){
            Handles.color = Color.red;
         Handles.Label(camera.transform.position,camera.transform.position.ToString());
            Handles.BeginGUI();
            GUI.backgroundColor = Color.red;
            if (GUILayout.Button(&quot;click&quot;, GUILayout.Width(200f))){
                Debug.LogFormat(&quot;click={0}&quot;,camera.name);
            }
            GUILayout.Label(&quot;Label&quot;);
            Handles.EndGUI();
        }
    }
}
</code></pre>
<h5 id="常驻辅助ui">常驻辅助UI</h5>
<pre><code class="language-c#">public class Extension{
    [InitializeOnLoadMethod]
    static void InitializeOnLoadMethod(){
        SceneView.duringSceneGui += delegate(SceneView sceneView){
            Handles.BeginGUI();
            GUI.Label(new Rect(0,0,50,15),&quot;title&quot; );
            GUI.Button(new Rect(0, 20, 50, 50)
                , AssetDatabase.GetBuiltinExtraResource&lt;Texture&gt;(&quot;Assets/unity.png&quot;));
            Handles.EndGUI();
        };
    }
}
</code></pre>
<h5 id="禁用选中对象">禁用选中对象</h5>
<pre><code class="language-c#">public class Extension{
    [InitializeOnLoadMethod]
    static void InitializeOnLoadMethod(){
        SceneView.duringSceneGui += delegate(SceneView sceneView){
            Event e = Event.current;
            if (e != null){
                //获取它的controllID后，即可禁止将点击事件穿透下去
                //表示禁止接收控制焦点
                int controlID = GUIUtility.GetControlID(FocusType.Passive);
                if (e.type == EventType.Layout){
                    HandleUtility.AddDefaultControl(controlID);
                }
            }
        };
    }
}
</code></pre>
<h4 id="拓展game视图">拓展Game视图</h4>
<p>Game视图拓展分**1.<strong>运行模式</strong>2.**非运行模式</p>
<pre><code class="language-C#">#if UNITY_EDITOR
[ExecuteInEditMode]//非运行模式下也会执行代码的生命周期
public class Extension:MonoBehaviour{
    void OnGUI(){
        if(GUILayout.Button(&quot;Click&quot;)){
            Debug.Log(&quot;Click!&quot;);
        }
        GUILayout.Label(&quot;HelloWorld&quot;);
    }
}
#endif
</code></pre>
<h4 id="menuitem菜单">MenuItem菜单</h4>
<h5 id="覆盖系统菜单">覆盖系统菜单</h5>
<pre><code class="language-c#">[MenuItem(&quot;GameObject/UI/Text&quot;)]
static void CreateNewText(){
    //todo
}
</code></pre>
<h5 id="自定义菜单">自定义菜单</h5>
<pre><code class="language-c#">[MenuItem(&quot;Root/TestCheck&quot;,false,1)]
static void checkFunction() {
    var menuPath = &quot;Root/TestCheck&quot;;
    bool m_Checked = Menu.GetChecked(menuPath);
    Menu.SetChecked(menuPath,!m_Checked);
}
[MenuItem(&quot;Root/TestGray&quot;)]
static void grayFunction() { }
[MenuItem(&quot;Root/TestGray&quot;,true,20)]
static bool grayFunctionValidate() {
    return false;//false表示置灰，不可点击
}
</code></pre>
<h4 id="面板拓展">面板拓展</h4>
<h5 id="inspector面板">Inspector面板</h5>
<pre><code class="language-C#">#if UNITY_EDITOR
using UnityEditor;
#endif
using UnityEditor.Experimental.TerrainAPI;
using UnityEngine;

#if UNITY_EDITOR
[CustomEditor(typeof(PoJo))]
public class Extension:Editor
{
    private bool m_EnableToogle;
    public override void OnInspectorGUI()
    {
        PoJo poJo = target as PoJo;
        poJo.scrollPos = EditorGUILayout.BeginScrollView(poJo.scrollPos, false, true);
        poJo.myName = EditorGUILayout.TextField(&quot;text&quot;, poJo.myName);
        poJo.myId = EditorGUILayout.IntField(&quot;int&quot;, poJo.myId);

        poJo.prefab = EditorGUILayout.ObjectField(&quot;GameObject&quot;, poJo.prefab,typeof(GameObject),true)as GameObject;
        //绘制按钮
        EditorGUILayout.BeginHorizontal();
        GUILayout.Button(&quot;1&quot;);
        GUILayout.Button(&quot;2&quot;);
        poJo.myEnum = (PoJo.MyEnum) EditorGUILayout.EnumPopup(&quot;MyEnum:&quot;, poJo.myEnum);
        EditorGUILayout.EndHorizontal();
        
        //toogle component
        m_EnableToogle = EditorGUILayout.BeginToggleGroup(&quot;EnableToogle&quot;, m_EnableToogle);
        poJo.toogle1 = EditorGUILayout.Toggle(&quot;toogle1&quot;, poJo.toogle1);
        poJo.toogle2 = EditorGUILayout.Toggle(&quot;toogle2&quot;, poJo.toogle2);
        EditorGUILayout.EndToggleGroup();
        EditorGUILayout.EndScrollView();
    }
}
#endif
</code></pre>
<h5 id="编辑器窗口editor-window">编辑器窗口Editor Window</h5>
<pre><code class="language-c#">public class CustomWindow:EditorWindow,IHasCustomMenu
{
    [MenuItem(&quot;Window/CustomWindow&quot;)]
    static void Init(){
        CustomWindow window = (CustomWindow) EditorWindow.GetWindow(typeof(CustomWindow));
        window.Show();
    }
    private Texture m_MyTexture = null;
    private float m_MyFloat = 0.5f;
    private void Awake(){
        Debug.LogFormat(&quot;窗口初始化调用&quot;);
        m_MyTexture = AssetDatabase.LoadAssetAtPath&lt;Texture&gt;(&quot;Assets/unity.png&quot;);
    }
    private void OnGUI(){
        GUILayout.Label(&quot;HelloWorld&quot;,EditorStyles.boldLabel);
        m_MyFloat = EditorGUILayout.Slider(&quot;Slide&quot;, m_MyFloat, -5, 5);
        GUI.DrawTexture(new Rect(0,30,100,100),m_MyTexture);
    }
    private void OnDestroy(){/*销毁时调用*/}
    private void OnFocus(){/*拥有焦点时调用*/}
    private void OnHierarchyChange(){/*hierarchy视图发生变化时调用*/}
    private void OnInspectorUpdate(){/*Inspector每帧更新*/}
    private void OnLostFocus(){ /*失去焦点时调用*/}
    private void OnProjectChange(){/*Project视图发生变化时调用*/}
    private void OnSelectionChange(){/*在hierarchy或project视图中选择一个对象时调用*/}
    private void Update(){/*每帧调用*/}
    public void AddItemsToMenu(GenericMenu menu){
        menu.AddDisabledItem(new GUIContent(&quot;Disable&quot;));
        menu.AddItem(new GUIContent(&quot;Test1&quot;),true, () =&gt;{/*todo*/});
        menu.AddSeparator(&quot;Test/&quot;);
        menu.AddItem(new GUIContent(&quot;Test/Test3&quot;),true, () =&gt; { });
    }
}
</code></pre>
<h4 id="自定义导入类型">自定义导入类型</h4>
<pre><code class="language-c#">[ScriptedImporter(1,&quot;custom&quot;)]
public class ImportListener : ScriptedImporter{
    public override void OnImportAsset(AssetImportContext ctx){
        var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
        var position = JsonUtility.FromJson&lt;Vector3&gt;(File.ReadAllText(ctx.assetPath));
        cube.transform.position = position;
        cube.transform.localScale = Vector3.one;
        ctx.AddObjectToAsset(&quot;obj&quot;,cube);
        ctx.SetMainObject(cube);
        //添加材质
        var material = new Material(Shader.Find(&quot;Standard&quot;));
        material.color = Color.red;
        ctx.AddObjectToAsset(&quot;material&quot;,material);
        var tempMesh = new Mesh();
        DestroyImmediate(tempMesh);
    }
}
</code></pre>
<h3 id="游戏脚本">游戏脚本</h3>
<h5 id="脚本序列化">脚本序列化</h5>
<pre><code class="language-c#">#if UNITY_EDITOR
[CustomEditor(typeof(SerializedClass))]
public class ScriptInspector : Editor{
    public override void OnInspectorGUI(){
        serializedObject.Update();//更新最新数据
        EditorGUI.BeginChangeCheck();//标记检查
        SerializedProperty property = serializedObject.FindProperty(&quot;id&quot;);//获取数据信息
        property.intValue = EditorGUILayout.IntField(&quot;主键&quot;, property.intValue);//保存数据
        property = serializedObject.FindProperty(&quot;name&quot;);
        property.stringValue = EditorGUILayout.TextField(&quot;姓名&quot;, property.stringValue);
        property = serializedObject.FindProperty(&quot;prefab&quot;);
        property.objectReferenceValue = EditorGUILayout.ObjectField(&quot;游戏对象&quot;,property.objectReferenceValue,typeof(GameObject),true);
        EditorGUILayout.PropertyField(serializedObject.FindProperty(&quot;targets&quot;), true);
        //标记检查发生变化
        if (EditorGUI.EndChangeCheck());//标记检查发生变化
        if (GUI.changed);//判断面板元素变化
        //保存全部数据
        serializedObject.ApplyModifiedProperties();
    }
}
#endif
</code></pre>
<h5 id="序列化反序列化">序列化反序列化</h5>
<pre><code class="language-c#">public class SerializedClass:MonoBehaviour,ISerializationCallbackReceiver{
    [SerializeField] private List&lt;Sprite&gt; m_Values = new List&lt;Sprite&gt;();
    [SerializeField]private List&lt;string&gt; m_Keys = new List&lt;string&gt;();
    public Dictionary&lt;string, Sprite&gt; m_SpriteDic = new Dictionary&lt;string, Sprite&gt;();
    public void OnBeforeSerialize(){
        m_Keys.Clear();
        m_Values.Clear();
        foreach (KeyValuePair&lt;string,Sprite&gt; pair in m_SpriteDic){
            m_Keys.Add(pair.Key);
            m_Values.Add(pair.Value);
        }
    }
    public void OnAfterDeserialize(){
        m_SpriteDic.Clear();
        for (int i = 0; i &lt; m_Keys.Count; i++){
            m_SpriteDic[m_Keys[i]] = m_Values[i];
        }
    }
}

#if UNITY_EDITOR
[CustomEditor(typeof(SerializedClass))]
public class Extension:Editor{
    public override void OnInspectorGUI(){
        serializedObject.Update();
        SerializedProperty propertyKey = serializedObject.FindProperty(&quot;m_Keys&quot;);
        SerializedProperty propertyValue = serializedObject.FindProperty(&quot;m_Values&quot;);
        GUILayout.BeginVertical();
        for (int i = 0; i &lt; propertyKey.arraySize; i++){
            GUILayout.BeginHorizontal();
            SerializedProperty key = propertyKey.GetArrayElementAtIndex(i);
            SerializedProperty value = propertyValue.GetArrayElementAtIndex(i);
            key.stringValue = EditorGUILayout.TextField(&quot;Key&quot;, key.stringValue);
            value.objectReferenceValue =
                EditorGUILayout.ObjectField(&quot;Value&quot;, value.objectReferenceValue, typeof(Sprite),false);
            GUILayout.EndHorizontal();
        }
        GUILayout.EndVertical();
        GUILayout.BeginHorizontal();
        if (GUILayout.Button(&quot;+&quot;)){
            (target as SerializedClass).m_SpriteDic[propertyKey.arraySize.ToString()] = null;
        }
        GUILayout.EndHorizontal();
        serializedObject.ApplyModifiedProperties();
    }
}
#endif
</code></pre>
<h5 id="scriptable-object">Scriptable Object</h5>
<pre><code class="language-C#">//菜单点击生成
[CreateAssetMenu]
public class Displayer : ScriptableObject{
    [SerializeField] public List&lt;DisplayerInfo&gt; m_DisplayerInfo;
    [Serializable]public class DisplayerInfo{
        public int id;
        public string name;
    }
}
public class DisplayerReader : MonoBehaviour{
    private void Start(){
        Displayer display = Resources.Load&lt;Displayer&gt;(&quot;Path&quot;);//读取
    }
}
</code></pre>
<pre><code class="language-c#">public class Extension{
    [MenuItem(&quot;Assets/Create ScriptableObject&quot;)]
    static void CreateScriptableObject(){
        Displayer displayer = ScriptableObject.CreateInstance&lt;Displayer&gt;();
        displayer.m_DisplayerInfo = new List&lt;Displayer.DisplayerInfo&gt;();
        displayer.m_DisplayerInfo.Add(new Displayer.DisplayerInfo() {id = 100, name = &quot;test&quot;});
        //将资源保存到本地
        AssetDatabase.CreateAsset(displayer,&quot;Assets/Resources/displayer.asset&quot;);
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android]]></title>
        <id>https://sunxiaohang.github.io/post/android/</id>
        <link href="https://sunxiaohang.github.io/post/android/">
        </link>
        <updated>2020-04-06T11:24:25.000Z</updated>
        <summary type="html"><![CDATA[<p>初学Android时的一些基础知识汇总，作为理解Android基本原理的实验性代码，不具有参考价值，主要参考书目为第一行代码</p>
]]></summary>
        <content type="html"><![CDATA[<p>初学Android时的一些基础知识汇总，作为理解Android基本原理的实验性代码，不具有参考价值，主要参考书目为第一行代码</p>
<!-- more -->
<h4 id="activity">Activity</h4>
<pre><code>    protected void onCreate(Bundle savedInstanceState) {
        Log.i(&quot;target&quot;,&quot;Activity onCreate&quot;);
    }
    protected void onStart() {
        Log.i(&quot;target&quot;,&quot;Activity onStart&quot;);
    }
    protected void onRestart() {
        Log.i(&quot;target&quot;,&quot;Activity onRestart&quot;);
    }
    protected void onResume() {
        Log.i(&quot;target&quot;,&quot;Activity onResume&quot;);
    }
    protected void onPause() {
        Log.i(&quot;target&quot;,&quot;Activity onPause&quot;);
    }
    protected void onStop() {
        Log.i(&quot;target&quot;,&quot;Activity onStop&quot;);
    }
    protected void onDestroy() {
        Log.i(&quot;target&quot;,&quot;Activity onDestroy&quot;);
    }
</code></pre>
<h5 id="不同情境下生命周期方法执行顺序">不同情境下生命周期方法执行顺序</h5>
<p><em>正常情况下生命周期</em><br>
<code>从进入activity到按下回退键退出activity</code></p>
<pre><code>com.example.root.activitylifecycle I/target: Activity onCreate
com.example.root.activitylifecycle I/target: Activity onStart
com.example.root.activitylifecycle I/target: Activity onResume
com.example.root.activitylifecycle I/target: Activity onPause
com.example.root.activitylifecycle I/target: Activity onStop
com.example.root.activitylifecycle I/target: Activity onDestroy
</code></pre>
<p><em>屏幕灭掉</em></p>
<pre><code>com.example.root.activitylifecycle I/target: Activity onCreate
com.example.root.activitylifecycle I/target: Activity onStart
com.example.root.activitylifecycle I/target: Activity onResume
com.example.root.activitylifecycle I/target: Activity onPause
com.example.root.activitylifecycle I/target: Activity onStop
</code></pre>
<p><code>可以看到并没有执行onDestroy方法，接下来点亮屏幕</code></p>
<pre><code>com.example.root.activitylifecycle I/target: Activity onRestart
com.example.root.activitylifecycle I/target: Activity onStart
com.example.root.activitylifecycle I/target: Activity onResume
</code></pre>
<p><em>跳转到其他activity</em></p>
<pre><code>com.example.root.activitylifecycle I/target: Activity onCreate
com.example.root.activitylifecycle I/target: Activity onStart
com.example.root.activitylifecycle I/target: Activity onResume
com.example.root.activitylifecycle I/target: Activity onPause
com.example.root.activitylifecycle I/target: SecondActivity onCreate
com.example.root.activitylifecycle I/target: SecondActivity onStart
com.example.root.activitylifecycle I/target: SecondActivity onResume
com.example.root.activitylifecycle I/target: Activity onStop
</code></pre>
<p>注意：当第二个activity执行到<code>onResume</code>方法后第一个activity才执行<code>onStop</code>方法,即当第二个activity就绪之后第一个activity才执行onStop方法，但第一个activity并没有执行onDestroy方法，它被放入后退栈中。<br>
<code>接下来按下退格键返回第一个activity</code></p>
<pre><code>com.example.root.activitylifecycle I/target: SecondActivity onPause
com.example.root.activitylifecycle I/target: Activity onRestart
com.example.root.activitylifecycle I/target: Activity onStart
com.example.root.activitylifecycle I/target: Activity onResume
com.example.root.activitylifecycle I/target: SecondActivity onStop
com.example.root.activitylifecycle I/target: SecondActivity onDestroy
</code></pre>
<p>第二个activity的生命周期执行完成，第一个activity执行<code>onRestart</code>到<code>onResume</code>重新就绪,再次按下退格键</p>
<pre><code>com.example.root.activitylifecycle I/target: Activity onPause
com.example.root.activitylifecycle I/target: SecondActivity onStop
com.example.root.activitylifecycle I/target: SecondActivity onDestroy
</code></pre>
<p>第一个activity生命周期执行结束</p>
<h5 id="activity异常时数据保存于数据恢复">Activity异常时数据保存于数据恢复</h5>
<p>当屏幕旋转的时候activity就会重新执行onCreate,我们可以用屏幕旋转模拟activity异常销毁</p>
<pre><code>    protected void onSaveInstanceState(Bundle outState) {
        Log.i(&quot;target&quot;,&quot;Activity onSaveInstanceState&quot;);
        outState.putString(&quot;target&quot;,&quot;this is onSaveInstanceState saved bundle data&quot;);
    }
    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        Log.i(&quot;target&quot;,&quot;Activity onRestoreInstanceState&quot;);
        Log.i(&quot;target&quot;,savedInstanceState.getString(&quot;target&quot;));
    }
</code></pre>
<p><code>日志信息</code></p>
<pre><code>com.example.root.activitylifecycle I/target: Activity onSaveInstanceState
com.example.root.activitylifecycle I/target: Activity onRestoreInstanceState
com.example.root.activitylifecycle I/target: this is onSaveInstanceState saved bundle data
</code></pre>
<h5 id="activity的launchmode">Activity的LaunchMode</h5>
<ul>
<li><code>standard模式</code>：这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中，使用场景（大多数Activity）</li>
<li><code>singleTop模式</code>：如果任务栈的栈顶正好存在该Activity的实例，就重用该实例（会调用实例的onNewIntent()），否则就会创建新的实例并放入栈顶，计时栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例，使用场景（新闻类或者阅读类App的内容页面）</li>
<li><code>singleTask模式</code>：如果栈中已经有该Activity的实例，就重写该实例（会调用实例的onNewIntent()）。重用时，会让该实例回到栈顶，因此在他上面的实例将会被移出栈，如果栈中不存在该实例，将创建新的实例放入栈中，使用场景如浏览器的主界面，不管从多少个应用启动浏览器，只会启动主界面一次，其余都会走onNewIntent，并清空主界面上的其他页面</li>
<li><code>singleInstance模式</code>：在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该activity实例，一旦该模式的activity实例已经存在于某个栈中，任何英语再激活该activity时都会重用该栈中的实例，会调用（onNewIntent（）），其效果相当于多个应用共享一个应用，不管谁激活该activity都会进入同一个应用中，使用场景（闹铃提示，将闹钟提醒与闹钟设置分离），singleinstance不要勇于中间页面，如果用于中间页面，跳转会有问题（A-&gt;B-&gt;(singleinstance)-&gt;C）完全退出后再次启动首先打开的是B</li>
</ul>
<h5 id="activity的flags">Activity的Flags</h5>
<p><code>intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</code>;//指定Activity为&quot;singleTask&quot;启动模式<br>
<code>intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP)</code>;//指定Activity为&quot;singleTop&quot;启动模式<br>
<code>intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)</code>;//位于其上的Activity都要出栈，类似&quot;singleTask&quot;<br>
<code>intent.setFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS)</code>;//不会出现在Activity的历史列表中，等同于<code>android:excludeFromRecents=&quot;true&quot;</code></p>
<h5 id="intentfilter的匹配规则">IntentFilter的匹配规则</h5>
<p>为了匹配过滤列表，需要同时匹配过滤列表中的action，category，data信息。一个Activity可以有多个intentFilter，一个Intent只要能匹配任何一组intentFilter即可成功启动对应Activity</p>
<h6 id="action的匹配规则">action的匹配规则</h6>
<p>action区分大小写，必须存在，只需匹配一个<br>
category的匹配规则可以没有，若是有，必须全部匹配（可以比过滤规则中少）<br>
示例：</p>
<pre><code>&lt;intent-filter&gt;
    &lt;action android:name=&quot;com.example.root.saveinstancelearn.secondactivity&quot;/&gt;
    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
    &lt;category android:name=&quot;com.example.root.saveinstancelearn.secondactivity&quot;/&gt;
&lt;/intent-filter&gt;
</code></pre>
<pre><code>Intent intent=new Intent(&quot;com.example.root.saveinstancelearn.secondactivity&quot;);               
intent.addCategory(Intent.CATEGORY_DEFAULT);
startActivity(intent);
</code></pre>
<h5 id="data的匹配规则">data的匹配规则</h5>
<p>data与action类似(data语法如下)</p>
<pre><code>&lt;data android:scheme=&quot;string&quot;
    android:host=&quot;string&quot;
    android:port=&quot;string&quot;
    android:path=&quot;string&quot;
    android:pathPattern=&quot;string&quot;
    android:pathPrefix=&quot;string&quot;
    android:mimeType=&quot;string&quot; /&gt;
</code></pre>
<p>data有两部分组成，mimeType和URI。mimeType指定媒体类型，比如image/jpeg等<br>
匹配示例：</p>
<pre><code>&lt;intent-filter&gt;
    &lt;data android:mimeType=&quot;image/*&quot;/&gt;
&lt;intent-filter&gt;
</code></pre>
<p><code>intent.setDataAndType(Uri.parse(&quot;file://abc&quot;),&quot;image/png&quot;)</code>;</p>
<blockquote>
<p>ps:如果要为Intent指定完整的data，必须调用setDataAndType方法，不能先调用setData在调用setType，以为这两个方法会清除对方的值；</p>
</blockquote>
<p>实例</p>
<pre><code>&lt;intent-filter&gt;
    &lt;data android:mimeType=&quot;video/mpeg&quot; android:scheme=&quot;http&quot;/&gt;
    &lt;data android:mimeType=&quot;audio/mpeg&quot; android:scheme=&quot;http&quot;/&gt;
&lt;/intent-filter&gt;
</code></pre>
<p><code>intent.setDataAndType(Uri.parse(&quot;http://abc&quot;),&quot;video/mpeg&quot;)</code>;或者<br>
<code>intent.setDataAndType(Uri.parse(&quot;http://abc&quot;),&quot;audio/mpeg&quot;)</code>;</p>
<h4 id="service">Service</h4>
<p>创建一个Binder类继承自<code>android.os.Binder</code>里面有两个方法，分别用于设置通信内容和获取Myservice对象。</p>
<pre><code>  public class Binder extends android.os.Binder{
      public void setData(String data){
          MyService.this.data=data;
      }
      public MyService getService(){
          return MyService.this;
      }
  }
</code></pre>
<p>下面是自定义的Myservice对象继承自Service类，并覆写<code>onCreate</code> <code>onDestory</code> <code>onBind</code>方法。</p>
<pre><code>  public MyService() extends Service {
    @Override
    public void onCreate() {
        running=true;
        super.onCreate();
        new Thread(){
            @Override
            public void run() {
                super.run();
                int i=0;
                while (running){
                    i++;
                    String str=i+&quot;:&quot;+data;
                    System.out.println(str);
                    if(callback!=null){
                        callback.onDataChange(str);
                    }
                    try {
                        sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }.start();
    }
 }
  @Override
  public void onDestroy() {
      running=false;
      super.onDestroy();
  }
  @Override
  public IBinder onBind(Intent intent) {
      return new Binder();
  }
}
</code></pre>
<p>之后需要创建一个接口用于检测通信消息发生变化的回调接口。</p>
<pre><code>  public interface Callback{
      void onDataChange(String data);
  }
</code></pre>
<p>在主UI线程中添加一些按钮并绑定相应的点击事件用于启动和停止服务，以及更行Service数据。用来检测Service是否与UI线程实时通信。</p>
<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener, ServiceConnection {
  private Button bindService;
  private Button unBindService;
  private Button syncData;
  private EditText editText;
  private MyService.Binder binder;
  private TextView textView;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      setContentView(R.layout.activity_main);
      initView();
  }

  private void initView() {
      bindService = (Button) findViewById(R.id.bindService);
      unBindService = (Button) findViewById(R.id.unBindService);
      syncData = (Button) findViewById(R.id.syncData);
      editText= (EditText) findViewById(R.id.editText);
      textView= (TextView) findViewById(R.id.tv_textout);
      bindService.setOnClickListener(this);
      unBindService.setOnClickListener(this);
      syncData.setOnClickListener(this);
  }

  @Override
  public void onClick(View view) {
      switch (view.getId()) {
          case R.id.bindService:
              bindService(new Intent(this, MyService.class), this, Context.BIND_AUTO_CREATE);
              break;
          case R.id.unBindService:
              unbindService(this);
              break;
          case R.id.syncData:
              if(binder!=null){
                  binder.setData(editText.getText().toString());
              }
              break;
      }
  }

  @Override
  public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
      binder= (MyService.Binder) iBinder;
      binder.getService().setCallback(new MyService.Callback() {
          @Override
          public void onDataChange(String data) {
              Message msg=new Message();
              Bundle b=new Bundle();
              b.putString(&quot;data&quot;,data);
              msg.setData(b);
              handler.sendMessage(msg);
          }
      });
  }
  private Handler handler=new Handler(){
      @Override
      public void handleMessage(Message msg) {
          super.handleMessage(msg);
          textView.setText(msg.getData().getString(&quot;data&quot;));
      }
  };
  @Override
  public void onServiceDisconnected(ComponentName componentName) {
  }
}
</code></pre>
<h4 id="java-io流">Java IO流</h4>
<table>
<thead>
<tr>
<th>分类</th>
<th style="text-align:center">字节输入流</th>
<th style="text-align:center">字节输出流</th>
<th style="text-align:center">字符输入流</th>
<th style="text-align:center">字符输出流</th>
</tr>
</thead>
<tbody>
<tr>
<td>抽象基类</td>
<td style="text-align:center"><code>InputStream</code></td>
<td style="text-align:center"><code>OutputStream</code></td>
<td style="text-align:center"><code>Reader</code></td>
<td style="text-align:center"><code>Writer</code></td>
</tr>
<tr>
<td>访问文件</td>
<td style="text-align:center">FileInputStream</td>
<td style="text-align:center">FileOutputStream</td>
<td style="text-align:center">FileReader</td>
<td style="text-align:center">FileWriter</td>
</tr>
<tr>
<td>访问数组</td>
<td style="text-align:center">ByteArrayInputStream</td>
<td style="text-align:center">BiteArrayOutputStream</td>
<td style="text-align:center">CharArrayReader</td>
<td style="text-align:center">CharArrayWriter</td>
</tr>
<tr>
<td>访问管道</td>
<td style="text-align:center">PipedInputStream</td>
<td style="text-align:center">PipedOutputStream</td>
<td style="text-align:center">PipedReader</td>
<td style="text-align:center">PipedWriter</td>
</tr>
<tr>
<td>访问字符串</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">StringReader</td>
<td style="text-align:center">StringWriter</td>
</tr>
<tr>
<td>缓冲流</td>
<td style="text-align:center">BufferedInputStream</td>
<td style="text-align:center">BufferedOutputStream</td>
<td style="text-align:center">BufferedReader</td>
<td style="text-align:center">BufferedWriter</td>
</tr>
<tr>
<td>转换流</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">InputStreamReader</td>
<td style="text-align:center">OutputStreamWriter</td>
</tr>
<tr>
<td>对象流</td>
<td style="text-align:center">ObjectInputStream</td>
<td style="text-align:center">ObjectOutputStream</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>抽象基类</td>
<td style="text-align:center"><code>FilterInputStream</code></td>
<td style="text-align:center"><code>FilterOutputStream</code></td>
<td style="text-align:center"><code>FilterReader</code></td>
<td style="text-align:center"><code>FilterWriter</code></td>
</tr>
<tr>
<td>打印流</td>
<td style="text-align:center"></td>
<td style="text-align:center">PrintStream</td>
<td style="text-align:center"></td>
<td style="text-align:center">PrintWriter</td>
</tr>
<tr>
<td>推回输入流</td>
<td style="text-align:center">PushbackInputStream</td>
<td style="text-align:center"></td>
<td style="text-align:center">PushbackReader</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>特殊流</td>
<td style="text-align:center">DataInputStream</td>
<td style="text-align:center">DataOutputStream</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>其中基类都是抽象类，不同的子类对应不同的用途<br>
首先我们看一下字节流与字符流的不同之处</p>
<blockquote>
<p>字节流是由字节组成的,<a href="http://baike.baidu.com/item/%E5%AD%97%E7%AC%A6">字符</a>流是由字符组成的. Java里字符由两个字节组成.字节流是最基本的，所有的InputStream和OutputStream的子类都是，主要用在处理二进制数据，它是按字节来处理的但实际中很多的数据是文本，又提出了字符流的概念，它是按<a href="http://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E6%9C%BA">虚拟机</a>的encode来处理，也就是要进行<a href="http://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E9%9B%86">字符集</a>的转化。</p>
</blockquote>
<p>通俗的来讲，字节流就是二进制流，通常的图片，视频，音频文件都可以通过字节流来读写，字符流就是字符串，中文字符，等unicode字符编码后的字符集。字节流可以通过转换流（即<code>InputStreamReader</code>，<code>InputStreamWriter</code>）转换为字符流（转化的过程就是编码的过程），缓冲流是为了提高读写效率提供的类，可以开辟出一个缓冲区用于高速存取数据流（分别对应字节流和字符流）。</p>
<h4 id="字节流读写文件的实例">字节流读写文件的实例</h4>
<pre><code>public class FileCopy {
	public void fileCopy(String sourceFile,String targetFile) throws IOException{
		FileInputStream in=new FileInputStream(sourceFile);
		FileOutputStream out=new FileOutputStream(targetFile);
		byte[] buffer=new byte[2048];//创建2048个字节大小的缓冲区（可根据拷贝文件大小自行定义）
		int value;
		while((value=in.read(buffer))!=-1){//循环读写
			out.write(buffer, 0, value);
		}
                if(in!=null)in.close();//关闭i/o流
                if(out!=null)out.close();
	}
	public static void main(String[] args) throws IOException {
		String in=&quot;readFile.txt&quot;;
		String out=&quot;outFile.txt&quot;;
		FileCopy f=new FileCopy();
		f.fileCopy(in, out);
	}
}
</code></pre>
<h5 id="字节流转字符流实例">字节流转字符流实例</h5>
<p>文件拷贝不推荐用这种方法，此方法仅作为字节流转字符流的实例，因为在文件copy中字节流转化为字符流读写的意义不大，而且会降低运行效率</p>
<pre><code>public class FileCopy {
	public void fileCopy(String sourceFile,String targetFile) throws IOException{
		FileInputStream in=new FileInputStream(sourceFile);
		FileOutputStream out=new FileOutputStream(targetFile);
		BufferedReader reader=new BufferedReader(new InputStreamReader(in));
		BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(out));
		String line=&quot;&quot;;
		StringBuffer result=new StringBuffer();
		while((line=reader.readLine())!=null){
			writer.write(line);//此处的write是将数据写入缓冲区，并没有写入文件
			writer.flush();//将缓冲区数据写入文件
		}
		if(writer!=null)writer.close();
		if(reader!=null)reader.close();
	}
	public static void main(String[] args) throws IOException {
		String in=&quot;readFile.txt&quot;;
		String out=&quot;outFile.txt&quot;;
		FileCopy f=new FileCopy();
		f.fileCopy(in, out);
		System.out.println(&quot;hell java&quot;);
	}
}
</code></pre>
<p>关键在于这两行</p>
<pre><code>BufferedReader reader=new BufferedReader(new InputStreamReader(in));
BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(out));
</code></pre>
<p>将FileInputStream作为参数传入InputStreamReader中然后作为参数传给BufferedReader,其中InputStreamReader作为Reader的子类传入</p>
<h4 id="android持久化存储">Android持久化存储</h4>
<h5 id="文件写入">文件写入</h5>
<pre><code>    public void save(String inputText){
        FileOutputStream out=null;
        BufferedWriter writer=null;
        try {
            out=openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE);
            writer=new BufferedWriter(new OutputStreamWriter(out));
            writer.write(inputText);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(writer!=null){
                try {
                    writer.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
</code></pre>
<h5 id="读取文件">读取文件</h5>
<pre><code>    public String load(){
        FileInputStream in =null;
        BufferedReader reader=null;
        StringBuilder content=new StringBuilder();
        try {
            in=openFileInput(&quot;data&quot;);
            reader=new BufferedReader(new InputStreamReader(in));
            String line=&quot;&quot;;
            while ((line=reader.readLine())!=null){
                content.append(line);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if(reader!=null){
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return content.toString();
    }
</code></pre>
<h4 id="sharepreferences方法">SharePreferences方法</h4>
<p><code>SharePreference</code>文件默认放在<code>/data/data/&lt;packagename&gt;/shared_prefs/目录下</code></p>
<h5 id="sharedpreferences写入">SharedPreferences写入</h5>
<pre><code>SharedPreferences.Editor editor=getSharedPreferences(&quot;data&quot;,MODE_PRIVATE).edit();
editor.putString(&quot;et_inputText&quot;,&quot;sharePreferences test&quot;);
editor.commit();
</code></pre>
<h5 id="sharedpreferences读取">SharedPreferences读取</h5>
<pre><code>SharedPreferences sp=getSharedPreferences(&quot;data&quot;,MODE_PRIVATE);
String input=sp.getString(&quot;et_inputText&quot;,&quot;请输入用户名&quot;);//第二个参数是为空的默认信息
</code></pre>
<h4 id="sqlite数据库存储">SQLite数据库存储</h4>
<p><code>SQLite</code>文件默认放在<code>/data/data/&lt;packagename&gt;/databases/目录下</code></p>
<pre><code>public class MyDataBaseHelper extends SQLiteOpenHelper{
    private static final String CREATE_BOOK=&quot;create table Book(&quot;
            +&quot;id integer primary key autoincrement, &quot;
            +&quot;author text, &quot;
            +&quot;price real, &quot;
            +&quot;pages integer, &quot;
            +&quot;name text)&quot;;
    private static final String CREATE_CATEGORY=&quot;create table Category(&quot;
            +&quot;id integer primary key autoincrement, &quot;
            +&quot;category_name text, &quot;
            +&quot;category_code integer)&quot;;
    private Context mContext;
    public MyDataBaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
        super(context, name, factory, version);
        mContext=context;
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(CREATE_BOOK);
        db.execSQL(CREATE_CATEGORY);
        Toast.makeText(mContext,&quot;create succeed&quot;,Toast.LENGTH_SHORT).show();
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        db.execSQL(&quot;drop table if exists Book&quot;);
        db.execSQL(&quot;drop table if exists Category&quot;);
        onCreate(db);
    }
</code></pre>
<p>创建数据库</p>
<pre><code> dbHelper=new MyDataBaseHelper(this,&quot;BookStore.db&quot;,null,2);
</code></pre>
<p>插入数据</p>
<pre><code>SQLiteDatabase db=dbHelper.getWritableDatabase();
ContentValues values=new ContentValues();
values.put(&quot;name&quot;,&quot;Effective Java&quot;);
values.put(&quot;author&quot;,&quot;Joshua Bloch&quot;);
values.put(&quot;pages&quot;,454);
values.put(&quot;price&quot;,16.96);
db.insert(&quot;Book&quot;,null,values);
</code></pre>
<p>更新数据</p>
<pre><code>ContentValues values=new ContentValues();
values.put(&quot;price&quot;,198.00);
SQLiteDatabase db=dbHelper.getReadableDatabase();
db.update(&quot;Book&quot;,values,&quot;name=?&quot;,new String[]{&quot;Android Programme&quot;});
</code></pre>
<p>删除行</p>
<pre><code>SQLiteDatabase db = dbHelper.getWritableDatabase();
db.delete(&quot;Book&quot;, &quot;pages &gt; ?&quot;, new String[] { &quot;500&quot; });
</code></pre>
<p><code>ContentValues</code>知识android提供的一个便于数据库操作的类，为数据库操作提供便利，也可以直接使用数据库语句进行操作</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring]]></title>
        <id>https://sunxiaohang.github.io/post/spring/</id>
        <link href="https://sunxiaohang.github.io/post/spring/">
        </link>
        <updated>2020-04-06T11:23:21.000Z</updated>
        <summary type="html"><![CDATA[<p>主要是一些读书笔记，总结java web项目常用框架的一些实现细节和基础理论。</p>
]]></summary>
        <content type="html"><![CDATA[<p>主要是一些读书笔记，总结java web项目常用框架的一些实现细节和基础理论。</p>
<!-- more -->
<h4 id="jsp">JSP</h4>
<h5 id="jsp内置对象">JSP内置对象</h5>
<table>
<thead>
<tr>
<th>JSP内置对象</th>
<th>对象描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Out</td>
<td>向客户端对象输出数据</td>
</tr>
<tr>
<td>Request</td>
<td>向服务器提交数据</td>
</tr>
<tr>
<td>Response</td>
<td>服务器项目信息</td>
</tr>
<tr>
<td>Exception</td>
<td>异常信息</td>
</tr>
<tr>
<td>Config</td>
<td>配置信息</td>
</tr>
<tr>
<td>Page</td>
<td>指向当前page本身</td>
</tr>
<tr>
<td>Session</td>
<td>保存会话信息（统一用户的不同对象之间共享信息）</td>
</tr>
<tr>
<td>Application</td>
<td>上下文（不同用户间共享信息）</td>
</tr>
<tr>
<td>PageContext</td>
<td>队jsp页面所有对象及命名空间的访问</td>
</tr>
</tbody>
</table>
<h5 id="out对象">out对象</h5>
<p><code>out.flush()</code><br>
<code>out.clearBuffer</code><br>
<code>out.clear</code></p>
<pre><code>out.print(&quot;获取当前缓冲区大小：&quot;+out.getBufferSize());
out.print(&quot;当前缓冲区剩余字节数目&quot;+out.getRemaining());
</code></pre>
<h5 id="request对象">Request对象</h5>
<table>
<thead>
<tr>
<th>Request对象</th>
<th>对象描述</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h5 id="简单语法格式整理">简单语法格式整理</h5>
<pre><code>&lt;jsp:forward page=&quot;login.jsp&quot;&gt;
    &lt;jsp:param value=&quot;jikexueyuan&quot; name=&quot;username&quot;/&gt;
    &lt;jsp:param value=&quot;sunxiaohang&quot; name=&quot;password&quot;/&gt;
&lt;/jsp:forward&gt;
&lt;%@page errorPage=&quot;error_page.jsp&quot; isErrorPage=&quot;true&quot; %&gt;


  String username=request.getParameter(&quot;username&quot;);
    String password=request.getParameter(&quot;password&quot;);
    out.println(&quot;username &quot;+username);
    out.println(&quot;&lt;br/&gt;&quot;);
    out.println(&quot;password &quot;+password);

&lt;jsp:include page=&quot;body.jsp&quot;&gt;
    &lt;jsp:param name=&quot;bgcolor&quot; value=&quot;red&quot;/&gt;
&lt;/jsp:include&gt;

&lt;body bgcolor=&quot;&lt;%=request.getParameter(&quot;bgcolor&quot;)%&gt;&quot;&gt;
&lt;/body&gt;

&lt;jsp:useBean id=&quot;person&quot; class=&quot;Person&quot;&gt;&lt;/jsp:useBean&gt;
&lt;jsp:setProperty property=&quot;name&quot; name=&quot;person&quot;/&gt;
&lt;jsp:setProperty property=&quot;sex&quot; name=&quot;person&quot;/&gt;

&lt;jsp:getProperty property=&quot;name&quot; name=&quot;person&quot;/&gt;
&lt;jsp:getProperty property=&quot;sex&quot; name=&quot;person&quot;/&gt;
需要添加statdard.jar jstl.jar包
</code></pre>
<h5 id="spring内置对象">Spring内置对象</h5>
<pre><code>  response.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);//无缓存
    response.setIntHeader(&quot;refresh&quot;,2);//设置两秒钟自动刷新
    out.print(&quot;this date is :&quot;+new java.util.Date().toString()+&quot;&lt;br&gt;&quot;);
    response.sendRedirect(&quot;https://www.baidu.com&quot;);//重定向页面
    Cookie cookie=new Cookie(&quot;username&quot;,&quot;password&quot;);
    cookie.setMaxAge(3600);
    response.addCookie(cookie);
    session.getId();
</code></pre>
<h5 id="面向方面的程序设计aop">面向<code>方面</code>的程序设计（AOP）</h5>
<p>Spring框架的一个关键组件是面向方面的程序设计（AOP）框架。一个程序中跨越多个点的功能被称为<code>横切关注点</code>，其在概念上独立于应用程序的业务逻辑（sample：日志记录、声明性事务）</p>
<p><code>OOP</code>中模块化的关键单元是类，<code>AOP</code>中模块化的关键单元室方面。<code>AOP</code>帮助你将横切关注点从他们所影响的对象中分离出来，<code>依赖注入</code>帮助你将你的应用程序对象从彼此中分离出来。</p>
<ul>
<li>
<p><code>控制反转IOC</code><br>
在编写一个复杂的java程序时应用程序类应当尽可能的独立于其他的java类来增加这些类的可重用性，当进行单元测试时，可以使他们独立于其他类进行测试。</p>
</li>
<li>
<p><code>依赖注入DI</code><br>
依赖注入可以以向构造函数传递参数的方式发生，或者通过使用setter方法post-construction。</p>
</li>
</ul>
<h5 id="spring体系结构">Spring体系结构</h5>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/2480310-1638858c768bd15f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Spring体系框架图" loading="lazy"></figure>
<h5 id="核心容器">核心容器</h5>
<p>核心容器由核心、bean、上下文的表达式语言模块组成</p>
<ul>
<li><code>核心</code>提供框架的基本组成部分、包括IOC和依赖注入功能。</li>
<li><code>Bean</code>提供BeanFactory，工厂模式的复杂实现。</li>
<li><code>上下文</code>建立在由core和bean提供的坚实基础上，他是访问定义和配置的任何对象的媒介。ApplicationContext接口是上下文模块的重点。</li>
<li><code>表达式语言</code>模块在运行时提供了查询和操作一个对象图的强大的表达式语言</li>
</ul>
<h5 id="数据集成-访问">数据集成、访问</h5>
<ul>
<li><code>JDBC</code>提供删除冗余的JDBC相关编码的JDBC抽象层</li>
<li><code>ORC</code>为流行的对象关系映射API，包括JPA、JDO、Hibernate和iBatis提供集成层</li>
<li><code>OXM</code>提供抽象层、它支持对JAXB、Castor、XMLBeans，JiBx和XStream的对象/XML映射实现</li>
<li><code>JMS</code>java消息服务包含生产和消费的信息的功能</li>
<li><code>事务</code>事务模块为实现特殊接口的类及所有的POJO支持编程式和声明式事务管理</li>
</ul>
<h5 id="web">Web</h5>
<ul>
<li><code>Web</code>提供基本的面向web的集成功能，例如多个文件上传的功能和使用servlet监听器和面向web应用程序的上下文来初始化IOC容器</li>
<li><code>Web-MVC</code>包含Spring的模型-视图-控制（MVC），实现了web应用程序</li>
<li><code>Web-Socket</code>为<code>WebSocket-Based</code>提供支持，而且在web应用程序中提供客户端和服务器端之间的通信的两种方式。</li>
<li><code>Web-Portlet</code>提供在portlet环境中实现MVC，并且反映了Web-Servlet模块的功能。</li>
</ul>
<h5 id="spring实例">Spring实例</h5>
<ul>
<li>1.生成工厂对象，加载完指定路径下bean配置文件，利用框架提供的<code>FileSystemXmlApplicationContext</code> API生成工厂bean<code>FileSystemXmlApplicationContext</code>负责生成和初始化所有对象，比如：所有XML bean配置文件中的bean</li>
<li>利用第一步生成的上下文中的<code>getBean()</code>方法得到所需要的bean，这个方法通过配置中的<code>beanID</code>来返回一个真正的对象，一旦得到这个对象就可以利用这个对象条用任何方法。</li>
</ul>
<pre><code> ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;/configure/beansConfigure.xml&quot;);
        HelloWord helloWord= (HelloWord) applicationContext.getBean(&quot;helloWord&quot;);
        helloWord.getMessage();
</code></pre>
<h5 id="bean-property">bean property</h5>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>强制属性，制定用来创建bean的bean类</td>
</tr>
<tr>
<td>name/id</td>
<td>指定唯一的bean的标识符</td>
</tr>
<tr>
<td>scope</td>
<td>指定由特定bean定义创建的对象的作用域</td>
</tr>
<tr>
<td>constructor-arg</td>
<td>用来注入依赖关系</td>
</tr>
<tr>
<td>properties</td>
<td>用来注入依赖关系</td>
</tr>
<tr>
<td>autowiring mode</td>
<td>用来注入依赖关系</td>
</tr>
<tr>
<td>lazy-initialization mode</td>
<td>第一次调用时创建对象（懒汉模式）</td>
</tr>
<tr>
<td>initialization</td>
<td>在bean的所有必须属性被容器设置之后，调用回调方法</td>
</tr>
<tr>
<td>destruction</td>
<td>当包含该bean的容器被销毁是，使用回调方法</td>
</tr>
</tbody>
</table>
<h5 id="spring配置元数据">Spring配置元数据</h5>
<p><code>Spring IoC</code>容器完全由实际编写的配置元数据的格式解耦</p>
<ul>
<li>基于XML的配置文件</li>
<li>基于注解的配置</li>
<li>基于java的配置</li>
</ul>
<h5 id="spring-bean的作用域">Spring Bean的作用域</h5>
<p>在Spring定义一个bean时，必须声明该bean的作用域.</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>singleTon</code></td>
<td>单例模式</td>
</tr>
<tr>
<td><code>prototype</code></td>
<td>普通模式，每次调用创建一个新的对象</td>
</tr>
<tr>
<td><code>request</code></td>
<td>作用域定义为HTTP请求，只在web-aware spring ApplicationContext的上下文中有效</td>
</tr>
<tr>
<td><code>session</code></td>
<td>作用域定义限制为HTTP会话，只在web-aware spring ApplicationContext的上下文中有效</td>
</tr>
<tr>
<td><code>global-session</code></td>
<td>作用域将bean的定义限制为全局HTTP绘画，只在web-aware spring ApplicationContext的上下文中有效</td>
</tr>
</tbody>
</table>
<p>作用域设置实例</p>
<pre><code> &lt;bean id=&quot;singleTon&quot; class=&quot;com.example.SingleTon&quot; 
      scope=&quot;singleton&quot;&gt;
</code></pre>
<h5 id="spring-bean的生命周期">Spring bean的生命周期</h5>
<p>声明带有 <code>init-method</code>和 <code>destroy-method</code> 参数的 。</p>
<ul>
<li><code>init-method</code> 属性指定一个方法，在实例化 bean 时调用该方法。</li>
<li><code>destroy-method</code> 指定一个方法，只有从容器中移除 bean 后，才能调用该方法。</li>
</ul>
<p>在<code>org.springframework.beans.factory.InitializingBean</code> 接口指定一个单一的方法：</p>
<pre><code>void afterPropertiesSet() throws Exception;
</code></pre>
<p>我们只需要在实现<code>InitializingBean</code>接口就可以在对象创建后做一些事情</p>
<pre><code>public class TestBean implements InitializingBean {
   public void afterPropertiesSet() throws Exception{
      // do some initialization work
   }
}
</code></pre>
<p>同样的在<code>org.springframework.beans.factory.DisposableBean</code> 接口指定一个单一的方法：</p>
<pre><code>void destroy() throws Exception;
</code></pre>
<p>然后在类对象中实现<code>DisposableBean</code>接口</p>
<pre><code>public class TestBean implements DisposableBean{
    @Override
    public void destroy() throws Exception {
        // do some initialization work
    }
}
</code></pre>
<p>除此之外，在基于XML元数据配置的境况下还可以通过设置<code>destroy-method</code>属性实现</p>
<pre><code>&lt;bean id=&quot;exampleBean&quot;
         class=&quot;examples.ExampleBean&quot; destroy-method=&quot;destroy&quot;/&gt;
</code></pre>
<p>在类里面我们可以这样定义</p>
<pre><code>public class TestBean {
   public void destroy() {
      // do some destruction work
   }
}
</code></pre>
<h5 id="beanpostprocessor">BeanPostProcessor</h5>
<p>有时候会需要在bean实例化对象前后去做一些准备工作或预处理，可以在创建bean类时实现<code>BeanPostProcessor</code>接口去完成自定义工作。<br>
该接口定义了<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>两个带参函数，示例代码如下</p>
<pre><code>public class TestBean implements BeanPostProcessor {
   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
      System.out.println(&quot;BeforeInitialization : &quot; + beanName);
      return bean;  // you can return any other object as well
   }
   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
      System.out.println(&quot;AfterInitialization : &quot; + beanName);
      return bean;  // you can return any other object as well
   }
}
</code></pre>
<p><code>注意</code>：在main方法中需要注册一个在 AbstractApplicationContext 类中声明的关闭 hook 的 registerShutdownHook() 方法。它将确保正常关闭，并且调用相关的 destroy 方法。</p>
<pre><code>context.registerShutdownHook();
</code></pre>
<h4 id="java的反射机制">Java的反射机制</h4>
<p><code>写在Spring Ioc之前</code><br>
类装载器就是寻找类的字节码文件并构造出类在JVM内部表示的对象组件，主要工作由ClassLoader及其子类负责，ClassLoader是一个重要的java运行时系统组件，他负责在运行时查找和装入Class字节码文件</p>
<pre><code>public class ReflectCar {
    public static Car initCarByDefaultConst() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        ClassLoader loader=Thread.currentThread().getContextClassLoader();
        Class clazz=loader.loadClass(&quot;com.beijinghuayi.ioc.Car&quot;);
        //获取类默认实例化对象
        Constructor constructor=clazz.getDeclaredConstructor((Class[])null);
        Car car= (Car) constructor.newInstance();

        Method setBrand=clazz.getMethod(&quot;setBrand&quot;,String.class);
        setBrand.invoke(car,&quot;奔驰&quot;);
        Method setColor=clazz.getMethod(&quot;setColor&quot;,String.class);
        setColor.invoke(car,&quot;红色&quot;);
        Method setMaxspeed=clazz.getMethod(&quot;setMaxspeed&quot;,String.class);
        setMaxspeed.invoke(car,&quot;200码&quot;);
        return car;
    }
    public static Car initCarByParams() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        ClassLoader loader=Thread.currentThread().getContextClassLoader();
        Class clazz=loader.loadClass(&quot;com.beijinghuayi.ioc.Car&quot;);
        Constructor constructor=clazz.getDeclaredConstructor(new Class[]{String.class,String.class,String.class});
        Car car= (Car) constructor.newInstance(new Object[]{&quot;红色&quot;,&quot;宝马&quot;,&quot;180&quot;});
        return car;
    }
}
</code></pre>
<p><code>工作机制：</code></p>
<ul>
<li>1.装载：查找和导入Class文件</li>
<li>2.链接：执行校验，准备和解析步骤</li>
<li>3.初始化：对类的静态变量、静态代码块执行初始化操作</li>
</ul>
<p><code>Tip:</code>JVM在运行时会产生3个<code>classLoader</code></p>
<ul>
<li>根装载器（C++实现、不是classloader的子类）装载jre核心类库</li>
<li>ExtClassLoader（扩展类装载器）装载jre扩展目录ext中的jar类</li>
<li>AppClassLoader（系统类装载器）装载classpath中的内容</li>
</ul>
<p><code>ClassLoader</code>重要方法</p>
<ul>
<li>Class loadClass(String name);从文件中装在类</li>
<li>Class defineClass(String name,byte[]b,int off,int len)</li>
<li>Class findSystemClass(String name)</li>
<li>Class findLoadedClass(String name)</li>
<li>ClassLoader getParent()</li>
</ul>
<p>Class反射对象描述类语义结构，可以从Class对象中获得构造函数，成员变量，方法等元素的反射对象，并以编程的方法通过这些反射对象对目标类对象进行操作。这些反射对象类在java.reflect包中定义，下面是最主要的三个反射类</p>
<ul>
<li>1.Constructor类对象的反射类（通过getConstructor方法可以获得类的所有构造函数反射对象数组）NewInstance。</li>
<li>2.Method类方法的反射类invoke() getReturnType(),getParameterTypes();</li>
<li>3.Field 获取类的成员变量反射类（ 获取成员变量反射数组）<br>
<code>Tip</code>访问private，protect成员变量或方法时需添加<code>Field.setAccessible(true)</code>，<code>Method.setAccessible(true)</code>方法取消java语言检查，否则将会抛出<code>IllegalAccessException</code>异常.</li>
</ul>
<pre><code> ClassLoader loader=Thread.currentThread().getContextClassLoader();
        System.out.println(&quot;classLoader:&quot;+loader);
        System.out.println(&quot;parent classLoader:&quot;+loader.getParent());
        System.out.println(&quot;grandParent classLoader:&quot;+loader.getParent().getParent());
</code></pre>
<h5 id="引出spring-ioc">引出Spring Ioc</h5>
<p>在Spring中，通过IOC可以将实现类、参数信息等配置在对应的配置文件中，那么当需要更改实现类或参数信息时，只需要修改配置文件即可，我们还可以对某对象所需要的其他对象进行注入，这种注入都是在配置文件中实现。</p>
<h5 id="spring-bean的简单实现">Spring Bean的简单实现</h5>
<pre><code>public class BeanFactory {
    private Map&lt;String,Object&gt; beanmap=new HashMap&lt;&gt;();
    public void init(String xml) throws DocumentException, ClassNotFoundException, IntrospectionException, IllegalAccessException, InstantiationException, InvocationTargetException {
        //1.创建读取配置文件的reader对象
        SAXReader reader=new SAXReader();
        //2.获取当前线程的类加载器
        ClassLoader loader=Thread.currentThread().getContextClassLoader();
        //3.从class目录下获取指定的xml文件
        InputStream ins=loader.getResourceAsStream(xml);
        Document doc=reader.read(ins);
        Element root=doc.getRootElement();
        Element foo;

        //4.遍历xml文件中的Bean实例
        for(Iterator i=root.elementIterator(&quot;bean&quot;);i.hasNext();){
            foo= (Element) i.next();
            //5.针对每一个bean实例，获取bean的属性id和class
            Attribute id=foo.attribute(&quot;id&quot;);
            Attribute cls=foo.attribute(&quot;class&quot;);

            //6.利用Java反射机制，通过class的名称获取Class对象
            Class bean=Class.forName(cls.getText());
            //7.获取丢应class信息
            java.beans.BeanInfo info =java.beans.Introspector.getBeanInfo(bean);
            //8.获取其属性描述
            java.beans.PropertyDescriptor pd[]=info.getPropertyDescriptors();
            //9.创建一个对象，并在接下来的代码中为对象的属性赋值
            Object obj=bean.newInstance();
            //10.遍历该bean的property属性
            for(Iterator ite=foo.elementIterator(&quot;property&quot;);ite.hasNext();){
                Element foo2= (Element) ite.next();
                //11.获取该property的name属性
                Attribute name=foo2.attribute(&quot;name&quot;);
                String value=null;
                //12.获取该property的子元素的值
                for (Iterator ite1 = foo2.elementIterator(&quot;value&quot;); ite1.hasNext();)
                {
                    Element node = (Element) ite1.next();
                    value = node.getText();
                    break;
                }

                //13.利用Java的反射机制调用对象的某个set方法，并将值设置进去
                for (int k = 0; k &lt; pd.length; k++) {
                    if (pd[k].getName().equalsIgnoreCase(name.getText()))
                    {
                        Method mSet = null;
                        mSet = pd[k].getWriteMethod();
                        mSet.invoke(obj, value);
                    }
                }
            }
            //14.将对象放入beanMap中，其中key为id值，value为对象
            beanmap.put(id.getText(), obj);
        }
    }
    /**
     * 通过bean的id获取bean的对象.
     *
     * @param beanName
     *            bean的id
     * @return 返回对应对象
     */
    public Object getBean(String beanName) {
        Object obj = beanmap.get(beanName);
        return obj;
    }
}
</code></pre>
<p><code>config.xml</code></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans&gt;
    &lt;bean id=&quot;javaBean&quot; class=&quot;JavaBean&quot;&gt;
        &lt;property name=&quot;username&quot;&gt;
            &lt;value&gt;mic_swift&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name=&quot;password&quot;&gt;
            &lt;value&gt;010101010110&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h5 id="spring资源访问工具类">Spring资源访问工具类</h5>
<p>JDK所提供的访问资源类并不能很好的满足各种底层资源的访问需求，因此，Spring设计了一个Resource接口，它为应用提供了更强大的访问底层资源的能力：<br>
<code>主要方法：</code></p>
<ul>
<li>boolean exists()</li>
<li>boolean isOpen()</li>
<li>URL getURL();</li>
<li>File getFile();</li>
<li>inputStream getInputStream();</li>
</ul>
<p><code>具体实现类</code></p>
<ul>
<li>ByteArrayResource</li>
<li>ClassPathResource</li>
<li>FileSystemResource</li>
<li>InputStreamResource</li>
<li>ServletContextResource</li>
<li>UrlResource</li>
</ul>
<p>为了访问不同类型的资源，必须使用相应的Resource实现类，Spring提供了一个强大的加载资源的机制，能够自动识别不同的资源类型。<br>
<code>资源类型地址前缀</code></p>
<ul>
<li>classpath classpath:com/example/config.xml</li>
<li>File file:/com/example/config.xml</li>
<li>Http http://www.baidu.com</li>
<li>Ftp ftp://www.baidu.com</li>
<li>无前缀 com/example/config.xml<br>
######BeanFactory和ApplicationContext<br>
BeanFactory时Spring框架的最核心接口，它提供高级的Ioc配置机制，AppliactionContext建立在BeanFactory基础上，提供了更多面向应用的功能，它提供了国际化支持和框架事件体系，更易于创建实际应用一般成BeanFactory为Ioc容器，而称ApplicationContext为应用上下文</li>
</ul>
<p>BeanFactory是一个类工厂，可以常见并管理各种类的对象，Spring称这些创建和管理的java对象为bean，在Spring中，java对象的范围更加宽泛，接下来我们对BeanFactory的类体系结构以及装载初始化顺序进行说明：</p>
<h5 id="类体系结构">类体系结构</h5>
<ul>
<li>XmlBeanFactory</li>
<li>ListableBeanFactory</li>
<li>HierarhicalBeanFactory</li>
<li>ConfigurableBeanFactory</li>
<li>AutowireCapableBeanFactory</li>
<li>SingletonBeanFactory</li>
<li>BeanDefinitionRegistry</li>
</ul>
<h5 id="初始化顺序">初始化顺序</h5>
<ul>
<li>创建配置文件</li>
<li>装载配置文件</li>
<li>启动Ioc容器</li>
<li>获取Bean实例</li>
</ul>
<p>ApplicationContext由BeanFactory派生而来，提供了更多面向实际的功能。在BeanFactory中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置的方式实现，接下来介绍一下ApplicationContext的实现类以及类体系结构：</p>
<p><code>具体实现类</code></p>
<ul>
<li>ClassPathXmlApplicationContext</li>
<li>FileSystemXmlApplicationContext</li>
<li>ConfigurableApplicationContext<br>
<code>类继承体系</code>(扩展接口)</li>
<li>ApplicationEventPublisher</li>
<li>MessageSource</li>
<li>ResourcePatternResolver</li>
<li>LifeCycle(用于处理异步)</li>
</ul>
<p>Spring容器中的Bean拥有明确的生命周期，由多个特定的生命阶段组成，每个生命阶段都允许外界对Bean进行控制，在Spring中，我们从Bean的作用范围和实例化Bean时所经历的一系列阶段来描述Bean的生命周期</p>
<ul>
<li>BeanFactory中的Bean的生命周期</li>
<li>ApplicationContext中的Bean的生命周期</li>
</ul>
<h5 id="spring容器启动基本条件">Spring容器启动基本条件</h5>
<ul>
<li>Spring框架类包</li>
<li>Bean配置信息</li>
<li>Bean类满足</li>
</ul>
<h5 id="bean的元数据信息">Bean的元数据信息</h5>
<ul>
<li>Bean的实现类</li>
<li>Bean的属性信息</li>
<li>Bean的依赖关系</li>
<li>Bean的行为配置</li>
<li>Bean的创建方式</li>
</ul>
<p>使用静态工厂的方式除了指定必须的class属性，还要指定factory-method属性来指定实例化Bean的方法，而且使用静态工厂方法也允许指定方法参数，SpringIoc容器将调用此属性的方法来获取Bean。</p>
<p>使用实例工厂方法不能指定clas属性，此时必须使用factory-bean来指定工厂Bean，factory-method属性指定实例化Bean的方法，而且使用实例工厂方法允许指定方法参数，方式和使用构造器方式一样</p>
<pre><code>&lt;bean id=&quot;beanInstanceFactory&quot; class=&quot;com.beijinghuayi.spring.Instance&quot;/&gt;
	&lt;bean id=&quot;helloWorldInstance&quot; factory-bean=&quot;beanInstanceFactory&quot; factory-method=&quot;newInstance&quot;&gt;
		&lt;constructor-arg index=&quot;0&quot; value=&quot;Hello Instance Factory!&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="spring多个配置文件的整合">Spring多个配置文件的整合</h5>
<pre><code>&lt;beans&gt;
    &lt;import resource=&quot;common/Spring-Common.xml&quot;/&gt;
    &lt;import resource=&quot;common/Spring-Connect.xml&quot;/&gt;
    &lt;import resource=&quot;common/Spring-Moudel.xml&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<h5 id="spring-bean-定义继承">Spring Bean 定义继承</h5>
<ul>
<li>Bean可以通过设置配置文件来定义继承关系</li>
<li>子 bean 的定义继承父定义的配置数据。子定义可以根据需要重写一些值，或者添加其他值。<code>tip:</code>Spring Bean 定义的继承与 Java 类的继承无关，但是继承的概念是一样的。</li>
<li>当你使用基于 XML 的配置元数据时，通过使用父属性，指定父 bean 作为该属性的值来表明子 bean 的定义。</li>
</ul>
<p>通过XML配置文件实现继承关系实例</p>
<pre><code>&lt;bean id=&quot;person&quot; class=&quot;com.example.Person&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;swift&quot;/&gt;
      &lt;property name=&quot;details&quot; value=&quot;animal can speak&quot;/&gt;
   &lt;/bean&gt;

   &lt;bean id=&quot;student&quot; class=&quot;com.example.Student&quot; parent=&quot;person&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;study&quot;/&gt;
      &lt;property name=&quot;details&quot; value=&quot;good good study, day day up!&quot;/&gt;
   &lt;/bean&gt;
</code></pre>
<p><code>tip：</code>在定义Student类的时候我们不再需要继承Person类</p>
<h5 id="bean-定义模板">Bean 定义模板</h5>
<pre><code>&lt;bean id=&quot;person&quot; abstract=&quot;true&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;swift&quot;/&gt;
      &lt;property name=&quot;details&quot; value=&quot;animal can speak&quot;/&gt;
   &lt;/bean&gt;

   &lt;bean id=&quot;student&quot; class=&quot;com.example.Student&quot; parent=&quot;person&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;study&quot;/&gt;
      &lt;property name=&quot;details&quot; value=&quot;good good study, day day up!&quot;/&gt;
   &lt;/bean&gt;
</code></pre>
<p>person 自身不能被实例化，因为它是不完整的(没有指定class属性)，而且它也被明确地标记为抽象的。当一个定义是抽象的，它仅仅作为一个纯粹的模板 bean 定义来使用的，充当子定义的父定义使用。</p>
<h5 id="spring-依赖注入">Spring 依赖注入</h5>
<p>当编写一个复杂的 Java 应用程序时，应用程序的 java 有多个对象，应用程序类应该尽可能独立于其他 Java 类来增加这些类重用的可能性，依赖注入DI<br>
（或有时称为布线）有助于把这些类粘合在一起，同时保持他们<code>独立</code>。</p>
<ul>
<li>构造函数注入</li>
</ul>
<pre><code>public class Person{
   private Speak speak;
   public Person(Speak speak) {
      this.speak= speak;
   }
}
</code></pre>
<p>依赖关系通过<code>类构造函数</code>被注入到 Person类中。</p>
<ul>
<li>setter方法注入</li>
</ul>
<pre><code>public class Person{
   private Speak speak;
   public void setSpeak(Speak speak){
	   this.speak=speak;
   }
}
</code></pre>
<p>依赖关系通过<code>类构造函数</code>被注入到 Person类中。控制流通过依赖注入（DI）已经“反转”，因为你已经有效地委托依赖关系到一些外部系统。</p>
<ul>
<li>XML配置文件注入</li>
</ul>
<pre><code> &lt;bean id=&quot;person&quot; class=&quot;com.example.Person&quot;&gt;
      &lt;constructor-arg ref=&quot;speak&quot;/&gt;
&lt;/bean&gt;
&lt;!-- Definition for speak bean --&gt;
&lt;bean id=&quot;speak&quot; class=&quot;com.example.Speak&quot;&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="spring-基于设值函数的依赖注入">Spring 基于设值函数的依赖注入</h5>
<p>当容器调用一个无参的构造函数或一个无参的静态 factory 方法来初始化你的 bean 后，通过容器在你的 bean 上调用设值函数，基于设值函数的 DI 就完成了。</p>
<pre><code> &lt;bean id=&quot;person&quot; class=&quot;com.example.Person&quot;&gt;
      &lt;property name=&quot;speak&quot; ref=&quot;speak&quot;&gt;
&lt;/bean&gt;
&lt;!-- Definition for speak bean --&gt;
&lt;bean id=&quot;speak&quot; class=&quot;com.example.Speak&quot;&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>
<p><code>Tip：</code>此方法和构造函数注入唯一的区别就是在基于构造函数注入中，我们使用的是标签中的元素，而在基于设值函数的注入中，我们使用的是标签。</p>
</li>
<li>
<p><code>tip：</code>如果你要把一个引用传递给一个对象，那么你需要使用 标签的 ref 属性，而如果你要直接传递一个值，那么你应该使用 value 属性。</p>
</li>
</ul>
<h5 id="p-namespace"><code>p-namespace</code></h5>
<pre><code>&lt;bean id=&quot;test&quot; class=&quot;com.example.Person&quot;&gt;
      &lt;property name=&quot;name&quot; value=&quot;swift&quot;/&gt;
      &lt;property name=&quot;method&quot; ref=&quot;speak&quot;/&gt;
&lt;/bean&gt;
//可以通过如下方式简化表示
&lt;bean id=&quot;test&quot; class=&quot;com.example.Person&quot;
      p:name=&quot;swift&quot;
      p:method=&quot;speak&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h5 id="注入内部bean">注入内部bean</h5>
<p>inner bean是在bean类中添加的内部类（java内部类）</p>
<pre><code>&lt;bean id=&quot;person&quot; class=&quot;com.sunxiaohang.Person&quot;&gt;
        &lt;property name=&quot;speak&quot;&gt;
            &lt;bean id=&quot;speak&quot; class=&quot;com.sunxiaohang.Speak&quot;&gt;&lt;/bean&gt;
        &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>tip:<code>&lt;!--property需要提供set方法才能使用--&gt;</code></p>
<h5 id="spring注入集合">Spring注入集合</h5>
<p>Spring提供了四种集合类</p>
<table>
<thead>
<tr>
<th>Spring集合类</th>
</tr>
</thead>
<tbody>
<tr>
<td>Map</td>
</tr>
<tr>
<td>Properties</td>
</tr>
<tr>
<td>Set</td>
</tr>
<tr>
<td>List</td>
</tr>
</tbody>
</table>
<p>以下是<code>Collections</code>类和<code>springbean.xml</code>的配置代码</p>
<pre><code>package com.sunxiaohang;

import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

public class Collections {
    private Set collectionSet;
    private Map collectionMap;
    private Properties collectionProperties;
    private List collectionList;

    public Collections() {
    }

    public Set getCollectionSet() {
        System.out.println(&quot;Set Element:&quot;+collectionSet);
        return collectionSet;
    }

    public void setCollectionSet(Set collectionSet) {
        this.collectionSet = collectionSet;
    }

    public Map getCollectionMap() {
        System.out.println(&quot;Map Element:&quot;+collectionMap);
        return collectionMap;
    }

    public void setCollectionMap(Map collectionMap) {
        this.collectionMap = collectionMap;
    }

    public Properties getCollectionProperties() {
        System.out.println(&quot;Properties Element:&quot;+collectionProperties);
        return collectionProperties;
    }

    public void setCollectionProperties(Properties collectionProperties) {
        this.collectionProperties = collectionProperties;
    }

    public List getCollectionList() {
        System.out.println(&quot;list Element:&quot;+collectionList);
        return collectionList;
    }

    public void setCollectionList(List collectionList) {
        this.collectionList = collectionList;
    }
}

</code></pre>
<pre><code>&lt;bean id=&quot;collections&quot; class=&quot;com.sunxiaohang.Collections&quot;&gt;
    &lt;property name=&quot;collectionList&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;张三&lt;/value&gt;
            &lt;value&gt;李四&lt;/value&gt;
            &lt;value&gt;王五&lt;/value&gt;
            &lt;value&gt;马六&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name=&quot;collectionSet&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;北京&lt;/value&gt;
            &lt;value&gt;天津&lt;/value&gt;
            &lt;value&gt;上海&lt;/value&gt;
            &lt;value&gt;广州&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
    &lt;property name=&quot;collectionMap&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;1&quot; value=&quot;one&quot;/&gt;
            &lt;entry key=&quot;2&quot; value=&quot;two&quot;/&gt;
            &lt;entry key=&quot;3&quot; value=&quot;three&quot;/&gt;
            &lt;entry key=&quot;4&quot; value=&quot;four&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name=&quot;collectionProperties&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;1&quot;&gt;姓名&lt;/prop&gt;
            &lt;prop key=&quot;2&quot;&gt;性别&lt;/prop&gt;
            &lt;prop key=&quot;3&quot;&gt;年龄&lt;/prop&gt;
            &lt;prop key=&quot;4&quot;&gt;出生日期&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式]]></title>
        <id>https://sunxiaohang.github.io/post/she-ji-mo-shi/</id>
        <link href="https://sunxiaohang.github.io/post/she-ji-mo-shi/">
        </link>
        <updated>2020-04-06T11:19:42.000Z</updated>
        <summary type="html"><![CDATA[<p>仅包含设计模式的一般实现和设计思想以及设计模式的使用方向，不拘泥于具体语言。以下设计模式思想仅基于Java语言实现，旨在优化软件工程结构，完善项目的鲁棒性和健壮性，便于后期迭代和维护。</p>
]]></summary>
        <content type="html"><![CDATA[<p>仅包含设计模式的一般实现和设计思想以及设计模式的使用方向，不拘泥于具体语言。以下设计模式思想仅基于Java语言实现，旨在优化软件工程结构，完善项目的鲁棒性和健壮性，便于后期迭代和维护。</p>
<!-- more -->
<h3 id="六大设计原则">六大设计原则</h3>
<h5 id="单一职责原则">单一职责原则</h5>
<blockquote>
<p>分离业务对象和业务逻辑</p>
</blockquote>
<h5 id="里氏替换原则">里氏替换原则</h5>
<blockquote>
<ul>
<li>子类必须完全实现父类方法</li>
<li>子类可以有自己的个性</li>
<li>覆盖或实现父类的方法是<code>输入参数可以被放大</code></li>
<li>覆盖或实现父类的方法是<code>输出结果可以被缩小</code></li>
</ul>
</blockquote>
<h5 id="依赖倒置原则">依赖倒置原则</h5>
<blockquote>
<ul>
<li>高层模块不依赖底层模块，都依赖其抽象</li>
<li>抽象不应该依赖细节</li>
<li>细节应该以来抽象</li>
</ul>
</blockquote>
<h5 id="接口隔离原则">接口隔离原则</h5>
<blockquote>
<ul>
<li>接口尽量小</li>
<li>接口高内聚</li>
<li>定制服务</li>
<li>接口的设计是有限度的</li>
</ul>
</blockquote>
<h5 id="迪米特法则最少知道原则">迪米特法则[最少知道原则]</h5>
<blockquote>
<ul>
<li>只和朋友交流</li>
<li>朋友之间也有<code>距离</code></li>
<li>是自己的就是自己的</li>
<li>谨慎使用Serializable</li>
</ul>
</blockquote>
<h5 id="开闭原则">开闭原则</h5>
<blockquote>
<p>扩展开放，修改关闭</p>
</blockquote>
<h3 id="单例模式">单例模式</h3>
<h5 id="使用场景">使用场景</h5>
<ul>
<li>要求生成唯一序列号的环境</li>
<li>共享访问或共享数据</li>
<li>对象创建资源消耗大</li>
<li>需要定义大量的静态常量和静态方</li>
</ul>
<h3 id="工厂方法模式">工厂方法模式</h3>
<p><code>Example</code></p>
<pre><code>// Human.java
public interface Human {
    void getColor();
}
// WhiteHuman.java
public class WhiteHuman implements Human{
    @Override
    public void getColor() {
        System.out.println(&quot;white Human color!&quot;);
    }
}
// AbstractHumanFactory.java
/**
 * 必需是Class类型
 * 必须是Human的实现类
 * */
public abstract class AbstractHumanFactory {
    public abstract &lt;T extends Human&gt; T createHuman(Class&lt;T&gt; c);
}
// Useage
AbstractHumanFactory factory = new HumanFactory();
Human whiteMan = factory.createHuman(WhiteHuman.class);
</code></pre>
<h5 id="简单工厂">简单工厂</h5>
<pre><code>// HumanFactory.java
/**
* 直接定义静态方法，跳过抽象工厂
*/
public class HumanFactory {
    public static &lt;T extends Human&gt; T createHuman(Class&lt;T&gt; c){
        Human human = null;
        try {
            human = (Human) Class.forName(c.getName()).newInstance();
        } catch (Exception e) {
            System.out.println(&quot;specify human class error!&quot;);
        } 
        return (T) human;
    }
}
// Usage
HumanFactory.createHuman(White.class);
</code></pre>
<h5 id="工厂单例">工厂单例</h5>
<pre><code>// SingletonFactory.java
public class SingletonFactory {
    private static Singleton sigleton;
    static {
        try {
            Class clazz = Class.forName(Singleton.class.getName());
            Constructor constructor = clazz.getDeclaredConstructor();
            constructor.setAccessible(true);
            sigleton = (Singleton) constructor.newInstance();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } 
    }
    public Singleton getSigleton(){
        return sigleton;
    }
}
</code></pre>
<h3 id="抽象工厂模式">抽象工厂模式</h3>
<figure data-type="image" tabindex="1"><img src="https://upload-images.jianshu.io/upload_images/2480310-9c9889a239cee88c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" loading="lazy"></figure>
<pre><code>// AbstractCreator.java
public abstract class AbstractCreator {
    public abstract AbstractProductA createProductA();
    public abstract AbstractProductB createProductB();
}
// Creator1.java
public class Creator1 extends AbstractCreator{
    @Override
    public AbstractProductA createProductA() {
        return new ProductA1();
    }
    @Override
    public AbstractProductB createProductB() {
        return new ProductB1();
    }
}
// Creator2.java
public class Creator2 extends AbstractCreator{
    @Override
    public AbstractProductA createProductA() {
        return new ProductA2();
    }
    @Override
    public AbstractProductB createProductB() {
        return new ProductB2();
    }
}
</code></pre>
<pre><code>//AbstractProductA.java
public abstract class AbstractProductA {
    public void shareMethod(){}
    public abstract void doSomething();
}
//AbstractProductB.java
public abstract class AbstractProductB {
    public void shareMethod(){}
    public abstract void doSomething();
}
// ProductA1.java
public class ProductA1 extends AbstractProductA{
    @Override
    public void doSomething() {
        System.out.println(&quot;product a1&quot;);
    }
}
// ProductA2.java
public class ProductA2 extends AbstractProductA{
    @Override
    public void doSomething() {
        System.out.println(&quot;product a2&quot;);
    }
}
</code></pre>
<h3 id="模板方法模式">模板方法模式</h3>
<pre><code>public abstract class HummerModel {
     public abstract void start();
     public abstract void stop();       
     public abstract void alarm();
     public abstract void engineBoom();
     public abstract void run(){
         this.start();
         this.engineBoom();
         this.alarm();
         this.stop();   
     }
}
</code></pre>
<h5 id="使用场景-2">使用场景</h5>
<ul>
<li>多个子类有共有方法，并且逻辑过程基本相同</li>
<li>重构，吧相同的代码抽取到父类中，通过<code>钩子函数约束行为</code>(实现类约束模板类行为)</li>
</ul>
<pre><code>public abstract class HummerModel {
     public abstract void start();
     public abstract void stop();       
     public abstract void alarm();
     public abstract void engineBoom();
     final public void run() {          
             this.start();              
             this.engineBoom();         
             if(this.isAlarm()){
                      this.alarm();
             }
             this.stop();
     } 
//在抽象类中，isAlarm是一个实现方法，
//其作用是模板方法根据其返回值决定是否要鸣喇叭，
//子类可以覆写该返回值控制其行为.
     protected  boolean isAlarm(){
             return true;
     }
}
</code></pre>
<h3 id="建造者模式">建造者模式</h3>
<pre><code>/** * 总结：  
* 1.静态内部类可以有静态成员(方法，属性)，而非静态内部类则不能有静态成员(方法，属性)。 
* 2.静态内部类只能够访问外部类的静态成员,而非静态内部类则可以访问外部类的所有成员(方法，属性)。 
* 3.实例化一个非静态的内部类的方法： 
*  a.先生成一个外部类对象实例 
*  OutClassTest oc1 = new OutClassTest(); 
*  b.通过外部类的对象实例生成内部类对象 
*  OutClassTest.InnerClass no_static_inner = oc1.new InnerClass(); 
*  4.实例化一个静态内部类的方法： 
*  a.不依赖于外部类的实例,直接实例化内部类对象 
*  OutClassTest.InnerStaticClass inner = new OutClassTest.InnerStaticClass(); 
*  b.调用内部静态类的方法或静态变量,通过类名直接调用 
*  OutClassTest.InnerStaticClass.static_value 
*  OutClassTest.InnerStaticClass.getMessage() 
*/
public class Person {
    private final int id;//身份证号
    private final String name;//姓名
    private int age;//年龄
    private boolean sex;//性别
    private String desc;//个人描述
    private Person(Builder builder){
        this.id=builder.id;
        this.name=builder.name;
        this.age=builder.age;
        this.sex=builder.sex;
        this.desc=builder.desc;
    }
    public static class Builder{
        private final int id;
        private final String name;
        private int age;
        private boolean sex;
        private String desc;
        public Builder(int id, String name) {
            this.id = id;
            this.name = name;
        }
        public Builder age(int age){
            //年龄合法性检查
            if(age&lt;0)throw new IllegalArgumentException();
            else this.age=age;
            return this;
        }
        public Builder sex(boolean sex){
            this.sex=sex;
            return this;
        }
        public Builder desc(String desc){
            this.desc=desc;
            return this;
        }
        public Person build(){
            return new Person(this);
        }
    }
}
</code></pre>
<h3 id="代理模式">代理模式</h3>
<p>为其他对象提供一种代理以控制对该对象的访问</p>
<h5 id="简单静态代理">简单静态代理</h5>
<pre><code>public class GamePlayerProxy implements IGamePlayer {
     private IGamePlayer gamePlayer = null;     
     public GamePlayerProxy(IGamePlayer _gamePlayer){
             this.gamePlayer = _gamePlayer;
     }
     @Override
     public void killBoss() {
             this.gamePlayer.killBoss();
     }
     @Override
     public void login(String user, String password) {
             this.gamePlayer.login(user, password);
     }
     @Override
     public void upgrade() {
             this.gamePlayer.upgrade();
     }
}
</code></pre>
<h5 id="动态代理">动态代理</h5>
<pre><code>//IGamePlayer.java
public interface IGamePlayer {
    void login(String username,String password);
    void killBoss();
    void upgrade();
}
// GamePlayer.java
public class GamePlayer implements IGamePlayer{
    private String username;
    private String password;
    public GamePlayer(String username) {
        this.username = username;
    }
    @Override
    public void login(String username, String password) {
        this.username = username;
        this.password = password;
        System.out.println(username+&quot; login!&quot;);
    }
    @Override
    public void killBoss() {
        System.out.println(username+&quot; kill boss!&quot;);
    }
    @Override
    public void upgrade() {
        System.out.println(username+&quot; kill upgrade!&quot;);
    }
}
// GamePlayIH.java
public class GamePlayIH implements InvocationHandler {
    private Object obj;
    public GamePlayIH(Object _obj){
        this.obj = _obj;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object result = method.invoke(this.obj,args);
        if(method.getName().equalsIgnoreCase(&quot;login&quot;))
            System.out.println(&quot;some one login in with my account!&quot;);
        return result;
    }
}
// Usage
IGamePlayer player = new GamePlayer(&quot;zhangsan&quot;);
InvocationHandler handler = new GamePlayIH(player);
ClassLoader loader = player.getClass().getClassLoader();
IGamePlayer proxy = (IGamePlayer) Proxy.newProxyInstance(loader,new Class[]{IGamePlayer.class},handler);
proxy.login(&quot;zhangsan&quot;,&quot;root&quot;);
proxy.killBoss();
proxy.upgrade();
</code></pre>
<h5 id="使用动态代理实现前置后置通知">使用动态代理实现前置后置通知</h5>
<pre><code>// IAdvice.java
public interface IAdvice {
    void exec();
}
//BeforeAdvice.java
public class BeforeAdvice implements IAdvice{
    @Override
    public void exec() {
        System.out.println(&quot;this is a before advice!&quot;);
    }
}
// AfterAdvice.java
public class AfterAdvice implements IAdvice{
    @Override
    public void exec() {
        System.out.println(&quot;this is a after advice!&quot;);
    }
}
//MyInvocationHandler.java
public class MyInvocationHandler implements InvocationHandler {
    private Object obj;
    public MyInvocationHandler(Object obj) {
        this.obj = obj;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        return method.invoke(obj,args);
    }
}
//Subject.java
public interface Subject {
    void doSomething(String args);
}
//RealSubject.java
public class RealSubject implements Subject{
    @Override
    public void doSomething(String args) {
        System.out.println(&quot;do something!---&gt;&quot;+args);
    }
}
// DynamicProxy.java
public class DynamicProxy {
    public static void newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler){
        if(true){
            new BeforeAdvice().exec();
        }
        Subject subject = (Subject) Proxy.newProxyInstance(loader,interfaces,handler);
        subject.doSomething(&quot;execute!&quot;);
        if(true){
            new AfterAdvice().exec();
        }
    }
}
</code></pre>
<h3 id="观察者模式">观察者模式</h3>
<p>定义对象间一对多的依赖关系使得每当对象状态改变，则所有依赖它的对象都会得到通知并自动更新</p>
<pre><code>// Observer.java
public interface Observer {
    void update();
}
// ConcreteObserver.java
public class ConcreteObserver implements Observer{
    @Override
    public void update() {
        System.out.println(&quot;接受消息并进行处理！&quot;);
    }
}
// Subject.java
public abstract class Subject {
    private Vector&lt;Observer&gt; observers = new Vector&lt;&gt;();
    public void addObserver(Observer o){
        observers.add(o);
    }
    public void deleteObserver(Observer o){
        observers.remove(o);
    }
    public void notifyObserver(){
        for (Observer o:observers) {
            o.update();
        }
    }
}
// ConcreteSubject.java
public class ConcreteSubject extends Subject{
    public void doSomething(){
        System.out.println(&quot;logic processing!&quot;);
        super.notifyObserver();
    }
}
// Usage
ConcreteSubject subject = new ConcreteSubject();
        Observer observer = new ConcreteObserver();
        subject.addObserver(observer);
        subject.doSomething();
</code></pre>
<h3 id="门面模式">门面模式</h3>
<p>要求一个子系统的外部与其内部通信必须通过一个统一的对象进行，门面模式提供一个高层次的接口，使得子系统更容易使用。</p>
<pre><code>// LoginClassFlutter.java
public class ClassA {
     public void doSomethingA(){
             //业务逻辑
     }
}
public class ClassB {
     public void doSomethingB(){
             //业务逻辑
     }
}
public class ClassC {
     public void doSomethingC(){
             //业务逻辑
     }
}
// Facade.java
public class Facade {
     //被委托的对象
     private ClassA a = new ClassA();
     private ClassB b = new ClassB();
     private ClassC c = new ClassC();
     //提供给外部访问的方法
     public void methodA(){
             this.a.doSomethingA();
     }
     public void methodB(){
             this.b.doSomethingB();
     }
     public void methodC(){
             this.c.doSomethingC();
     }
}
</code></pre>
<h3 id="装饰者模式">装饰者模式</h3>
<p>动态的给以一个对象添加一些额外的职责，就增加功能来说，装饰着模式相比生成子类更加灵活</p>
<pre><code>//Component.java
public abstract class Component {
    public abstract void operate();
}
//ConcreteComponent.java
public class ConcreteComponent extends Component{
    @Override
    public void operate() {
        System.out.println(&quot;do something operate!&quot;);
    }
}
//Decorator.java (extent `Component`)
public abstract class Decorator extends Component{
    private Component component = null;
    public Decorator(Component component) {
        this.component = component;
    }
    @Override
    public void operate() {
        this.component.operate();
    }
}
//ConcreteDecorator1.java
public class ConcreteDecorator1 extends Decorator{
    public ConcreteDecorator1(Component component) {
        super(component);
    }
    private void method1(){
        System.out.println(&quot;method1 operate!&quot;);
    }
    @Override
    public void operate() {
        this.method1();
        super.operate();
    }
}
// Usage
Component component = new ConcreteComponent();
component = new ConcreteDecorator1(component);
component = new ConcreteDecorator2(component);
component.operate();
</code></pre>
<h5 id="应用场景">应用场景</h5>
<ul>
<li>需要扩展一个类的功能</li>
<li>需要动态地给一个对象增加功能，也可动态撤销</li>
<li>需要为一批兄弟类怎行改装或加装功能</li>
</ul>
<h3 id="责任链模式">责任链模式</h3>
<p>使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系，将这些对象连接成一条链，并沿着这条链传递该请求，直到有对象处理该请求为止。</p>
<pre><code>class Level{}
class Request{
    public Level getRequestLevel(){
        return null;
    }
}
class Response{}
// Handler.java(abstract interface)
public abstract class Handler {
    private Handler nextHandler;
    public final Response handleMessage(Request request){
        Response response = null;
        if(this.getHandlerLevel().equals(request.getRequestLevel())){
            response = this.echo(request);
        }else {
            if(this.nextHandler != null){
                response = this.nextHandler.handleMessage(request);
            }else {
                System.out.println(&quot; no handler exception&quot;);
                return null;
            }
        }
        return response;
    }
    public void setNext(Handler _handler){
        this.nextHandler = _handler;
    }
    protected abstract Level getHandlerLevel();
    protected abstract Response echo(Request request);
}
// ConcreteHandler1.java
//ConcreteHandler2.java 同
//ConcreteHandler3.java 同
public class ConcreteHandler1 extends Handler{
    @Override
    protected Level getHandlerLevel() {
        //设置自己的处理级别
        return null;
    }
    @Override
    protected Response echo(Request request) {
        //完成处理逻辑
        return null;
    }
}
// Usage
Handler handler1 = new ConcreteHandler1();
Handler handler2 = new ConcreteHandler2();
Handler handler3 = new ConcreteHandler3();
handler1.setNext(handler2);
handler2.setNext(handler3);
Response response = handler1.handleMessage(new Request());
</code></pre>
<h3 id="访问者模式">访问者模式</h3>
<p>封装一些作用与某种数据结构的中的各种元素操作，它可以在不改变数据结构的前提下定义作用于这些元素的新操作</p>
<pre><code>// Element.java
public abstract class Element {
    public abstract void doSomething();
    public abstract void accept(IVisitor visitor);
}
// ConcreteElement1.java
// ConcreteElement2.java 同
public class ConcreteElement1 extends Element{
    @Override
    public void doSomething() {
        System.out.println(&quot;processing... 1&quot;);
    }
    @Override
    public void accept(IVisitor visitor) {
        visitor.visit(this);
    }
}
// IVisitor.java
public interface IVisitor {
    public void visit(ConcreteElement1 element1);
    public void visit(ConcreteElement2 element2);
}
//Visitor.java
public class Visitor implements IVisitor{
    @Override
    public void visit(ConcreteElement1 element1) {
        element1.doSomething();
    }
    @Override
    public void visit(ConcreteElement2 element2) {
        element2.doSomething();
    }
}
// Usage
Element element = createElement();
element.accept(new Visitor());
</code></pre>
<h3 id="命令模式">命令模式</h3>
<p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能</p>
<pre><code>// Receiver.java
public abstract class Receiver {
    public abstract void doSomething();
}
// ConcreteReceiver1.java
// ConcreteReceiver2.java 同
public class ConcreteReceiver1 extends Receiver {
    @Override
    public void doSomething() {
        System.out.println(&quot;receiver 1&quot;);
    }
}
//Command.java
public abstract class Command {
    public abstract void execute();
}
// ConcreteCommand1.java
// ConcreteCommand2.java
public class ConcreteCommand1 extends Command {
    private Receiver receiver;
    public ConcreteCommand1(Receiver receiver) {
        this.receiver = receiver;
    }
    @Override
    public void execute() {
        this.receiver.doSomething();
    }
}
//Invoke.java
public class Invoke {
    private Command command;
    public void setCommand(Command command) {
        this.command = command;
    }
    public void action(){
        this.command.execute();
    }
}
//Usage
Invoke invoke = new Invoke();
Receiver receiver = new ConcreteReceiver1();
Command command = new ConcreteCommand1(receiver);
invoke.setCommand(command);
invoke.action();
</code></pre>
]]></content>
    </entry>
</feed>